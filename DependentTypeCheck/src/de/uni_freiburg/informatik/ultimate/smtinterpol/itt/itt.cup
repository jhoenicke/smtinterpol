/*
 * Copyright (C) 2009-2012 University of Freiburg
 *
 * This file is part of SMTInterpol.
 *
 * SMTInterpol is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SMTInterpol is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SMTInterpol.  If not, see <http://www.gnu.org/licenses/>.
 */
/* CUP specification for ITT */

package de.uni_freiburg.informatik.ultimate.smtinterpol.itt;
import java.util.ArrayList;
import java.util.HashMap;
import java_cup.runtime.Symbol;

parser Parser;
option symbols = LexerSymbols;
option java15, compact_red, newpositions;

parser code {:
	String filename;

	public void report_error(String s, Object sym) {
		String location;
		if (sym instanceof MySymbolFactory.LineColumnSymbol) {
			MySymbolFactory.LineColumnSymbol bsym = (MySymbolFactory.LineColumnSymbol) sym;
			location = bsym.getLocation();
		} else if ((sym instanceof Symbol) 
				&& ((Symbol)sym).sym == LexerSymbols.EOF) {
			location = "EOF";
		} else {
			location = "UNKNOWN";
		}
		System.err.println(filename+":"+location+": "+s);
	}

	public void report_error(String s) {	
		report_error(s, cur_token);
	}

	public void syntax_error(Symbol sym) {
		report_error("Syntax Error", sym);
	}

	public void setFileName(String filename) {
		this.filename = filename;
	}
:}

action code {:
	InductiveType inductiveType;
	int inductiveIndex;
	
	ArrayList<String> varNames;
	ArrayList<Term> varTypes;
	ArrayList<Integer> lastEntry;
	HashMap<String, Term> globals;
	HashMap<String, Integer> locals;
	
	{
		globals = new HashMap<String,Term>();
		globals.put("U", Term.universe(0));
		locals = new HashMap<String, Integer>();
		varNames = new ArrayList<String>();
		varTypes = new ArrayList<Term>();
		lastEntry = new ArrayList<Integer>();
	}
	
	public Term lookupName(String id) {
		if (locals.containsKey(id)) {
			int index = locals.get(id);
			int debruijn = varTypes.size() - 1 - index;
			return Term.variable(debruijn, varTypes.get(index));
		}
		if (globals.containsKey(id)) {
			return globals.get(id);
		}
		if (id.startsWith("U")) {
			try {
				int num = Integer.parseInt(id.substring(1));
				return Term.universe(num);
			} catch (NumberFormatException ex) {
				/* ignore */
			}
		}
		return null;
	}
	
	public void pushBruijnVariable(String name, Term type, Symbol type$) {
		if (!(type.getType().evaluateHead() instanceof UniverseTerm))
			parser.report_error("expected set type", type$);
		varNames.add(name);
		varTypes.add(type);
		lastEntry.add(locals.get(name));
		locals.put(name, varNames.size()-1);
	}

	public void popBruijnVariable() {
		int index = varNames.size()-1;
		String name = varNames.remove(index);
		varTypes.remove(index);
		Integer last = lastEntry.remove(index);
		if (last == null)
			locals.remove(name);
		else
			locals.put(name, last);
	}

	public void registerType(InductiveType type) {
		for (int i = 0; i < type.mConstrs.length; i++) {
			globals.put(type.mConstrs[i].toString(), type.mConstrs[i]);
		}
		globals.put(type.mRecOperator.toString(), type.mRecOperator);
	}
:}

/*init with {: getScanner().init(); :} */
scan with {: return getScanner().next_token(); :}


/* Keywords */
terminal INDUCTIVE, DEFINITION, CHECK, TYPECHECK, EVALUATETYPE, EVALUATE, ASSUME;
/* Symbols */
terminal ARROW, COLON, LPAR, RPAR, LAMBDA, COMMA, EQUALS;
terminal String ID;

non terminal goal, declaration, inductivedecl;
non terminal Term inductivetype;
non terminal Term expr, expr2, expr3;
non terminal Term exprPi, exprPiFront, exprApp, exprLambda, exprInLambda;
non terminal Constructor constrdecl;
non terminal ArrayList<Constructor> constrdecls;


goal ::= declaration*;

declaration ::= inductivedecl
	| ASSUME ID:i COLON expr:t
	  {:
		globals.put(i, new Assumption(i, t));
	  :}
	| DEFINITION ID:i EQUALS expr:e
	  {: e.setName(i); globals.put(i, e); :}
	| CHECK expr:e1 EQUALS expr:e2
	  {:
		if (!e1.equals(e2))
			parser.report_error("Check failed: " + e1.evaluate()
					+ " is not " + e2.evaluate(), e1$);
	  :}
	| TYPECHECK expr2:e COLON expr:t
	  {:
		if (!e.getType().isSubType(t))
			parser.report_error("TypeCheck failed: " + e.getType().evaluate()
					+ " is not " + t.evaluate(), e$);
	  :}
	| EVALUATETYPE expr:e
	  {: System.out.println(e.getType().evaluate()); :}
	| EVALUATE expr:e
	  {: System.out.println(e.evaluate()); :}
	;

inductivedecl ::= INDUCTIVE ID:i COLON inductivetype:type
	  {:
		inductiveType = new InductiveType(i, type);
		inductiveIndex = 0;
		globals.put(i, inductiveType);
	  :}
	  EQUALS constrdecls?:constrs
	  {:
		for (int j = 0; j < inductiveType.mParams.length; j++)
			popBruijnVariable();
		inductiveType.setConstructors(constrs);
		registerType(inductiveType);
		inductiveType = null;
	  :};

inductivetype ::= exprPiFront:exprDom
	  inductivetype:exprRng
	  {: 	RESULT = new PiTerm(exprDom, exprRng); :}
	| ID:u
	  {:
		RESULT = lookupName(u);
		if (!RESULT.equals(Term.universe(0)))
			parser.report_error("expected type U", u$);
	  :}
	;

constrdecls ::=
	constrdecl:d {: RESULT = new ArrayList<Constructor>(); RESULT.add(d); :}
	| constrdecls:l COMMA constrdecl:d {: l.add(d); RESULT = l; :};

constrdecl ::=
	ID:i COLON expr:e
	{: 
		try {
			RESULT = new Constructor(i, inductiveIndex++, inductiveType, e);
		} catch (IllegalArgumentException ex) {
			parser.report_error(ex.getMessage());
			RESULT = null;
		}
	:} 
	;

expr ::= exprPi
	| exprLambda
	| expr2
	;
expr2 ::= exprApp
	| expr3
	;
expr3 ::= ID:i
	{:
		RESULT = lookupName(i);
		if (RESULT == null)
			parser.report_error("Undefined Symbol " + i, i$);
	:}
	| LPAR expr:e {: RESULT = e; :} RPAR
	;

exprInLambda ::= exprLambda:expr
	| ARROW expr:expr {: RESULT = expr; :}
	;

exprApp ::= expr2:exprFunc expr3:exprArg
	{:
		Term exprFuncType = exprFunc.getType();
		exprFuncType = exprFuncType.evaluateHead();
		if (!(exprFuncType instanceof PiTerm))
			parser.report_error("Applying to a non-function", exprArg$);
		else if (!exprArg.getType().isSubType(((PiTerm)exprFuncType).mDomain))
			parser.report_error("Argument has wrong type "+exprArg.getType().evaluate() +
				" expected: " + ((PiTerm)exprFuncType).mDomain.evaluate(), exprArg$);
		RESULT = new AppTerm(exprFunc, exprArg);
	:}
	;
exprLambda ::= LAMBDA ID:i COLON expr2:exprArg
	{:
		pushBruijnVariable(i, exprArg, exprArg$);
	:}
	exprInLambda:exprSub
	{:
		popBruijnVariable();
		RESULT = new LambdaTerm(exprArg, exprSub);
	:}
	;
exprPi ::= exprPiFront:exprDom expr:exprRng
	{:
		popBruijnVariable();
		if (!(exprRng.getType().evaluateHead() instanceof UniverseTerm))
			parser.report_error("expected set type", exprRng$);
		RESULT = new PiTerm(exprDom, exprRng);
	:}
	;

exprPiFront ::=
	ID:i COLON expr2:exprDom ARROW
	{: pushBruijnVariable(i, exprDom, exprDom$); RESULT = exprDom; :}
	| expr2:exprDom ARROW
	{: pushBruijnVariable("", exprDom, exprDom$); RESULT = exprDom; :}
	;
