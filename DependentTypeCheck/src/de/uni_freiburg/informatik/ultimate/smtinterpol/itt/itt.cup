/*
 * Copyright (C) 2009-2012 University of Freiburg
 *
 * This file is part of SMTInterpol.
 *
 * SMTInterpol is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SMTInterpol is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SMTInterpol.  If not, see <http://www.gnu.org/licenses/>.
 */
/* CUP specification for ITT */

package de.uni_freiburg.informatik.ultimate.smtinterpol.itt;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.HashMap;
import java_cup.runtime.Symbol;

parser Parser;
option symbols = LexerSymbols;
option java15, compact_red, newpositions;

parser code {:
	String filename;

	public void report_error(String s, Object sym) {
		String location;
		if (sym instanceof MySymbolFactory.LineColumnSymbol) {
			MySymbolFactory.LineColumnSymbol bsym = (MySymbolFactory.LineColumnSymbol) sym;
			location = bsym.getLocation();
		} else if ((sym instanceof Symbol) 
				&& ((Symbol)sym).sym == LexerSymbols.EOF) {
			location = "EOF";
		} else {
			location = "UNKNOWN";
		}
		System.err.println(filename+":"+location+": "+s);
	}

	public void report_error(String s) {	
		report_error(s, cur_token);
	}

	public void syntax_error(Symbol sym) {
		report_error("Syntax Error", sym);
	}

	public void setFileName(String filename) {
		this.filename = filename;
	}
:}

action code {:
	InductiveType inductiveType;
	int inductiveIndex;
	
	ArrayList<LocalInfo> gamma;
	HashMap<String, Term> globals;
	HashMap<String, Integer> locals;
	
	{
		globals = new HashMap<String,Term>();
		globals.put("U", Term.universe(0));
		locals = new HashMap<String, Integer>();
		gamma = new ArrayList<LocalInfo>();
	}
	
	public Term lookupName(String id) {
		if (locals.containsKey(id)) {
			int index = locals.get(id);
			LocalInfo info = gamma.get(index);
			if (info.mIsLet) {
				int offset = gamma.size() - index;
				return Term.substitute(info.mTerm,
					Substitution.shift(offset), null);
			} else {
				int debruijn = gamma.size() - 1 - index;
				return Term.variable(debruijn, info.mTerm);
			}
		}
		if (globals.containsKey(id)) {
			return globals.get(id);
		}
		if (id.startsWith("U")) {
			try {
				int num = Integer.parseInt(id.substring(1));
				return Term.universe(num);
			} catch (NumberFormatException ex) {
				/* ignore */
			}
		}
		return null;
	}

	public Term buildAppTerm(Term exprFunc, Term exprArg, Symbol symbol) {
		try {
			return Term.buildApplication(exprFunc, exprArg);
		} catch (IllegalArgumentException ex) {
			parser.report_error(ex.getMessage(), symbol);
			return null;
		}
	}
	
	public void pushBruijnVariable(LocalInfo info, Symbol type$) {
		if (!info.mIsLet &&
		    !(info.mTerm.getType().evaluateHead() instanceof UniverseTerm))
			parser.report_error("expected set type", type$);
		Integer lastIndex = locals.put(info.mName, gamma.size());
		info.mLastIndex = lastIndex != null ? (int) lastIndex : -1;
		gamma.add(info);
	}

	public void popBruijnVariable() {
		LocalInfo info = gamma.remove(gamma.size()-1);
		if (info.mLastIndex == -1)
			locals.remove(info.mName);
		else
			locals.put(info.mName, info.mLastIndex);
	}

	public void registerType(InductiveType type) {
		for (int i = 0; i < type.mConstrs.length; i++) {
			globals.put(type.mConstrs[i].toString(), type.mConstrs[i]);
		}
		globals.put(type.mRecOperator.toString(), type.mRecOperator);
	}
:}

/*init with {: getScanner().init(); :} */
scan with {: return getScanner().next_token(); :}


/* Keywords */
terminal INDUCTIVE, DEFINITION, CHECK, TYPECHECK, EVALUATETYPE, EVALUATE;
terminal ASSUME, LET;
/* Symbols */
terminal ARROW, COLON, LPAR, RPAR, LAMBDA, COMMA, EQUALS, LBRA, RBRA;
terminal String ID;

non terminal goal, declaration, inductivedecl;
non terminal Term inductivetype;
non terminal Term expr, expr2, expr3;
non terminal Term exprPi, exprApp, exprLambda, exprInLambda;
non terminal LocalInfo exprPiFront, exprLambdaFront;
non terminal Constructor constrdecl;
non terminal ArrayList<Constructor> constrdecls;


goal ::= declaration*;

declaration ::= inductivedecl
	| ASSUME ID:i COLON expr:t
	  {:
		globals.put(i, new Assumption(i, t));
	  :}
	| DEFINITION ID:i EQUALS expr:e
	  {: e.setName(i); globals.put(i, e); :}
	| CHECK expr:e1 EQUALS expr:e2
	  {:
		if (!e1.equals(e2))
			parser.report_error("Check failed: " + e1.evaluate()
					+ " is not " + e2.evaluate(), e1$);
	  :}
	| TYPECHECK expr2:e COLON expr:t
	  {:
		if (!e.getType().isSubType(t))
			parser.report_error("TypeCheck failed: " + e.getType().evaluate()
					+ " is not " + t.evaluate(), e$);
	  :}
	| EVALUATETYPE expr:e
	  {: System.out.println(e.getType().evaluate()); :}
	| EVALUATE expr:e
	  {: System.out.println(e.evaluate()); :}
	;

inductivedecl ::= INDUCTIVE ID:i COLON inductivetype:type
	  {:
		inductiveType = new InductiveType(i, type);
		inductiveIndex = 0;
		globals.put(i, inductiveType);
	  :}
	  EQUALS constrdecls?:constrs
	  {:
		for (int j = 0; j < inductiveType.mParams.length; j++)
			popBruijnVariable();
		inductiveType.setConstructors(constrs);
		registerType(inductiveType);
		inductiveType = null;
	  :};

inductivetype ::= exprPiFront:varInfo
	  inductivetype:exprRng
	  {: 	RESULT = new PiTerm(varInfo.mTerm, exprRng); :}
	| ID:u
	  {:
		RESULT = lookupName(u);
		if (!RESULT.equals(Term.universe(0)))
			parser.report_error("expected type U", u$);
	  :}
	;

constrdecls ::=
	constrdecl:d {: RESULT = new ArrayList<Constructor>(); RESULT.add(d); :}
	| constrdecls:l COMMA constrdecl:d {: l.add(d); RESULT = l; :};

constrdecl ::=
	ID:i COLON expr:e
	{: 
		try {
			RESULT = new Constructor(i, inductiveIndex++, inductiveType, e);
		} catch (IllegalArgumentException ex) {
			parser.report_error(ex.getMessage());
			RESULT = null;
		}
	:} 
	;

expr ::= exprPi
	| exprLambda
	| ASSUME expr:e
	{: RESULT = new Assumption("", e); :}
	| expr2
	;
expr2 ::= exprApp
	| expr3
	;
expr3 ::= ID:i
	{:
		RESULT = lookupName(i);
		if (RESULT == null)
			parser.report_error("Undefined Symbol " + i, i$);
	:}
	| LPAR expr:e {: RESULT = e; :} RPAR
	;

exprInLambda ::= exprLambda:expr
	| ARROW expr:expr {: RESULT = expr; :}
	;

exprApp ::= expr2:exprFunc expr3:exprArg
	{:
		Term exprFuncType = exprFunc.getType();
		RESULT = buildAppTerm(exprFunc, exprArg, exprArg$);
	:}
	;
exprLambda ::= 
	exprLambdaFront:varInfo exprInLambda:exprSub
	{:
		popBruijnVariable();
		try {
			if (varInfo.mIsLet) {
				RESULT = Term.substitute(exprSub, 
					Substitution.cons(varInfo.mTerm, Substitution.shift(0), 
							exprSub.numFreeVariables()), null);
			} else {
				RESULT = new LambdaTerm(varInfo.mTerm, exprSub);
			}
		} catch (IllegalArgumentException ex) {
			parser.report_error(ex.getMessage(), varInfo$);
			RESULT = null;
		}
	:}
	;
exprLambdaFront ::= LAMBDA ID:i COLON expr2:exprArg
	{:
		RESULT = new LocalInfo(i, exprArg);
		pushBruijnVariable(RESULT, exprArg$);
	:}
	| LBRA LAMBDA ID:i COLON expr2:exprArg RBRA
	{:
		RESULT = new LocalInfo(i, exprArg);
		pushBruijnVariable(RESULT, exprArg$);
	:}
	| LET ID:i EQUALS expr2:exprArg
	{:
		RESULT = new LocalInfo(i, exprArg, true);
		pushBruijnVariable(RESULT, exprArg$);
	:}
	;

exprPi ::= exprPiFront:varInfo expr:exprRng
	{:
		popBruijnVariable();
		if (!(exprRng.getType().evaluateHead() instanceof UniverseTerm))
			parser.report_error("expected set type", exprRng$);
		RESULT = new PiTerm(varInfo.mTerm, exprRng);
	:}
	;

exprPiFront ::=
	ID:i COLON expr2:exprDom ARROW
	{: RESULT = new LocalInfo(i, exprDom);
	   pushBruijnVariable(RESULT, exprDom$); :}
	| LBRA ID:i COLON expr2:exprDom RBRA ARROW
	{: RESULT = new LocalInfo(i, exprDom);
	   pushBruijnVariable(RESULT, exprDom$); :}
	| expr2:exprDom ARROW
	{: RESULT = new LocalInfo("", exprDom);
	   pushBruijnVariable(RESULT, exprDom$); :}
	;
