;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Equality Type

; Now we create the Identity type to express equalities.
Inductive I : A:U -> a:A -> b:A -> U =
  r : I a a

; The standard rules for substitution, symmetry and reverse substitution
Definition I.subst =
  \A:U \r:A \s:A \eq:I r s \C:(A -> U) ->
  I.rec r (\x:A \eq:I r x -> C r -> C x) (\x:C r -> x) s eq

TypeCheck I.subst : A:U -> r:A -> s:A -> I r s -> C:(A -> U) -> C r -> C s

Definition I.symm = \A:U \r:A \s:A \eq:I r s ->
  I.subst eq (\x:A -> I x r) (I.r r)
TypeCheck I.symm : A:U -> r:A -> s:A -> I r s -> I s r

Definition I.rsubst =
  \A:U \r:A \s:A \eq:I s r ->
  I.subst (I.symm eq)
TypeCheck I.rsubst : A:U -> r:A -> s:A -> I s r -> C:(A -> U) -> C r -> C s

Definition I.trans = \A:U \a:A \b:A \eq1:I a b \c:A \eq2:I b c ->
  I.subst eq2 (\x:A -> I a x) eq1
TypeCheck I.trans : A:U -> r:A -> s:A ->I r s ->  t:A -> I s t -> I r t
Definition I.trans2 = \A:U \a:A \b:A \eq1:I a b \c:A \eq2:I b c \d:A \eq3:I c d ->
  I.trans eq1 (I.trans eq2 eq3)
Definition I.trans3 = \A:U \a:A \b:A \eq1:I a b \c:A \eq2:I b c
  \d:A \eq3:I c d \e:A \eq4:I d e ->
  I.trans2 eq1 eq2 (I.trans eq3 eq4)

Definition I.cong = \A:U \B:U
  \c:(A -> B) \a:A \b:A \eq: I a b ->
    I.subst eq (\x:A -> I (c a) (c x)) (I.r (c a))
TypeCheck I.cong :
  A:U -> B:U -> c:(A -> B) -> a:A -> b:A -> I a b -> I (c a) (c b)
Definition I.cong2 = \A:U \B:U \C:U \f:(A->B->C)
  \a1:A \a2:A \eq1: I a1 a2 \b1:B\b2:B \eq2: I b1 b2 ->
  I.subst eq1 (\x:A -> I (f a1 b1) (f x b2)) (I.cong (f a1) eq2)
TypeCheck I.cong2 :
  A:U -> B:U -> C:U -> f:(A -> B -> C) -> a1:A -> a2:A -> I a1 a2 ->
  b1:B -> b2:B -> I b1 b2 -> I (f a1 b1) (f a2 b2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Natural Numbers

Inductive Nat : U =
   0    : Nat,
   succ : Nat -> Nat
Evaluate Nat

Definition Nat.plus =
  \a:Nat -> Nat.rec (\n:Nat -> Nat) a (\n:Nat \r:Nat -> Nat.succ r)
Definition Nat.mul =
  \a:Nat -> Nat.rec (\n:Nat -> Nat) Nat.0 (\n:Nat \r:Nat -> (Nat.plus r a))
Definition Nat.mul2 =
  Nat.rec (\n:Nat -> Nat) Nat.0 (\n:Nat \r:Nat -> Nat.succ (Nat.succ r))

; prove n = 0 + n
Definition Nat.plus.symm0 =
  Nat.rec (\n:Nat -> I n (Nat.plus Nat.0 n))
         (I.r Nat.0)
         (\n:Nat \r:(I n (Nat.plus Nat.0 n)) -> I.cong Nat.succ r)
TypeCheck Nat.plus.symm0 : n:Nat -> I n (Nat.plus Nat.0 n)

; prove succ(m + n) = (succ m) + n
Definition Nat.plus.symmstep = \m:Nat -> 
  Nat.rec (\n:Nat -> I (Nat.succ (Nat.plus m n)) (Nat.plus (Nat.succ m) n))
      (I.r (Nat.succ m))
      (\n:Nat \r:I (Nat.succ (Nat.plus m n)) (Nat.plus (Nat.succ m) n) ->
         I.cong Nat.succ r)
TypeCheck Nat.plus.symmstep : m:Nat -> n:Nat ->
                     I (Nat.succ (Nat.plus m n)) (Nat.plus (Nat.succ m) n)

; Now prove n + m = m + n
Definition Nat.plus.symm =
  Nat.rec (\m:Nat -> n:Nat -> I (Nat.plus n m) (Nat.plus m n))
        Nat.plus.symm0
        (\m:Nat \r:(n:Nat -> I (Nat.plus n m) (Nat.plus m n))
         \n:Nat -> 
	       I.trans (I.cong Nat.succ (r n)) (Nat.plus.symmstep m n))
TypeCheck Nat.plus.symm : m:Nat -> n:Nat -> I (Nat.plus n m) (Nat.plus m n)

; (a+b)+c = a+(b+c)
Definition Nat.plus.assoc = \a:Nat \b:Nat ->
  Nat.rec (\c:Nat -> I (Nat.plus (Nat.plus a b) c) (Nat.plus a (Nat.plus b c)))
     (I.r (Nat.plus a b))
     (\c:Nat
      \hyp:(I (Nat.plus (Nat.plus a b) c) (Nat.plus a (Nat.plus b c))) ->
      I.cong Nat.succ hyp)
TypeCheck Nat.plus.assoc : a:Nat -> b:Nat -> c:Nat ->
                      I (Nat.plus (Nat.plus a b) c)
                             (Nat.plus a (Nat.plus b c))
; (a+b)+(c+d) = a+(b+(c+d)) = a+((b+c)+d)
Definition Nat.plus.assoc4 = \a:Nat \b:Nat \c:Nat \d:Nat ->
  I.trans   (Nat.plus.assoc a b (Nat.plus c d))
            (I.cong (Nat.plus a) (I.symm (Nat.plus.assoc b c d)))

; (a+b)+(c+d) = a+((b+c)+d) = (a+c)+(b+d)
Definition Nat.plus.symmassoc = \a:Nat \b:Nat \c:Nat \d:Nat ->
  I.trans2
    (Nat.plus.assoc4 a b c d)
    (I.cong (\x:Nat -> Nat.plus a (Nat.plus x d)) (Nat.plus.symm c b))
    (I.symm (Nat.plus.assoc4 a c b d))
TypeCheck Nat.plus.symmassoc : a:Nat -> b:Nat -> c:Nat -> d:Nat ->
  I (Nat.plus (Nat.plus a b) (Nat.plus c d))
           (Nat.plus (Nat.plus a c) (Nat.plus b d))

Definition Nat.mul2.distr = \a:Nat ->
  Let Thesis = (\b:Nat -> I (Nat.plus (Nat.mul2 a) (Nat.mul2 b))
                            (Nat.mul2 (Nat.plus a b))) ->
  Nat.rec Thesis
    (I.r (Nat.mul2 a))
    (\b:Nat \Hyp:Thesis b -> (I.cong (\x:Nat -> Nat.succ (Nat.succ x)) Hyp))
TypeCheck Nat.mul2.distr : a:Nat -> b:Nat ->
  I (Nat.plus (Nat.mul2 a) (Nat.mul2 b)) (Nat.mul2 (Nat.plus a b))

; (a+b)+c = a+(b+c) = a+(c+b) = (a+c)+b
Definition Nat.plus.assocsymm2 = \a:Nat \b:Nat \c:Nat ->
  (I.trans2 (Nat.plus.assoc a b c)
            (I.cong (Nat.plus a) (Nat.plus.symm c b))
            (I.symm (Nat.plus.assoc a c b)))
              
Definition Nat.mul.symm0 =
  Nat.rec (\a:Nat -> I (Nat.mul Nat.0 a) Nat.0)
    (I.r Nat.0) 
    (\a:Nat -> \Hyp:I (Nat.mul Nat.0 a) Nat.0 -> Hyp)

; (b+1) * a = (b * a) + a
Definition Nat.mul.symmstep = \b:Nat ->
  Nat.rec (\a:Nat -> I (Nat.mul (Nat.succ b) a) (Nat.plus (Nat.mul b a) a))
    (I.r Nat.0) 
    (\a:Nat \Hyp:I (Nat.mul (Nat.succ b) a) (Nat.plus (Nat.mul b a) a) ->
     ; (b+1) * (a+1) = (b+1) * a + b+1 = (IH) ((b * a) + a) + b+1
     ; = ((b * a) + b) + a+1 = ((b+1) * (a+1)) + a+1
     I.trans (I.cong (\x:Nat -> (Nat.succ (Nat.plus x b))) Hyp)
             (I.cong Nat.succ (Nat.plus.assocsymm2 (Nat.mul b a) a b)))

; b*a = a*b
Definition Nat.mul.symm = \a:Nat ->
  Nat.rec (\b:Nat -> I (Nat.mul b a) (Nat.mul a b))
    (Nat.mul.symm0 a)
    (\b:Nat \Hyp:I (Nat.mul b a) (Nat.mul a b) ->
     ; (b+1)*a =symmstep (b*a) + a =IH (a*b) + a = a*(b+1)
     I.trans (Nat.mul.symmstep b a)
             (I.cong (\x:Nat -> Nat.plus x a) Hyp))

; (a + b)*c = a*c + b*c
Definition Nat.mul.distrib = \a:Nat \b:Nat ->
  Nat.rec (\c:Nat -> I (Nat.mul (Nat.plus a b) c) 
                       (Nat.plus (Nat.mul a c) (Nat.mul b c)))
    (I.r Nat.0)
    (\c:Nat \Hyp:I (Nat.mul (Nat.plus a b) c) 
                        (Nat.plus (Nat.mul a c) (Nat.mul b c)) ->
     ; (a+b)*(c+1) = (a+b)*c + (a+b) =Hyp (a*c + b*c) + (a+b)
     ; = (a*c + a) + (b*c + b) = a*(c+1) + b*(c+1)
     I.trans (I.cong (\x:Nat -> Nat.plus x (Nat.plus a b)) Hyp)
             (Nat.plus.symmassoc (Nat.mul a c) (Nat.mul b c) a b))

; a*(b + c) = (b + c)*a = b*a + c*a = a*b + a*c
Definition Nat.mul.distrib2 = \a:Nat \b:Nat \c:Nat ->
  I.trans2 (Nat.mul.symm (Nat.plus b c) a)
           (Nat.mul.distrib b c a)
	   (I.cong2 Nat.plus (Nat.mul.symm a b) (Nat.mul.symm a c))
TypeCheck Nat.mul.distrib2 : a:Nat -> b:Nat -> c:Nat ->
  I (Nat.mul a (Nat.plus b c)) (Nat.plus (Nat.mul a b) (Nat.mul a c))
	   
Definition Nat.mul.assoc = \a:Nat \b:Nat ->
  Nat.rec (\c:Nat -> I (Nat.mul (Nat.mul a b) c) (Nat.mul a (Nat.mul b c)))
    (I.r Nat.0)
    (\c:Nat \Hyp:I (Nat.mul (Nat.mul a b) c) (Nat.mul a (Nat.mul b c)) ->
     ;; (a*b)*(c+1) = (a*b)*c + (a*b) =Hyp 
     ;; a*(b*c) + a*b = a*(b*c + b) = a*(b*(c+1))
     I.trans (I.cong (\x:Nat -> Nat.plus x (Nat.mul a b)) Hyp)
             (I.symm (Nat.mul.distrib2 a (Nat.mul b c) b)))

Definition Nat.add10 = \n:Nat ->
	   (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ
           (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ n))))))))))
Definition Nat.mul10 =
   Nat.rec (\x:Nat -> Nat) Nat.0 
   (\x:Nat \r:Nat -> Nat.add10 r)
Definition Nat.mul10.distr = \a:Nat ->
  Nat.rec
    (\b:Nat -> I (Nat.plus (Nat.mul10 a) (Nat.mul10 b))
                   (Nat.mul10 (Nat.plus a b)))
    (I.r (Nat.mul10 a))
    (\b:Nat \Hyp:I (Nat.plus (Nat.mul10 a) (Nat.mul10 b))
                        (Nat.mul10 (Nat.plus a b)) ->
      (I.cong Nat.add10 Hyp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Binary Numbers

Inductive Bin : U =
   nil : Bin,
   0   : Bin -> Bin,
   1   : Bin -> Bin
Evaluate Bin

Inductive Carry: U =
   0 : Carry,
   1 : Carry

Definition Bin.succ = 
   Bin.rec (\x:Bin -> Bin) 
      (Bin.1 Bin.nil)
      (\a:Bin \r:Bin -> Bin.1 a)
      (\a:Bin \r:Bin -> Bin.0 r)
Definition Bin.addcarry = \a:Bin ->
   Carry.rec (\c:Carry -> Bin) a (Bin.succ a)
TypeCheck Bin.addcarry : Bin -> Carry -> Bin

Definition Bin.strip0.aux = \b:Bin ->
   Bin.rec (\x:Bin -> Bin) Bin.nil
      (\x:Bin \r:Bin -> Bin.0 b)
      (\x:Bin \r:Bin -> Bin.0 b)
      b
Definition Bin.strip0 =
   Bin.rec (\x:Bin -> Bin) Bin.nil
      (\x:Bin \r:Bin -> (Bin.strip0.aux r))
      (\x:Bin \r:Bin -> Bin.1 r)

Definition bin2nat =
   Bin.rec (\x:Bin -> Nat)
     Nat.0
     (\b:Bin \r:Nat -> Nat.mul2 r)
     (\b:Bin \r:Nat -> Nat.succ (Nat.mul2 r))

Definition Bin.succ.correct =
   Bin.rec (\b:Bin -> I (bin2nat (Bin.succ b)) (Nat.succ (bin2nat b)))
   (I.r (Nat.succ Nat.0))
   (\b:Bin \Hyp:I (bin2nat (Bin.succ b)) (Nat.succ (bin2nat b)) ->
      I.r (Nat.succ (bin2nat (Bin.0 b))))
   (\b:Bin \Hyp:I (bin2nat (Bin.succ b)) (Nat.succ (bin2nat b)) ->
      I.cong Nat.mul2 Hyp)

Definition Nat.addcarry = \n:Nat ->
   Carry.rec (\x:Carry -> Nat) n (Nat.succ n)

Definition Bin.addcarry.correct = \b:Bin ->
   Carry.rec (\c:Carry -> I (bin2nat (Bin.addcarry b c)) (Nat.addcarry (bin2nat b) c))
     (I.r (bin2nat b))
     (Bin.succ.correct b)
TypeCheck Bin.addcarry.correct : a:Bin -> c:Carry ->
   I (bin2nat (Bin.addcarry a c)) (Nat.addcarry (bin2nat a) c)


Definition nat2bin = Nat.rec (\n:Nat -> Bin) 
   Bin.nil 
   (\n:Nat -> Bin.succ)

Definition nat2bin.correct.1 = Nat.rec (\n:Nat -> I (bin2nat (nat2bin n)) n)
   (I.r Nat.0)
   (\n:Nat \Hyp:I (bin2nat (nat2bin n)) n ->
    I.trans (Bin.addcarry.correct (nat2bin n) Carry.1)
            (I.cong Nat.succ Hyp))
TypeCheck nat2bin.correct.1 : n : Nat -> I (bin2nat (nat2bin n)) n

Definition Bin.carry2bin = Carry.rec (\x:Carry -> Bin -> Bin) Bin.0 Bin.1
Definition Bin.negcarry2bin = Carry.rec (\x:Carry -> Bin -> Bin) Bin.1 Bin.0

Definition Bin.pluscarrycase0 = \a:Bin \add:(Bin -> Carry -> Bin)
                                \b:Bin \carry:Carry ->
    Bin.rec (\x:Bin -> Bin)
         (Bin.addcarry (Bin.0 a) carry)
	 (\b:Bin \r2:Bin ->
	    (Bin.carry2bin carry) (add b Carry.0))   ; 0+0+carry
	 (\b:Bin \r2:Bin ->
	    (Bin.negcarry2bin carry) (add b carry))  ; 0+1+carry
         b

Definition Bin.pluscarrycase1 = \a:Bin \add:(Bin -> Carry -> Bin)
                                \b:Bin \carry:Carry ->
     Bin.rec (\x:Bin -> Bin)
         (Bin.addcarry (Bin.1 a) carry)
	 (\b:Bin \r2:Bin ->
	    (Bin.negcarry2bin carry) (add b carry))  ; 1+0+carry
	 (\b:Bin \r2:Bin ->
	    (Bin.carry2bin carry) (add b Carry.1))   ; 1+1+carry
         b

Definition Bin.pluscarry =
   Bin.rec (\x:Bin -> Bin -> Carry -> Bin)
         (\b:Bin \carry:Carry -> Bin.addcarry b carry)
	 Bin.pluscarrycase0
	 Bin.pluscarrycase1

Definition Bin.plus = \a:Bin \b:Bin -> Bin.pluscarry a b Carry.0

TypeCheck Bin.plus : a:Bin -> b:Bin -> Bin

; Bin.succ (Bin.plus a b) = Bin.pluscarry a b Carry.1
Definition Bin.plus.pluscarry.lemma =
  Bin.rec (\a:Bin -> b:Bin -> I (Bin.succ (Bin.plus a b))
                                  (Bin.pluscarry a b Carry.1))
    (\b:Bin -> I.r (Bin.succ b))
    (\a:Bin \Hyp:(b:Bin -> I (Bin.succ (Bin.plus a b))
                                  (Bin.pluscarry a b Carry.1)) ->
     Bin.rec (\b:Bin -> I (Bin.succ (Bin.plus (Bin.0 a) b))
                               (Bin.pluscarry (Bin.0 a) b Carry.1))
	(I.r (Bin.1 a))
	(\b:Bin \_:I (Bin.succ (Bin.plus (Bin.0 a) b))
                          (Bin.pluscarry (Bin.0 a) b Carry.1) ->
         I.r (Bin.1 (Bin.plus a b)))
        (\b:Bin \_:I (Bin.succ (Bin.plus (Bin.0 a) b))
                          (Bin.pluscarry (Bin.0 a) b Carry.1) ->
	 I.cong Bin.0 (Hyp b)))
    (\a:Bin \Hyp:(b:Bin -> I (Bin.succ (Bin.plus a b))
                                  (Bin.pluscarry a b Carry.1)) ->
     Bin.rec (\b:Bin -> I (Bin.succ (Bin.plus (Bin.1 a) b))
                               (Bin.pluscarry (Bin.1 a) b Carry.1))
	(I.r (Bin.0 (Bin.succ a)))
        (\b:Bin \_:I (Bin.succ (Bin.plus (Bin.1 a) b))
                          (Bin.pluscarry (Bin.1 a) b Carry.1) ->
	 I.cong Bin.0 (Hyp b))
        (\b:Bin \_:I (Bin.succ (Bin.plus (Bin.1 a) b))
                          (Bin.pluscarry (Bin.1 a) b Carry.1) ->
         I.r (Bin.1 (Bin.pluscarry a b Carry.1))))
	   
; compute 23 + 17
Evaluate Bin.plus (Bin.1 (Bin.1 (Bin.1 (Bin.0 (Bin.1 (Bin.nil))))))
	          (Bin.1 (Bin.0 (Bin.0 (Bin.0 (Bin.1 (Bin.nil))))))

; compute 14 + 343
Evaluate Bin.plus (Bin.0 (Bin.1 (Bin.1 (Bin.1 Bin.nil))))
                  (Bin.1 (Bin.1 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.nil))))))))))

; (bin2nat ((carry2bin c) a))  = (Nat.addcarry 2*(bin2nat a) c)
Definition Bin.carry2bin.correct = \a:Bin ->
  Carry.rec (\c:Carry -> I (bin2nat ((Bin.carry2bin c) a))
	  (Nat.addcarry (Nat.mul2 (bin2nat a)) c))
          (I.r (Nat.mul2 (bin2nat a)))
	  (I.r (Nat.succ (Nat.mul2 (bin2nat a))))

TypeCheck Bin.carry2bin.correct : (a:Bin -> c:Carry ->
  I (bin2nat ((Bin.carry2bin c) a))
         (Nat.addcarry (Nat.mul2 (bin2nat a)) c))

Definition Bin.pluscarrycase0.correct =
  \a:Bin \add:(Bin -> Carry -> Bin)
  \Hyp: (b:Bin -> c:Carry ->
         I (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c))
  \b:Bin \c:Carry ->
  Bin.rec (\b:Bin ->
         I (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                           (bin2nat b)) c))
         (Bin.addcarry.correct (Bin.0 a) c)
        (\b:Bin \_:I (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                          (bin2nat b)) c) ->
	 ; bin2nat (Bin.pluscarrycase0 a add (Bin.0 b) c)
	 ;                     = bin2nat ((carry2bin c) (add b Carry.0))
	 ; {carry2bin.correct} = 2*(bin2nat (add b Carry.0)) + c
	 ; {Hyp}               = 2*((bin2nat a)  + (bin2nat b) + 0) + c
	 ;                     = 2*(bin2nat a) + 2*(bin2nat b) + c
	 ;                     = bin2nat (Bin.0 a) bin2nat (Bin.0 b) + c
	 I.trans (Bin.carry2bin.correct (add b Carry.0) c)
	         (I.cong (\x:Nat -> Nat.addcarry x c)
		         (I.trans (I.cong Nat.mul2 (Hyp b Carry.0))
		                  (I.symm (Nat.mul2.distr (bin2nat a) (bin2nat b))))))
        (\b:Bin \_:I (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                           (bin2nat b)) c)  ->
         Carry.rec (\c:Carry -> I (bin2nat ((Bin.negcarry2bin c) (add b c)))
                   (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
                                 (Nat.succ (Nat.mul2 (bin2nat b)))) c))
	     ; bin2nat (Bin.pluscarrycase1 a add (Bin.1 b) 0)
	     ;                     = bin2nat (Bin.1 (add b Bin.0))
	     ;                     = 2*(bin2nat (add b 0)) + 1
	     ; {Hyp}               = 2*((bin2nat a)  + (bin2nat b) + 0) + 1
	     ;                     = 2*(bin2nat a) + 2*(bin2nat b) + 1
	     ;                     = bin2nat (Bin.0 a) bin2nat (Bin.1 b) + 0
             (I.cong Nat.succ
	        (I.trans (I.cong Nat.mul2 (Hyp b Carry.0))
	                 (I.symm (Nat.mul2.distr (bin2nat a) (bin2nat b)))))
	     (I.trans (I.cong Nat.mul2 (Hyp b Carry.1))
		      (I.symm (Nat.mul2.distr (bin2nat a) (Nat.succ (bin2nat b)))))
         c) b

TypeCheck Bin.pluscarrycase0.correct :
  a:Bin -> add:(Bin -> Carry -> Bin) ->
  Hyp: (b:Bin -> c:Carry ->
         I (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c)) ->
  b: Bin -> c:Carry ->
         I (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                           (bin2nat b)) c)

Definition Bin.pluscarrycase1.correct =
  \a:Bin \add:(Bin -> Carry -> Bin)
  \Hyp: (b:Bin -> c:Carry ->
         I (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c))
  \b:Bin \c:Carry ->
  Bin.rec (\b:Bin ->
         I (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c))
         (Bin.addcarry.correct (Bin.1 a) c)
        (\b:Bin \_:I (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c) ->
         Carry.rec (\c:Carry -> I (bin2nat ((Bin.negcarry2bin c) (add b c)))
                   (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
                                           (Nat.mul2 (bin2nat b))) c))
	     ; 2*(bin2nat (add b 0)) + 1
	     ;  = 2*(a + b)  +1             {Hyp}
	     ;  = (2*a + 2*b)  +1           {Nat.mul2.distr}
	     ;  = (2*a + 1) + 2*b           {Nat.plus.symmstep}
             (I.trans2 (I.cong (\x:Nat -> Nat.succ (Nat.mul2 x)) (Hyp b Carry.0))
	               (I.cong Nat.succ (I.symm (Nat.mul2.distr (bin2nat a) (bin2nat b))))
		       (Nat.plus.symmstep (Nat.mul2 (bin2nat a)) (Nat.mul2 (bin2nat b))))
	     ; 2*(bin2nat (add b 1))
	     ;  = 2*((a + b) + 1) = 2*(a + b) + 2  {Hyp}
	     ;  = (2*a + 2*b) + 2           {Nat.mul2.distr}
	     ;  = (2*a + 1) + 2*b + 1       {Nat.plus.symmstep}
	     (I.trans2 (I.cong (\x:Nat -> (Nat.mul2 x)) (Hyp b Carry.1))
	               (I.cong (\x:Nat -> Nat.succ (Nat.succ x))
		               (I.symm (Nat.mul2.distr (bin2nat a) (bin2nat b))))
		       (I.cong Nat.succ
		               (Nat.plus.symmstep (Nat.mul2 (bin2nat a)) (Nat.mul2 (bin2nat b)))))
	     c)
        (\b:Bin \_:I (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c) ->
	     ; pluscarrycase1
	     ;  = 2*(bin2nat (add b 1)) + c {bin2carry.correct}
	     ;  = 2*(a + b+1) + c           {Hyp}
	     ;  = (2*a + 2*(b+1))  + c      {Nat.mul2.distr}
	     ;  = (2*a + 2*b+1) + 1 + c     {automatic}
	     ;  = (2*a + 1) + 2*b + 1 + c   {Nat.plus.symmstep}
	     (I.trans (Bin.carry2bin.correct (add b Carry.1) c)
	     	(I.cong (\x:Nat -> Nat.addcarry x c)
		   (I.trans2 (I.cong Nat.mul2 (Hyp b Carry.1))
			     (I.symm (Nat.mul2.distr (bin2nat a) (Nat.succ (bin2nat b))))
			     (Nat.plus.symmstep (Nat.mul2 (bin2nat a)) (Nat.succ (Nat.mul2 (bin2nat b))))))))
        b

TypeCheck Bin.pluscarrycase1.correct :
  a:Bin -> add:(Bin -> Carry -> Bin) ->
  Hyp: (b:Bin -> c:Carry ->
         I (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c)) ->
  b: Bin -> c:Carry ->
         I (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c)


Definition Bin.pluscarry.correct =
   Bin.rec (\x:Bin -> y:Bin -> c:Carry -> I (bin2nat (Bin.pluscarry x y c))
                 (Nat.addcarry (Nat.plus (bin2nat x) (bin2nat y)) c))
	 (\y:Bin \c:Carry ->
	    ; bin2nat (Bin.pluscarry nil y c)
	    ;  = bin2nat (Bin.addcarry y c)
	    ;  = y + c      {addcarry.correct}
	    ;  = (0 + y) + c  {Nat.plus.symm0}
	    I.trans (Bin.addcarry.correct y c)
	            (I.cong (\z:Nat -> Nat.addcarry z c)
		            (Nat.plus.symm0 (bin2nat y))))
	 (\x:Bin -> Bin.pluscarrycase0.correct x (Bin.pluscarry x))
	 (\x:Bin -> Bin.pluscarrycase1.correct x (Bin.pluscarry x))

TypeCheck Bin.pluscarry.correct : a:Bin -> b:Bin -> c:Carry ->
   I (bin2nat (Bin.pluscarry a b c))
          (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c)

Definition Bin.mul5 = \a:Bin -> Bin.plus a (Bin.0 (Bin.0 a))
Definition Bin.mul10 = \a:Bin -> Bin.0 (Bin.mul5 a)
TypeCheck Bin.mul10 : Bin -> Bin

Definition Nat.mul2.mul10.Lemma = 
   Nat.rec (\n:Nat -> I (Nat.mul10 (Nat.mul2 n)) (Nat.mul2 (Nat.mul10 n)))
   (I.r Nat.0)
   (\n:Nat \Hyp:I (Nat.mul10 (Nat.mul2 n)) (Nat.mul2 (Nat.mul10 n)) ->
     ; 10*2*(n+1) = 10*2*n + 20 ={HYP} 2*10*n + 20 = 2*10*(n+1)
     I.cong (\x:Nat -> Nat.add10 (Nat.add10 x)) Hyp)

; Lemma: Bin.plus b 2*c+1 = (Bin.plus b (2*c+0)) + 1
Definition Bin.mul2.add1.lemma = Bin.rec
   (\b:Bin -> c:Bin -> I (Bin.plus b (Bin.1 c))
                  (Bin.succ (Bin.plus b (Bin.0 c))))
   (\c:Bin -> I.r (Bin.1 c))
   (\b:Bin \Hyp:(c:Bin -> I (Bin.plus b (Bin.1 c))
                  (Bin.succ (Bin.plus b (Bin.0 c))))
    \c:Bin ->
    ;; I (Bin.plus (Bin.0 b) (Bin.1 c))
    ;;        (Bin.succ (Bin.plus (Bin.0 b) (Bin.0 c)))
    I.r (Bin.1 (Bin.plus b c)))
   (\b:Bin \Hyp:(c:Bin -> I (Bin.plus b (Bin.1 c))
                  (Bin.succ (Bin.plus b (Bin.0 c))))
    \c:Bin ->
    ;; Bin.plus (2*b+1) (2*c+1) = 2*(Binpluscarry b c 1)
    ;; = 2*(Binplus b c) + 2 = (Bin.plus (2*b+1) (2*c)) + 1
    I.cong Bin.0 (I.symm (Bin.plus.pluscarry.lemma b c)))

Definition Nat.mul10.mul2add.lemma = Nat.rec
   (\n:Nat -> I (Nat.mul10 n) (Nat.mul2 (Nat.plus n (Nat.mul2 (Nat.mul2 n)))))
   (I.r Nat.0)
   (\n:Nat \Hyp: I (Nat.mul10 n) (Nat.mul2 (Nat.plus n (Nat.mul2 (Nat.mul2 n)))) ->
    I.trans (I.cong (\x:Nat -> Nat.plus x (Nat.mul10 (Nat.succ Nat.0))) Hyp)
            (I.cong Nat.mul2 (Nat.plus.symmstep n (Nat.mul2 (Nat.mul2 (Nat.succ n))))))

;Nat.mul10 b = Nat.mul2 (Nat.add b (Nat.mul2 (Nat.mul2 b))) = Bin.mul10 b
Definition Bin.mul10.correct = \b:Bin ->
  I.trans (Nat.mul10.mul2add.lemma (bin2nat b))
   (I.cong Nat.mul2 (I.symm (Bin.pluscarry.correct b (Bin.0 (Bin.0 b)) Carry.0)))
TypeCheck Bin.mul10.correct : 
   b:Bin -> I (Nat.mul10 (bin2nat b)) (bin2nat (Bin.mul10 b))

; compute 343 * 10
Evaluate Bin.mul10 (Bin.1 (Bin.1 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.nil))))))))))


Definition Bin.mul = \a:Bin ->
  Bin.rec (\b:Bin -> Bin)
    Bin.nil
    (\b:Bin \mulab:Bin -> Bin.0 mulab)
    (\b:Bin \mulab:Bin -> Bin.plus (Bin.0 mulab) a)

Definition Bin.mul.correct.aux0 = \a:Nat ->
  Nat.rec (\b:Nat -> I (Nat.plus (Nat.plus (Nat.mul2 a) b) b)
                       (Nat.mul2 (Nat.plus a b)))
    (I.r (Nat.mul2 a))
    (\b:Nat \Hyp:I (Nat.plus (Nat.plus (Nat.mul2 a) b) b)
                        (Nat.mul2 (Nat.plus a b)) ->
     ;; (2*a + b+1) + b+1
     ;;   = (2*a + b) + b+2  {Nat.plus.symmstep}
     ;;   = 2*(a+b) + 2      {Hyp}2*(a*b) + a + a  {Hyp}
     ;;   = 2*(a+(b+1))
     I.trans (I.symm (Nat.plus.symmstep (Nat.plus (Nat.mul2 a) b) (Nat.succ b)))
             (I.cong (\x:Nat -> Nat.succ (Nat.succ x)) Hyp))

TypeCheck Bin.mul.correct.aux0 : a:Nat -> b:Nat ->
   I (Nat.plus (Nat.plus (Nat.mul2 a) b) b) (Nat.mul2 (Nat.plus a b))

Definition Bin.mul.correct.aux1 = \a:Nat ->
  Nat.rec (\b:Nat -> I (Nat.mul a (Nat.mul2 b)) (Nat.mul2 (Nat.mul a b)))
    (I.r Nat.0)
    (\b:Nat \Hyp:I (Nat.mul a (Nat.mul2 b)) (Nat.mul2 (Nat.mul a b)) ->
     ;; a*(2*(b+1)) = a*(2*b) + a + a
     ;;    = 2*(a*b) + a + a  {Hyp}
     ;;    = 2*(a*b + a)      {aux0}
     ;;    = 2*(a*(b+1))
     I.trans (I.cong (\x:Nat -> Nat.plus (Nat.plus x a) a) Hyp)
             (Bin.mul.correct.aux0 (Nat.mul a b) a))
TypeCheck Bin.mul.correct.aux1 : a:Nat -> b:Nat ->
   I (Nat.mul a (Nat.mul2 b)) (Nat.mul2 (Nat.mul a b))

Definition Bin.mul.correct = \a:Bin ->
  Bin.rec
    (\b:Bin -> I (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b)))
    (I.r Nat.0)
    (\b:Bin \Hyp:I (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b)) ->
     ;; "Bin.0 (Bin.mul a b)"
     ;;  = 2*"Bin.mul a b"
     ;;  = 2*("a"*"b")        {Hyp}
     ;;  = "a"*(2*"b")        {aux1}
     ;;  = "a"*("Bin.0 b")
     I.trans (I.cong Nat.mul2 Hyp)
             (I.symm (Bin.mul.correct.aux1 (bin2nat a) (bin2nat b))))
    (\b:Bin \Hyp:I (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b)) ->
     ;; "Bin.plus (Bin.0 (Bin.mul a b)) a"
     ;;  = 2*"Bin.mul a b" + "a"    {pluscarry.correct}
     ;;  = 2*("a"*"b") + "a"        {Hyp}
     ;;  = "a"*(2*"b") + "a"        {aux1}
     ;;  = "a"*("Bin.1 b")
     I.trans2 (Bin.pluscarry.correct (Bin.0 (Bin.mul a b)) a Carry.0)
              (I.cong (\x:Nat -> Nat.plus (Nat.mul2 x) (bin2nat a)) Hyp)
	      (I.cong (\x:Nat -> Nat.plus x (bin2nat a))
	              (I.symm (Bin.mul.correct.aux1 (bin2nat a) (bin2nat b)))))
TypeCheck Bin.mul.correct : a:Bin -> b:Bin ->
   I (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Decimal Numbers

Inductive Dec : U =
   nil : Dec,
   0   : Dec -> Dec,
   1   : Dec -> Dec,
   2   : Dec -> Dec,
   3   : Dec -> Dec,
   4   : Dec -> Dec,
   5   : Dec -> Dec,
   6   : Dec -> Dec,
   7   : Dec -> Dec,
   8   : Dec -> Dec,
   9   : Dec -> Dec

Evaluate Dec

Definition dec2nat =
    Let s = Nat.succ ->
    Dec.rec (\x:Dec -> Nat) Nat.0
      (\x:Dec -> Nat.mul10)
      (\x:Dec \h:Nat -> s (Nat.mul10 h))
      (\x:Dec \h:Nat -> s (s (Nat.mul10 h)))
      (\x:Dec \h:Nat -> s (s (s (Nat.mul10 h))))
      (\x:Dec \h:Nat -> s (s (s (s (Nat.mul10 h)))))
      (\x:Dec \h:Nat -> s (s (s (s (s (Nat.mul10 h))))))
      (\x:Dec \h:Nat -> s (s (s (s (s (s (Nat.mul10 h)))))))
      (\x:Dec \h:Nat -> s (s (s (s (s (s (s (Nat.mul10 h))))))))
      (\x:Dec \h:Nat -> s (s (s (s (s (s (s (s (Nat.mul10 h)))))))))
      (\x:Dec \h:Nat -> s (s (s (s (s (s (s (s (s (Nat.mul10 h))))))))))
      
Definition dec2bin =
   Dec.rec (\x:Dec -> Bin) Bin.nil
      (\x:Dec \r:Bin -> Bin.mul10 r)
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.1 (Bin.nil)))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.0 (Bin.1 (Bin.nil))))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.1 (Bin.1 (Bin.nil))))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.0 (Bin.0 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.1 (Bin.0 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.0 (Bin.1 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.1 (Bin.1 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.0 (Bin.0 (Bin.0 (Bin.1 (Bin.nil))))))
      (\x:Dec \r:Bin -> Bin.plus (Bin.mul10 r) (Bin.1 (Bin.0 (Bin.0 (Bin.1 (Bin.nil))))))

Definition dec2bin2nat.correct.aux = \c:Bin ->
      (\d:Dec \Hyp:I (bin2nat (dec2bin d)) (dec2nat d) ->
      ;; b2n (10 * (d2b d) + c)
      ;;  = b2n(10* d2b d) + c   {Bin.pluscarry.correct}
      ;;  = 10 * b2n(d2b d) + c  {Bin.mul10.correct}
      ;;  = 10 * d2n + c         {Hyp}
      I.trans2 (Bin.pluscarry.correct (Bin.mul10 (dec2bin d)) 
	                              c Carry.0)
               (I.cong (\x:Nat -> Nat.plus x (bin2nat c))
	               (I.symm (Bin.mul10.correct (dec2bin d))))
               (I.cong (\x:Nat -> Nat.plus (Nat.mul10 x) (bin2nat c))
	               Hyp))
TypeCheck dec2bin2nat.correct.aux : c:Bin -> d:Dec ->
  I (bin2nat (dec2bin d)) (dec2nat d) ->
  I (bin2nat (Bin.plus (Bin.mul10 (dec2bin d)) c))
         (Nat.plus (Nat.mul10 (dec2nat d)) (bin2nat c))

Definition dec2bin2nat.correct = 
   Dec.rec (\d:Dec -> I (bin2nat (dec2bin d)) (dec2nat d))
      (I.r Nat.0)
      (dec2bin2nat.correct.aux Bin.nil)
      (dec2bin2nat.correct.aux (Bin.1 Bin.nil))
      (dec2bin2nat.correct.aux (Bin.0 (Bin.1 Bin.nil)))
      (dec2bin2nat.correct.aux (Bin.1 (Bin.1 Bin.nil)))
      (dec2bin2nat.correct.aux (Bin.0 (Bin.0 (Bin.1 Bin.nil))))
      (dec2bin2nat.correct.aux (Bin.1 (Bin.0 (Bin.1 Bin.nil))))
      (dec2bin2nat.correct.aux (Bin.0 (Bin.1 (Bin.1 Bin.nil))))
      (dec2bin2nat.correct.aux (Bin.1 (Bin.1 (Bin.1 Bin.nil))))
      (dec2bin2nat.correct.aux (Bin.0 (Bin.0 (Bin.0 (Bin.1 Bin.nil)))))
      (dec2bin2nat.correct.aux (Bin.1 (Bin.0 (Bin.0 (Bin.1 Bin.nil)))))

TypeCheck Bin.pluscarry.correct : a:Bin -> b:Bin -> c:Carry ->
   I (bin2nat (Bin.pluscarry a b c))
          (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c)

; strip leading zero from a decimal number
; this function converts nil to nil and everything else to (Dec.0 r).
Definition Dec.strip0.aux = \r:Dec ->
  (\z:(Dec -> Dec -> Dec) -> 
   Dec.rec (\x:Dec -> Dec) Dec.nil z z z z z z z z z z r)
  (\_:Dec \_:Dec -> Dec.0 r)

Definition Dec.strip0.aux.correct.lemma =
  \cipher: (Dec -> Dec) 
  \eq:(r:Dec -> I (Dec.strip0.aux (cipher r)) (Dec.0 (cipher r)))
  \r:Dec \_:I (dec2nat (Dec.strip0.aux r)) (dec2nat (Dec.0 r)) ->
   I.rsubst (eq r)
      (\x:Dec -> I (dec2nat (Dec.0 (cipher r))) (dec2nat x))
      (I.r (dec2nat (Dec.0 (cipher r))))

Definition Dec.strip0.aux.correct =
  Dec.rec (\r:Dec -> I (dec2nat (Dec.strip0.aux r)) (dec2nat (Dec.0 r)))
     (I.r Nat.0)
     (Dec.strip0.aux.correct.lemma Dec.0 (\r:Dec -> I.r (Dec.0 (Dec.0 r))))
     (Dec.strip0.aux.correct.lemma Dec.1 (\r:Dec -> I.r (Dec.0 (Dec.1 r))))
     (Dec.strip0.aux.correct.lemma Dec.2 (\r:Dec -> I.r (Dec.0 (Dec.2 r))))
     (Dec.strip0.aux.correct.lemma Dec.3 (\r:Dec -> I.r (Dec.0 (Dec.3 r))))
     (Dec.strip0.aux.correct.lemma Dec.4 (\r:Dec -> I.r (Dec.0 (Dec.4 r))))
     (Dec.strip0.aux.correct.lemma Dec.5 (\r:Dec -> I.r (Dec.0 (Dec.5 r))))
     (Dec.strip0.aux.correct.lemma Dec.6 (\r:Dec -> I.r (Dec.0 (Dec.6 r))))
     (Dec.strip0.aux.correct.lemma Dec.7 (\r:Dec -> I.r (Dec.0 (Dec.7 r))))
     (Dec.strip0.aux.correct.lemma Dec.8 (\r:Dec -> I.r (Dec.0 (Dec.8 r))))
     (Dec.strip0.aux.correct.lemma Dec.9 (\r:Dec -> I.r (Dec.0 (Dec.9 r))))

TypeCheck Dec.strip0.aux.correct : r:Dec ->
  I (dec2nat (Dec.strip0.aux r)) (dec2nat (Dec.0 r))

Definition Dec.strip0 =
   Dec.rec (\x:Dec -> Dec) Dec.nil
      (\x:Dec \r:Dec -> Dec.strip0.aux r)
      (\x:Dec \r:Dec -> Dec.1 r)
      (\x:Dec \r:Dec -> Dec.2 r)
      (\x:Dec \r:Dec -> Dec.3 r)
      (\x:Dec \r:Dec -> Dec.4 r)
      (\x:Dec \r:Dec -> Dec.5 r)
      (\x:Dec \r:Dec -> Dec.6 r)
      (\x:Dec \r:Dec -> Dec.7 r)
      (\x:Dec \r:Dec -> Dec.8 r)
      (\x:Dec \r:Dec -> Dec.9 r)

Definition Dec.strip0.lemma = \cipher:Dec
   \d:Dec \eq:I (dec2nat (Dec.strip0 d)) (dec2nat d) ->
   ;; dec2nat (Dec.strip0 d')
   ;;  = Nat.plus (Nat.mul10 (dec2nat (Dec.strip0 d))) (dec2nat cipher)   {automatic}
   ;;  = Nat.plus (Nat.mul10 (dec2nat d) (dec2nat cipher)  {eq}
   ;;  = dec2nat (d') {automatic}
   I.cong (\x:Nat -> Nat.plus (Nat.mul10 x) (dec2nat cipher)) eq

Evaluate Dec.6
Definition Dec.strip0.correct =
   Dec.rec (\d:Dec -> I (dec2nat (Dec.strip0 d)) (dec2nat d))
      (I.r Nat.0)
      (\d:Dec \r:I (dec2nat (Dec.strip0 d)) (dec2nat d) ->
         I.subst r
	   (\x:Nat -> I (dec2nat (Dec.strip0.aux (Dec.strip0 d))) 
                             (Nat.mul10 x))
	   (Dec.strip0.aux.correct (Dec.strip0 d)))
      (Dec.strip0.lemma (Dec.1 Dec.nil))
      (Dec.strip0.lemma (Dec.2 Dec.nil))
      (Dec.strip0.lemma (Dec.3 Dec.nil))
      (Dec.strip0.lemma (Dec.4 Dec.nil))
      (Dec.strip0.lemma (Dec.5 Dec.nil))
      (Dec.strip0.lemma (Dec.6 Dec.nil))
      (Dec.strip0.lemma (Dec.7 Dec.nil))
      (Dec.strip0.lemma (Dec.8 Dec.nil))
      (Dec.strip0.lemma (Dec.9 Dec.nil))
	      
Evaluate Dec.5
TypeCheck Dec.strip0.correct : d:Dec ->
  I (dec2nat (Dec.strip0 d)) (dec2nat d)

Definition Dec.succ = 
  Dec.rec (\x:Dec -> Dec)
    (Dec.1 Dec.nil)
    (\x:Dec \r:Dec -> Dec.1 x)
    (\x:Dec \r:Dec -> Dec.2 x)
    (\x:Dec \r:Dec -> Dec.3 x)
    (\x:Dec \r:Dec -> Dec.4 x)
    (\x:Dec \r:Dec -> Dec.5 x)
    (\x:Dec \r:Dec -> Dec.6 x)
    (\x:Dec \r:Dec -> Dec.7 x)
    (\x:Dec \r:Dec -> Dec.8 x)
    (\x:Dec \r:Dec -> Dec.9 x)
    (\x:Dec \r:Dec -> Dec.0 r)

Definition Dec.succ.correct.aux0 = \digit: (Dec -> Dec)
  \d:Dec \_:I (dec2nat (Dec.succ d)) (Nat.succ (dec2nat d)) ->
  I.r (Nat.succ (Nat.plus (Nat.mul10 (dec2nat d))
                                  (dec2nat (digit Dec.nil))))

Definition Dec.succ.correct = 
  Dec.rec (\d:Dec -> I (dec2nat (Dec.succ d)) (Nat.succ (dec2nat d)))
    (I.r (Nat.succ Nat.0))
    (Dec.succ.correct.aux0 Dec.0)
    (Dec.succ.correct.aux0 Dec.1)
    (Dec.succ.correct.aux0 Dec.2)
    (Dec.succ.correct.aux0 Dec.3)
    (Dec.succ.correct.aux0 Dec.4)
    (Dec.succ.correct.aux0 Dec.5)
    (Dec.succ.correct.aux0 Dec.6)
    (Dec.succ.correct.aux0 Dec.7)
    (Dec.succ.correct.aux0 Dec.8)
    (\d:Dec \Hyp:I (dec2nat (Dec.succ d)) (Nat.succ (dec2nat d)) ->
     I.subst Hyp
        (\x:Nat -> I (Nat.mul10 (dec2nat (Dec.succ d)))
	               (Nat.mul10 x))
	(I.r (Nat.mul10 (dec2nat (Dec.succ d)))))

Definition nat2dec = Nat.rec (\n:Nat -> Dec) 
  Dec.nil (\n:Nat \d:Dec -> (Dec.succ d))

Definition nat2dec2nat.correct =
  Nat.rec (\n:Nat -> I (dec2nat (nat2dec n)) n)
    (I.r Nat.0)
    (\n:Nat \Hyp:I (dec2nat (nat2dec n)) n ->
      I.subst Hyp
	    (\x:Nat -> I (dec2nat (Dec.succ (nat2dec n)))
                              (Nat.succ x))
            (Dec.succ.correct (nat2dec n)))

Definition Dec.mul2.aux = 
   \dig0 : (Dec -> Dec) \dig1 : (Dec -> Dec) \nc:Carry
   \x:Dec \r:(Carry -> Dec) \c:Carry ->
      (Carry.rec (\c:Carry -> Dec -> Dec) dig0 dig1 c) (r nc)

Definition Dec.mul2 =
   Dec.rec (\x:Dec -> Carry -> Dec) 
      (Carry.rec (\c:Carry -> Dec) Dec.nil (Dec.1 Dec.nil))
      (Dec.mul2.aux Dec.0 Dec.1 Carry.0)
      (Dec.mul2.aux Dec.2 Dec.3 Carry.0)
      (Dec.mul2.aux Dec.4 Dec.5 Carry.0)
      (Dec.mul2.aux Dec.6 Dec.7 Carry.0)
      (Dec.mul2.aux Dec.8 Dec.9 Carry.0)
      (Dec.mul2.aux Dec.0 Dec.1 Carry.1)
      (Dec.mul2.aux Dec.2 Dec.3 Carry.1)
      (Dec.mul2.aux Dec.4 Dec.5 Carry.1)
      (Dec.mul2.aux Dec.6 Dec.7 Carry.1)
      (Dec.mul2.aux Dec.8 Dec.9 Carry.1)

Definition bin2dec =
   Bin.rec (\x:Bin -> Dec) Dec.nil
     (\x:Bin \r:Dec -> Dec.mul2 r Carry.0)
     (\x:Bin \r:Dec -> Dec.mul2 r Carry.1)

Definition Dec.addcarry = \d:Dec ->
  Carry.rec (\c:Carry -> Dec) d (Dec.succ d)

Definition Dec.addcarry.correct = \d:Dec ->
  Carry.rec (\c:Carry -> I (dec2nat (Dec.addcarry d c)) (Nat.addcarry (dec2nat d) c))
    (I.r (dec2nat d))
    (Dec.succ.correct d)

Evaluate Dec.2
Definition Dec.mul2.correct.aux2 = 
    \dig1:(Dec -> Dec) \dig2:(Dec -> Dec) \dig3:(Dec -> Dec)
    \nc:Carry
    \eq1a:(n:Nat -> I (Nat.plus (Nat.mul10 (Nat.addcarry n nc))
                                (dec2nat (dig2 Dec.nil)))
                      (Nat.plus (Nat.mul10 n)
		                (Nat.mul2 (dec2nat (dig1 Dec.nil)))))
    \eq1b:(d:Dec -> I (dec2nat (dig2 d))
                           (Nat.plus (Nat.mul10 (dec2nat d))
			             (dec2nat (dig2 Dec.nil))))
    \eq2:(d:Dec -> I (dig3 d) (Dec.succ (dig2 d)))
    Let dig23 = (Carry.rec (\c:Carry -> Dec -> Dec) dig2 dig3)
    \d:Dec \Hyp:(c:Carry -> I (dec2nat (Dec.mul2 d c)) (Nat.addcarry (Nat.mul2 (dec2nat d)) c))
    \c:Carry ->
    Let d' = (Dec.mul2 d nc) ->
    ;; (dec2nat (Dec.mul2 (dig1 d) c))
    ;;  = (dec2nat (dig23 (Dec.mul2 d nc)))                               {automatic in caller}
    ;;  = (dec2nat (Dec.addcarry (dig2 (Dig.mul2 d nc)) c))               {I.r/eq2}
    ;;  = (Nat.addcarry (dec2nat (dig2 (Dig.mul2 d nc))) c)               {Dec.addcarry.correct}
    ;;  = (Nat.addcarry (Nat.plus (Nat.mul10 (dec2nat (Dig.mul2 d nc)))   {eq1b}
    ;;                            (dec2nat (dig2 Dec.nil))) c)
    ;;  = (Nat.addcarry (Nat.plus (Nat.mul10 (Nat.addcarry (Nat.mul2 (dec2nat d)) c)) {Hyp}
    ;;                            (dec2nat (dig2 Dec.nil))) c)
    ;;  = (Nat.addcarry (Nat.plus (Nat.mul10 (Nat.mul2 (dec2nat d)))      {eq1a}
    ;;                            (Nat.mul2 (dec2nat (dig1 Dec.nil)))) c)
    ;;  = (Nat.addcarry (Nat.plus (Nat.mul2 (Nat.mul10 (dec2nat d)))      {Nat.mul2.mul10.Lemma}
    ;;                            (Nat.mul2 (dec2nat (dig1 Dec.nil)))) c)
    ;;  = (Nat.addcarry (Nat.mul2 (Nat.plus (Nat.mul10 (dec2nat d)))      {Nat.mul2.distr}
    ;;                                      (dec2nat (dig1 Dec.nil)))) c)
    ;;  = (Nat.addcarry (Nat.mul2 (dec2nat (dig1 d))) c)                  {automatic in caller}
    I.trans2 (I.cong dec2nat
	            (Carry.rec (\c:Carry -> I ((dig23 c) d') (Dec.addcarry (dig2 d') c))
                              (I.r (dig2 d')) (eq2 d') c))
	     (Dec.addcarry.correct (dig2 (Dec.mul2 d nc)) c)
	     (I.cong (\x:Nat -> (Nat.addcarry x c))
	        (I.trans3 (eq1b d')
		          (I.cong (\x:Nat -> Nat.plus (Nat.mul10 x) (dec2nat (dig2 Dec.nil)))
		                  (Hyp nc))
		          (eq1a (Nat.mul2 (dec2nat d)))
		(I.trans  (I.cong (\x:Nat -> Nat.plus x (Nat.mul2 (dec2nat (dig1 Dec.nil))))
			          (Nat.mul2.mul10.Lemma (dec2nat d)))
		          (Nat.mul2.distr (Nat.mul10 (dec2nat d)) (dec2nat (dig1 Dec.nil))))))

Evaluate Dec.0
Definition Dec.mul2.correct =
  Dec.rec (\d:Dec -> c:Carry -> I (dec2nat (Dec.mul2 d c))
                                       (Nat.addcarry (Nat.mul2 (dec2nat d)) c))
    (Carry.rec (\c:Carry -> I (dec2nat (Dec.mul2 Dec.nil c))
                                   (Nat.addcarry Nat.0 c))
        (I.r Nat.0) (I.r (Nat.succ Nat.0)))
    (Dec.mul2.correct.aux2 Dec.0 Dec.0 Dec.1 Carry.0
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat Dec.nil)))
        (\d:Dec -> I.r (dec2nat (Dec.0 d)))
        (\d:Dec -> I.r (Dec.1 d)))
    (Dec.mul2.correct.aux2 Dec.1 Dec.2 Dec.3 Carry.0
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.2 Dec.nil))))
        (\d:Dec -> I.r (dec2nat (Dec.2 d)))
        (\d:Dec -> I.r (Dec.3 d)))
    (Dec.mul2.correct.aux2 Dec.2 Dec.4 Dec.5 Carry.0
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.4 Dec.nil))))
        (\d:Dec -> I.r (dec2nat (Dec.4 d)))
        (\d:Dec -> I.r (Dec.5 d)))
    (Dec.mul2.correct.aux2 Dec.3 Dec.6 Dec.7 Carry.0
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.6 Dec.nil))))
        (\d:Dec -> I.r (dec2nat (Dec.6 d)))
        (\d:Dec -> I.r (Dec.7 d)))
    (Dec.mul2.correct.aux2 Dec.4 Dec.8 Dec.9 Carry.0
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.8 Dec.nil))))
        (\d:Dec -> I.r (dec2nat (Dec.8 d)))
        (\d:Dec -> I.r (Dec.9 d)))
    (Dec.mul2.correct.aux2 Dec.5 Dec.0 Dec.1 Carry.1
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.0 (Dec.1 Dec.nil)))))
        (\d:Dec -> I.r (dec2nat (Dec.0 d)))
	(\d:Dec -> I.r (Dec.1 d)))
    (Dec.mul2.correct.aux2 Dec.6 Dec.2 Dec.3 Carry.1
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.2 (Dec.1 Dec.nil)))))
        (\d:Dec -> I.r (dec2nat (Dec.2 d)))
        (\d:Dec -> I.r (Dec.3 d)))
    (Dec.mul2.correct.aux2 Dec.7 Dec.4 Dec.5 Carry.1
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.4 (Dec.1 Dec.nil)))))
        (\d:Dec -> I.r (dec2nat (Dec.4 d)))
        (\d:Dec -> I.r (Dec.5 d)))
    (Dec.mul2.correct.aux2 Dec.8 Dec.6 Dec.7 Carry.1
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.6 (Dec.1 Dec.nil)))))
        (\d:Dec -> I.r (dec2nat (Dec.6 d)))
        (\d:Dec -> I.r (Dec.7 d)))
    (Dec.mul2.correct.aux2 Dec.9 Dec.8 Dec.9 Carry.1
        (\n:Nat -> I.r (Nat.plus (Nat.mul10 n) (dec2nat (Dec.8 (Dec.1 Dec.nil)))))
        (\d:Dec -> I.r (dec2nat (Dec.8 d)))
        (\d:Dec -> I.r (Dec.9 d)))
Evaluate Dec.1

Definition bin2dec2nat.correct.aux = 
  \carry:Carry \b:Bin \Hyp:(I (dec2nat (bin2dec b)) (bin2nat b)) ->
    I.subst Hyp
       (\x:Nat -> I (dec2nat (Dec.mul2 (bin2dec b) carry))
                      (Nat.addcarry (Nat.mul2 x) carry))
       (Dec.mul2.correct (bin2dec b) carry)
TypeCheck bin2dec2nat.correct.aux : 
  carry:Carry -> b:Bin -> I (dec2nat (bin2dec b)) (bin2nat b) ->
    I (dec2nat (Dec.mul2 (bin2dec b) carry))
           (Nat.addcarry (Nat.mul2 (bin2nat b)) carry)

Definition bin2dec2nat.correct = 
  Bin.rec (\b:Bin -> I (dec2nat (bin2dec b)) (bin2nat b))
    (I.r Nat.0)
    (bin2dec2nat.correct.aux Carry.0)
    (bin2dec2nat.correct.aux Carry.1)


Definition Dec.plus = \a:Dec \b:Dec -> 
  bin2dec (Bin.plus (dec2bin a) (dec2bin b))
Definition Dec.mul = \a:Dec \b:Dec ->
  bin2dec (Bin.mul (dec2bin a) (dec2bin b))

Definition Dec.plus.correct = \a:Dec \b:Dec ->
  (I.subst (dec2bin2nat.correct a)
    (\x:Nat -> I (Nat.plus x (dec2nat b))
                (dec2nat (Dec.plus a b)))
  (I.subst (dec2bin2nat.correct b)
    (\x:Nat -> I (Nat.plus (bin2nat (dec2bin a)) x)
                (dec2nat (Dec.plus a b)))
  (I.subst (Bin.pluscarry.correct (dec2bin a) (dec2bin b) Carry.0)
    (\x:Nat -> I x (dec2nat (Dec.plus a b)))
  (I.rsubst (bin2dec2nat.correct (Bin.plus (dec2bin a) (dec2bin b)))
    (\x:Nat -> I (bin2nat (Bin.plus (dec2bin a) (dec2bin b))) x)
  (I.r (bin2nat (Bin.plus (dec2bin a) (dec2bin b))))))))
				 
TypeCheck Dec.plus.correct : a:Dec -> b:Dec ->
  I (Nat.plus (dec2nat a) (dec2nat b)) (dec2nat (Dec.plus a b))

Definition Dec.mul.correct = \a:Dec \b:Dec ->
  (I.subst (dec2bin2nat.correct a)
    (\x:Nat -> I (Nat.mul x (dec2nat b))
                (dec2nat (Dec.mul a b)))
  (I.subst (dec2bin2nat.correct b)
    (\x:Nat -> I (Nat.mul (bin2nat (dec2bin a)) x)
                (dec2nat (Dec.mul a b)))
  (I.subst (Bin.mul.correct (dec2bin a) (dec2bin b))
    (\x:Nat -> I x (dec2nat (Dec.mul a b)))
  (I.rsubst (bin2dec2nat.correct (Bin.mul (dec2bin a) (dec2bin b)))
    (\x:Nat -> I (bin2nat (Bin.mul (dec2bin a) (dec2bin b))) x)
  (I.r (bin2nat (Bin.mul (dec2bin a) (dec2bin b))))))))

TypeCheck Dec.mul.correct : a:Dec -> b:Dec ->
  I (Nat.mul (dec2nat a) (dec2nat b)) (dec2nat (Dec.mul a b))

Evaluate Dec.mul (Dec.5 Dec.nil) (Dec.7 Dec.nil)
Evaluate Dec.mul (Dec.5 (Dec.3 Dec.nil)) (Dec.7 (Dec.2 Dec.nil))
Evaluate Dec.mul (Dec.7 (Dec.5 (Dec.3 Dec.nil))) (Dec.3 (Dec.7 (Dec.2 Dec.nil)))
Evaluate Dec.mul (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))) (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil))))
Evaluate Dec.mul (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil))))) (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil)))))
Evaluate Dec.mul (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))) (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil))))))
Evaluate Dec.mul (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil))))))) (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil)))))))
Evaluate Dec.mul (Dec.3 (Dec.7 (Dec.2 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))))))))))) (Dec.9 (Dec.2 (Dec.1 (Dec.0 (Dec.7 (Dec.7 (Dec.7 (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil))))))))))))))
Evaluate Dec.mul (Dec.mul (Dec.3 (Dec.7 (Dec.2 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))))))))))) (Dec.9 (Dec.2 (Dec.1 (Dec.0 (Dec.7 (Dec.7 (Dec.7 (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil))))))))))))))) (Dec.mul (Dec.3 (Dec.7 (Dec.2 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))))))))))) (Dec.9 (Dec.2 (Dec.1 (Dec.0 (Dec.7 (Dec.7 (Dec.7 (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil)))))))))))))))
Evaluate Dec.mul (Dec.mul (Dec.mul (Dec.3 (Dec.7 (Dec.2 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))))))))))) (Dec.9 (Dec.2 (Dec.1 (Dec.0 (Dec.7 (Dec.7 (Dec.7 (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil))))))))))))))) (Dec.mul (Dec.3 (Dec.7 (Dec.2 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))))))))))) (Dec.9 (Dec.2 (Dec.1 (Dec.0 (Dec.7 (Dec.7 (Dec.7 (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil)))))))))))))))) (Dec.mul (Dec.mul (Dec.3 (Dec.7 (Dec.2 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))))))))))) (Dec.9 (Dec.2 (Dec.1 (Dec.0 (Dec.7 (Dec.7 (Dec.7 (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil))))))))))))))) (Dec.mul (Dec.3 (Dec.7 (Dec.2 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.5 (Dec.2 (Dec.9 (Dec.5 (Dec.3 Dec.nil)))))))))))))) (Dec.9 (Dec.2 (Dec.1 (Dec.0 (Dec.7 (Dec.7 (Dec.7 (Dec.3 (Dec.3 (Dec.3 (Dec.2 (Dec.5 (Dec.7 (Dec.2 Dec.nil))))))))))))))))
