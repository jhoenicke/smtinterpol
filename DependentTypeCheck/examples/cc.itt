; Proofs from the Paper
;  Herman Geuvers, A short and flexible proof of Strong Normalization for
;  the Calculus of Constructions

Inductive T : U = tt:T
Inductive F : U =

Inductive * : A:U -> B:U -> U =
  mk : A->B-> * A B
Definition *.mk = {\A:U} \a:A {\B:U} \b:B -> *.mk A B a b
Definition *.1 = {\A:U} {\B:U} -> *.rec (\_:* A B -> A) (\a:A \_:B -> a)
Definition *.2 = {\A:U} {\B:U} -> *.rec (\_:* A B -> B) (\_:A \b:B -> b)

Inductive + : A:U -> B:U -> U =
  1: A -> + A B,
  2: B -> + A B
Definition +.case = \C:U {\A:U} \1:(A -> C) {\B:U} \2:(B -> C) ->
  +.rec (\_:+ A B -> C) 1 2

Inductive Sigma : {A:U} -> B:(A->U) -> U =
  mk : a:A->b:(B a)-> Sigma B
Definition Sigma.1 = {\A:U} {\B:(A->U)} ->
  Sigma.rec (\_:Sigma B -> A) (\a:A \_:B a -> a)
Definition Sigma.2 = {\A:U} {\B:(A->U)} ->
  Sigma.rec (\p:Sigma B -> B (Sigma.1 p)) (\a:A \b:B a -> b)

Inductive I : {A:U} -> a:A -> b:A -> U =
  r : I a a
Definition T.eq = T.rec (\t1:T -> t2:T -> I t1 t2) (T.rec (I T.tt) (I.r T.tt))

Definition I.subst = {\A:U} {\a:A} {\b:A} \eq:I a b \C:(A -> U) ->
    I.rec (\x:A \_:I a x -> C a -> C x)
      (\z:C a -> z) eq
TypeCheck I.subst :
  {A:U} -> {a:A} -> {b:A} -> I a b -> C:(A -> U) -> C a -> C b
Definition I.symm = {\A:U} {\a:A} {\b:A} \eq:I a b ->
  I.subst eq (\x:A -> I x a) (I.r a)
Definition I.trans = {\A:U} {\a:A} {\b:A} \eq1:I a b {\c:A} \eq2:I b c ->
  I.subst eq2 (\x:A -> I a x) eq1
Definition I.subst2 = {\A:U} {\a1:A} {\a2:A} \eq1:I a1 a2
	              {\B:U} {\b1:B} {\b2:B} \eq2:I b1 b2
		      \C:(A -> B -> U) ->
  I.subst eq2 (\b:B -> C a1 b1 -> C a2 b)
    (I.subst eq1 (\a:A -> C a b1))
TypeCheck I.subst2 :
  {A:U} -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {B:U} -> {b1:B} -> {b2:B} -> I b1 b2 -> C:(A -> B -> U) -> C a1 b1 -> C a2 b2
Definition I.rsubst = {\A:U} {\b:A} {\a:A} \eq:I a b \C:(A -> U) ->
    I.subst (I.symm eq) C
Definition I.cong = {\A:U} {\B:U}
  \c:(A -> B) {\a:A} {\b:A} \eq: I a b ->
    I.subst eq (\x:A -> I (c a) (c x)) (I.r (c a))
TypeCheck I.cong :
  A:U -> B:U -> c:(A -> B) -> {a:A} -> {b:A} -> I a b -> I (c a) (c b)
Definition I.cong2 = {\A:U} {\B:U} {\C:U} \f:(A->B->C)
  {\a1:A} {\a2:A} \eq1: I a1 a2 {\b1:B}{\b2:B} \eq2: I b1 b2 ->
  I.subst eq1 (\x:A -> I (f a1 b1) (f x b2)) (I.cong (f a1) eq2)
TypeCheck I.cong2 :
  {A:U} -> {B:U} -> {C:U} -> f:(A -> B -> C) -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {b1:B} -> {b2:B} -> I b1 b2 -> I (f a1 b1) (f a2 b2)
Definition I.cong3 = {\A:U} {\B:U} {\C:U} {\D:U} \f:(A->B->C->D)
  {\a1:A} {\a2:A} \eq1: I a1 a2 {\b1:B}{\b2:B} \eq2: I b1 b2
  {\c1:C} {\c2:C} \eq3: I c1 c2 ->
  I.subst eq1 (\x:A -> I (f a1 b1 c1) (f x b2 c2)) (I.cong2 (f a1) eq2 eq3)

Inductive Bool : U = tt:Bool, ff:Bool
Definition Bool.ite = \b:Bool {\C:U1} \t:C \e:C ->
  Bool.rec (\_:Bool -> C) t e b

;===========================================
;  Natural Numbers
;===========================================

Inductive Nat : U =
  0 : Nat,
  s : Nat -> Nat
Definition Nat.1 = Nat.s Nat.0

Definition Nat.plus = Nat.rec (\_:Nat -> Nat -> Nat)
    (\b:Nat -> b) (\a:Nat \rec:(Nat->Nat) \b:Nat -> Nat.s (rec b))

Definition Nat.plus.zero =
    Nat.rec (\a:Nat -> I (Nat.plus a Nat.0) a)
       (I.r Nat.0)
       (\a:Nat \Hyp:I (Nat.plus a Nat.0) a -> I.cong Nat.s Hyp)
Definition Nat.s.plus.commutes = \a:Nat \b:Nat ->
    Nat.rec (\a:Nat -> I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)))
       (I.r (Nat.s b))
       (\a:Nat \Hyp: I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)) ->
        I.subst Hyp
	   (\x:Nat -> I (Nat.s (Nat.s (Nat.plus a b))) (Nat.s x))
	   (I.r (Nat.s (Nat.s (Nat.plus a b)))))
       a

Definition Nat.plus.commutes = \a:Nat ->
    Nat.rec (\b:Nat -> I (Nat.plus a b) (Nat.plus b a))
       (Nat.plus.zero a)
       (\b:Nat \Hyp:I (Nat.plus a b) (Nat.plus b a) ->
        I.subst Hyp
	        (\x:Nat -> I (Nat.plus a (Nat.s b)) (Nat.s x))
		(I.symm (Nat.s.plus.commutes a b)))

Definition Nat.iter = {\A:U} \f:(A->A) ->
  Nat.rec (\n:Nat -> A -> A) (\a:A -> a) (\_:Nat \rec:(A->A) \a:A -> f (rec a))
Definition Nat.iter.associative = {\A:U} \f:(A->A) \n:Nat \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)))
    (I.r (f a))
    (\n:Nat \Hyp:I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)) ->
     I.cong f Hyp)
    n
Definition Nat.iter.plus = {\A:U} \f:(A->A) \m:Nat \n:Nat \a:A ->
  Nat.rec (\m:Nat -> I (Nat.iter f m (Nat.iter f n a))
                       (Nat.iter f (Nat.plus m n) a))
    (I.r (Nat.iter f n a))
    (\m:Nat
     \eq:I (Nat.iter f m (Nat.iter f n a)) (Nat.iter f (Nat.plus m n) a) ->
     I.cong f eq)
    m

Definition Nat.iter.g.commutes = \A:U \f:(A->A) \g:(A->A)
  \fgcommutes:(a:A -> I (f (g a)) (g (f a))) \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f n (g a)) (g (Nat.iter f n a)))
    (I.r (g a))
    (\n:Nat\Hyp:I (Nat.iter f n (g a)) (g (Nat.iter f n a)) ->
     I.subst (fgcommutes (Nat.iter f n a))
        (\x:A -> I (Nat.iter f (Nat.s n) (g a)) x)
        (I.cong f Hyp))

;===========================================
;  Terms
;===========================================

Inductive VarType : U = []:VarType, *:VarType

Inductive Term : U =
  lam   : VarType -> Term -> Term -> Term,
  pi    : VarType -> Term -> Term -> Term,
  app   : Term -> Term -> Term,
  var   : VarType -> Nat -> Term,
  univ  : VarType -> Term

Definition Term.[] = Term.univ VarType.[]
Definition Term.*  = Term.univ VarType.*

;===========================================
;  variable shifting
;===========================================

; increment m by one, if m greater equal n.
Definition Nat.shiftn =
  Nat.rec (\n:Nat -> m:Nat -> Nat)
     Nat.s
     (\_:Nat \shiftn1:(Nat -> Nat) ->
       Nat.rec (\m:Nat -> Nat) Nat.0
	  (\m1:Nat \_:Nat -> Nat.s (shiftn1 m1)))

; Increment all variables >= n by one.
Definition Term.shiftn =
  Term.rec (\_:Term -> n:Nat -> Term)
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.lam vt (rt1 n) (rt2 (Nat.s n)))
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.pi vt (rt1 n) (rt2 (Nat.s n)))
    (\_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.app (rt1 n) (rt2 n))
    (\vt:VarType \i: Nat \n:Nat -> Term.var vt (Nat.shiftn n i))
    (\vt:VarType \n: Nat -> Term.univ vt)
Definition Term.shiftvar = \term:Term ->
    Term.shiftn term Nat.0

;  swap shiftn
Definition Nat.shiftn.commutes = \m:Nat ->
   Let Thesis = (\n:Nat -> \i:Nat ->
        I (Nat.shiftn n (Nat.shiftn (Nat.plus n m) i))
          (Nat.shiftn (Nat.s (Nat.plus n m)) (Nat.shiftn n i))) ->
   Nat.rec (\n:Nat -> i:Nat -> Thesis n i)
     (\i:Nat -> I.r (Nat.s (Nat.shiftn m i)))
     (\n:Nat \HypN: (i:Nat -> Thesis n i) ->
      Nat.rec (\i:Nat -> Thesis (Nat.s n) i)
        (I.r Nat.0)
	(\i:Nat \_:Thesis (Nat.s n) i ->
	 I.cong Nat.s (HypN i)))

Definition Term.shiftn.commutes = \m:Nat ->
   Let Thesis = (\T:Term -> n:Nat -> 
       I (Term.shiftn (Term.shiftn T (Nat.plus n m)) n)
       	 (Term.shiftn (Term.shiftn T n) (Nat.s (Nat.plus n m)))) ->
   Term.rec (\T:Term -> Thesis T)
     (\vt:VarType \S:Term \HypS:Thesis S \M:Term \HypM:Thesis M
      \n:Nat -> I.cong2 (Term.lam vt) (HypS n) (HypM (Nat.s n)))
     (\vt:VarType \S:Term \HypS:Thesis S \M:Term \HypM:Thesis M
      \n:Nat -> I.cong2 (Term.pi vt) (HypS n) (HypM (Nat.s n)))
     (\S:Term \HypS:Thesis S \M:Term \HypM:Thesis M
      \n:Nat -> I.cong2 Term.app (HypS n) (HypM n))
     (\vt:VarType \i:Nat \n:Nat ->
      I.cong (Term.var vt) (Nat.shiftn.commutes m n i))
     (\vt:VarType \n:Nat -> I.r (Term.univ vt))
TypeCheck Term.shiftn.commutes : m:Nat -> T:Term -> n:Nat -> 
    I (Term.shiftn (Term.shiftn T (Nat.plus n m)) n)
      (Term.shiftn (Term.shiftn T n) (Nat.s (Nat.plus n m)))

Definition Term.shiftvarn.commutes  = \T:Term \n:Nat ->
     Term.shiftn.commutes n T Nat.0
TypeCheck Term.shiftvarn.commutes : T:Term -> n:Nat ->
     I (Term.shiftvar (Term.shiftn T n))
       (Term.shiftn (Term.shiftvar T) (Nat.s n))

;===========================================
;  Substitutions
;===========================================

; Apply substitute on variable x_i.
; x_n by subst, decrementing all bigger variables
; i<n : return x_i
; i=n : return subst
; i>n : return x_{i-1}
Definition Term.var.substn = \vt:VarType \subst:Term ->
  Nat.rec (\n:Nat -> i:Nat -> Term)
     (Nat.rec (\i:Nat -> Term)
     	 subst
	 (\i1:Nat\_:Term -> Term.var vt i1))
     (\_:Nat \shiftn1:(i:Nat -> Term) ->
      Nat.rec (\i:Nat -> Term)
         (Term.var vt Nat.0)
	 (\i1:Nat \_:Term -> Term.shiftvar (shiftn1 i1)))


Definition Term.substn =
  Term.rec (\_:Term -> n:Nat -> Term -> Term)
    (\vt:VarType \_: Term \r1:(Nat->Term->Term)
     \_:Term \r2:(Nat->Term -> Term)
     \n:Nat \subst:Term ->
     Term.lam vt (r1 n subst) (r2 (Nat.s n) subst))
    (\vt:VarType \_: Term \r1:(Nat->Term->Term)
     \_:Term \r2:(Nat->Term -> Term)
     \n:Nat \subst:Term ->
     Term.pi vt (r1 n subst) (r2 (Nat.s n) subst))
    (\_: Term \r1:(Nat->Term->Term)
     \_:Term \r2:(Nat->Term -> Term)
     \n:Nat \subst:Term ->
     Term.app (r1 n subst) (r2 n subst))
    (\vt:VarType \i:Nat \n:Nat \subst:Term -> Term.var.substn vt subst n i)
    (\vt:VarType \n:Nat \subst:Term -> Term.univ vt)

Definition Term.subst = \term:Term \subst:Term ->
    Term.substn term Nat.0 subst

;; Lemma 1: Substitution on M.shift
;; I (Term.subst (Term.shiftvar M) N) M
Definition Term.substn.shiftn.id =
  Let Thesis = (\M:Term -> n:Nat ->
     N:Term -> I (Term.substn (Term.shiftn M n) n N) M) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 (Term.lam vt) (HypM1 n N) (HypM2 (Nat.s n) N))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 (Term.pi vt) (HypM1 n N) (HypM2 (Nat.s n) N))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 Term.app (HypM1 n N) (HypM2 n N))
    (\vt:VarType \i:Nat \n:Nat \N:Term ->
     Let Aux = (\n:Nat \i:Nat -> 
           I (Term.var.substn vt N n (Nat.shiftn n i))
    	     (Term.var vt i)) ->
     Nat.rec (\n:Nat -> i:Nat -> Aux n i)
        (\i:Nat ->
           I.r (Term.var vt i))
        (\n:Nat \Hyp:(i:Nat -> Aux n i) ->
          Nat.rec (\i:Nat -> Aux (Nat.s n) i)
             (I.r (Term.var vt Nat.0))
             (\i:Nat \_:(Aux (Nat.s n) i) ->
	      I.cong Term.shiftvar (Hyp i)))
     n i)
    (\vt:VarType \n:Nat \N:Term -> I.r (Term.univ vt))
Definition Term.shiftvar.subst.id = \M:Term \N:Term ->
  Term.substn.shiftn.id M Nat.0 N

;; Lemma 2: Arbitrary Substitution on M.shift
;; I (Term.substn (Term.shiftvar M) (Nat.s i) N)
;;   (Term.shiftvar (Term.substn M i N))
Definition Term.substn.shiftvar.commutes = \i:Nat \N:Term ->
  Let Thesis = (\M:Term -> n:Nat ->
      I (Term.substn (Term.shiftn M n) (Nat.s (Nat.plus n i)) N)
      	(Term.shiftn (Term.substn M (Nat.plus n i) N) n)) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \j:Nat \n:Nat ->
     Let Aux = (\n:Nat \j:Nat -> 
           I (Term.var.substn vt N (Nat.s (Nat.plus n i)) (Nat.shiftn n j))
    	     (Term.shiftn (Term.var.substn vt N (Nat.plus n i) j) n)) ->
     Nat.rec (\n:Nat -> j:Nat -> Aux n j)
        (\j:Nat ->
           I.r (Term.var.substn vt N (Nat.s i) (Nat.s j)))
        (\n:Nat \Hyp:(j:Nat -> Aux n j) ->
          Nat.rec (\j:Nat -> Aux (Nat.s n) j)
             (I.r (Term.var vt Nat.0))
             (\j:Nat \_:(Aux (Nat.s n) j) ->
	      I.trans (I.cong Term.shiftvar (Hyp j))
	      	      (Term.shiftvarn.commutes
		         (Term.var.substn vt N (Nat.plus n i) j) n)))
     n j)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))
  
Definition Term.subst.shiftvar.commutes = \M:Term \i:Nat \N:Term ->
  Term.substn.shiftvar.commutes i N M Nat.0

;; Lemma 3: Nested Substitutions
;; I (Term.subst (Term.substn M n2+1 N2) (Term.substn N n2 N2))
;;   (Term.substn (Term.subst M N) n2 N2)
Definition Term.substn.commutes = \N:Term \n2:Nat \N2:Term ->
  Let Thesis = (\M:Term -> n:Nat ->
    I (Term.substn (Term.substn M (Nat.s (Nat.plus n n2)) N2)
                   n (Term.substn N n2 N2))
      (Term.substn (Term.substn M n N) (Nat.plus n n2) N2)) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \i:Nat \n:Nat ->
     Let Aux = (\n:Nat \i:Nat -> 
           I (Term.substn (Term.var.substn vt N2 (Nat.s (Nat.plus n n2)) i)
	     		  n (Term.substn N n2 N2))
    	     (Term.substn (Term.var.substn vt N n i) (Nat.plus n n2) N2)) ->
     Nat.rec (\n:Nat -> i:Nat -> Aux n i)
        (Nat.rec (\i:Nat -> Aux Nat.0 i)
	   (I.r (Term.substn N n2 N2))
	   (\i:Nat \_:Aux Nat.0 i ->
	    Term.substn.shiftn.id (Term.var.substn vt N2 n2 i)
	   	      Nat.0 (Term.substn N n2 N2)))
        (\n:Nat \Hyp:(i:Nat -> Aux n i) ->
          Nat.rec (\i:Nat -> Aux (Nat.s n) i)
             (I.r (Term.var vt Nat.0))
             (\i:Nat \_:(Aux (Nat.s n) i) ->
	      I.trans (Term.subst.shiftvar.commutes
	      	         (Term.var.substn vt N2 (Nat.s (Nat.plus n n2)) i)
			 n (Term.substn N n2 N2))
	      (I.trans (I.cong Term.shiftvar (Hyp i))
	      (I.symm  (Term.subst.shiftvar.commutes
	      	         (Term.var.substn vt N n i) (Nat.plus n n2) N2)))))
     n i)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))

Definition Term.subst.substn.commutes = \M:Term \N:Term \n2:Nat \N2:Term ->
   Term.substn.commutes N n2 N2 M Nat.0

TypeCheck Term.subst.substn.commutes : M:Term -> N:Term -> n2:Nat -> N2:Term ->
   I (Term.subst (Term.substn M (Nat.s n2) N2) (Term.substn N n2 N2))
     (Term.substn (Term.subst M N) n2 N2)

;; Lemma 4: Shift and Substitution
;; Term.subst.shiftn N n2 M n =
;; I (Term.substn (Term.shiftn M n+n2+1) n (Term.shiftn N n2))
;;   (Term.shiftn (Term.substn M n N) n+n2)
Definition Term.subst.shiftn = \N:Term \n2:Nat ->
  Let Thesis = (\M:Term -> n:Nat ->
    I (Term.substn (Term.shiftn M (Nat.s (Nat.plus n n2)))
                   n (Term.shiftn N n2))
      (Term.shiftn (Term.substn M n N) (Nat.plus n n2))) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \i:Nat \n:Nat ->
     Let Aux = (\n:Nat \i:Nat -> 
           I (Term.var.substn vt (Term.shiftn N n2) n
	     		      (Nat.shiftn (Nat.s (Nat.plus n n2)) i))
    	     (Term.shiftn (Term.var.substn vt N n i) (Nat.plus n n2))) ->
     Nat.rec (\n:Nat -> i:Nat -> Aux n i)
        (Nat.rec (\i:Nat -> Aux Nat.0 i)
	   (I.r (Term.shiftn N n2))
	   (\i:Nat \_:Aux Nat.0 i ->
	    Term.substn.shiftn.id (Term.var vt (Nat.shiftn n2 i))
	   	      Nat.0 (Term.shiftn N n2)))
        (\n:Nat \Hyp:(i:Nat -> Aux n i) ->
          Nat.rec (\i:Nat -> Aux (Nat.s n) i)
             (I.r (Term.var vt Nat.0))
             (\i:Nat \_:(Aux (Nat.s n) i) ->
	      I.trans (Term.subst.shiftvar.commutes
	      	         (Term.var vt (Nat.shiftn (Nat.s (Nat.plus n n2)) i))
			 n (Term.shiftn N n2))
	      (I.trans (I.cong Term.shiftvar (Hyp i))
	               (Term.shiftvarn.commutes
	      	         (Term.var.substn vt N n i) (Nat.plus n n2)))))
     n i)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))
Definition Term.subst.shift = \t:Term \subst:Term \n:Nat ->
    I.symm (Term.subst.shiftn subst n t Nat.0)

TypeCheck Term.subst.shift : t:Term -> subst:Term -> n:Nat ->
    I (Term.shiftn (Term.subst t subst) n)
      (Term.subst (Term.shiftn t (Nat.s n)) (Term.shiftn subst n))

;===========================================
;  Beta Conversion
;===========================================

; One step of beta conversion
Inductive ConvStep : Term -> Term -> U =
  beta : vt:VarType -> T:Term -> M:Term -> N:Term ->
         ConvStep (Term.app (Term.lam vt T M) N) (Term.subst M N),
  lam1 : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.lam vt T1 M) (Term.lam vt T2 M),
  lam2 : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.lam vt T M1) (Term.lam vt T M2),
  pi1  : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.pi vt T1 M) (Term.pi vt T2 M),
  pi2  : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.pi vt T M1) (Term.pi vt T M2),
  app1 : {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> N:Term ->
         ConvStep (Term.app M1 N) (Term.app M2 N),
  app2 : M:Term -> {N1:Term} -> {N2:Term} -> ConvStep N1 N2 ->
         ConvStep (Term.app M N1) (Term.app M N2)

; Lemma: ConvStep applies the same for shifted terms.
; ConvStep T S -> ConvStep (Term.shiftn T n) (Term.shiftn S n)
Definition ConvStep.shiftn = 
  Let Thesis = (\T:Term \S:Term -> n:Nat ->
      ConvStep (Term.shiftn T n) (Term.shiftn S n)) ->
  ConvStep.rec (\T:Term \S: Term \step : ConvStep T S -> Thesis T S)
    (\vt:VarType \T:Term \M:Term \N:Term \n:Nat ->
     I.rsubst (Term.subst.shift M N n)
	      (\x: Term ->
	       ConvStep (Term.shiftn (Term.app (Term.lam vt T M) N) n) x)
     (ConvStep.beta vt (Term.shiftn T n) (Term.shiftn M (Nat.s n))
		    (Term.shiftn N n)))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n:Nat ->
     ConvStep.lam1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n:Nat ->
     ConvStep.lam2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n:Nat ->
     ConvStep.pi1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n:Nat ->
     ConvStep.pi2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n:Nat ->
     ConvStep.app1 (hyp n) (Term.shiftn M n))
    (\T:Term \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \n:Nat ->
     ConvStep.app2 (Term.shiftn T n) (hyp n))

Definition ConvStep.substn =
  Let Thesis = (\T:Term \S:Term -> n2:Nat -> N2:Term ->
      ConvStep (Term.substn T n2 N2) (Term.substn S n2 N2)) ->
  ConvStep.rec ({\T:Term} {\S: Term} \step : ConvStep T S -> Thesis T S)
    (\vt:VarType \T:Term \M:Term \N:Term \n2:Nat \N2:Term ->
     I.subst (Term.subst.substn.commutes M N n2 N2)
	     (\x: Term ->
	      ConvStep (Term.substn (Term.app (Term.lam vt T M) N) n2 N2) x)
     (ConvStep.beta vt (Term.substn T n2 N2)
     		    (Term.substn M (Nat.s n2) N2) (Term.substn N n2 N2)))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n2:Nat \N2:Term ->
     ConvStep.lam1 vt (hyp n2 N2) (Term.substn M (Nat.s n2) N2))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n2:Nat \N2:Term ->
     ConvStep.lam2 vt (hyp (Nat.s n2) N2) (Term.substn T n2 N2))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n2:Nat \N2:Term ->
     ConvStep.pi1 vt (hyp n2 N2) (Term.substn M (Nat.s n2) N2))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n2:Nat \N2:Term ->
     ConvStep.pi2 vt (hyp (Nat.s n2) N2) (Term.substn T n2 N2))
    (\T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n2:Nat \N2:Term ->
     ConvStep.app1 (hyp n2 N2) (Term.substn M n2 N2))
    (\T:Term \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \n2:Nat \N2:Term ->
     ConvStep.app2 (Term.substn T n2 N2) (hyp n2 N2))

Inductive ConvSymmStep : M:Term -> N:Term -> U =
  forw : ConvStep M N -> ConvSymmStep M N,
  back : ConvStep N M -> ConvSymmStep M N

Definition ConvSymmStep.shiftn = {\T:Term} {\S: Term} ->
   ConvSymmStep.rec (\step : ConvSymmStep T S -> n:Nat -> 
                         ConvSymmStep (Term.shiftn T n) (Term.shiftn S n))
	(\fstep:ConvStep T S \n:Nat ->
	 ConvSymmStep.forw (Term.shiftn T n) (Term.shiftn S n)
	 		   (ConvStep.shiftn fstep n))
	(\bstep:ConvStep S T \n:Nat ->
	 ConvSymmStep.back (Term.shiftn T n) (Term.shiftn S n)
	 		   (ConvStep.shiftn bstep n))

Definition ConvSymmStep.substn = {\T:Term} {\S: Term} ->
   ConvSymmStep.rec (\step : ConvSymmStep T S -> n2:Nat -> N2:Term -> 
                         ConvSymmStep (Term.substn T n2 N2) (Term.substn S n2 N2))
	(\fstep:ConvStep T S \n2:Nat \N2:Term ->
	 ConvSymmStep.forw (Term.substn T n2 N2) (Term.substn S n2 N2)
	 		   (ConvStep.substn fstep n2 N2))
	(\bstep:ConvStep S T \n2:Nat \N2:Term ->
	 ConvSymmStep.back (Term.substn T n2 N2) (Term.substn S n2 N2)
	 		   (ConvStep.substn bstep n2 N2))

;===========================================
;  Type Checking
;===========================================

Inductive VarList : U =
  nil  : VarList,
  cons : vt:VarType -> T:Term -> Gamma:VarList -> VarList

; The type checking rules of CC
Inductive CCTypeCheck : VarList -> Term -> Term -> U =
  ax   : CCTypeCheck VarList.nil Term.* Term.[],
  var  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.var vt Nat.0) (Term.shiftvar T),
  weak : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         {M : Term} -> {S:Term} -> CCTypeCheck Gamma M S ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.shiftvar M) (Term.shiftvar S),
  pi   : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
	 {vt2 : VarType} -> {S : Term} ->
	 CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2),
  lam  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         {M:Term} -> {S:Term} ->
         CCTypeCheck (VarList.cons vt T Gamma) M S ->
	 {vt2: VarType} -> CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.lam vt T M) (Term.pi vt T S),
  app  : {Gamma:VarList} -> {M:Term} -> {vt: VarType} -> {T : Term} -> {S:Term} ->
         CCTypeCheck Gamma M (Term.pi vt T S) ->
	 {N : Term} -> CCTypeCheck Gamma N T ->
	 CCTypeCheck Gamma (Term.app M N) (Term.subst S N),
  conv : {Gamma:VarList} -> {M:Term} -> {T:Term} -> CCTypeCheck Gamma M T ->
	 {S : Term} -> ConvSymmStep T S ->
	 CCTypeCheck Gamma M S

; Type Checking rules for a VarList Gamma.
Inductive VarListTypeCheck : VarList -> U =
  nil  : VarListTypeCheck VarList.nil,
  cons : {vt:VarType} -> {T:Term} -> {Gamma:VarList} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
 	 VarListTypeCheck Gamma -> 
         VarListTypeCheck (VarList.cons vt T Gamma)

Definition CCTypeCheck.ax2 = 
  VarListTypeCheck.rec ({\Gamma:VarList} \_:VarListTypeCheck Gamma ->
                        CCTypeCheck Gamma Term.* Term.[])
     CCTypeCheck.ax
     (\vt:VarType \T:Term \Gamma:VarList
      \tc:CCTypeCheck Gamma T (Term.univ vt)
      \_:VarListTypeCheck Gamma
      \r:CCTypeCheck Gamma Term.* Term.[] ->
        CCTypeCheck.weak tc r)

Definition CCTypeCheck.gammatc =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
                   VarListTypeCheck Gamma)
    VarListTypeCheck.nil
    ;var
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma
     \M : Term \S:Term \_: CCTypeCheck Gamma M S \_:VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

; delete the first n entries from a VarList
Definition VarList.deleten =
  Nat.rec (\n:Nat -> VarList -> VarList)
    (\Gamma:VarList -> Gamma)
    (\_:Nat \delrec:(VarList -> VarList) ->
     VarList.rec (\Gamma:VarList -> VarList) VarList.nil
        (\vt1:VarType \T1:Term \Gamma:VarList \_:VarList -> delrec Gamma))
    
; Insert a variable at position n in a VarList
Definition VarList.insertn =
  Nat.rec (\n:Nat -> VarType -> Term -> VarList -> VarList)
    VarList.cons
    (\n:Nat \insertrec:(VarType -> Term -> VarList -> VarList)
     \vt:VarType \T0:Term ->
     VarList.rec (\Gamma:VarList -> VarList)
        (insertrec vt T0 VarList.nil)
	(\vt1:VarType \T1:Term \Gamma:VarList \_:VarList ->
	 VarList.cons vt1 (Term.shiftn T1 n) (insertrec vt T0 Gamma)))
	 
Definition deletenil =
  Nat.rec (\n:Nat -> I (VarList.deleten n VarList.nil) VarList.nil)
     (I.r VarList.nil)
     (\n:Nat \_:I (VarList.deleten n VarList.nil) VarList.nil ->
      I.r VarList.nil)
TypeCheck deletenil : n:Nat -> I (VarList.deleten n VarList.nil) VarList.nil

; Lemma: Typecheck is preserved if we insert a variable in the middle of Gamma
; and adapt the numbering accordingly.
; Gamma |- M : N   and  (deleten n Gamma) |- T0 : */[]  implies
; (insertn n T0 Gamma) |- (shiftn n M) : (shiftn n N)
;
; Proof is by induction over "Gamma |- M : N"
Definition CCTypeCheck.weakn =
  \vt:VarType \T0:Term ->
  CCTypeCheck.rec ({\Gamma:VarList} {\M:Term} {\N:Term}
  		   \_:CCTypeCheck Gamma M N ->
                   n:Nat ->
		   CCTypeCheck (VarList.deleten n Gamma)
		       		T0 (Term.univ vt) ->
                   CCTypeCheck (VarList.insertn n vt T0 Gamma)
		                (Term.shiftn M n)
				(Term.shiftn N n))
    ;ax
    (Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
	      CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                    (Term.shiftn Term.* n)
				    (Term.shiftn Term.[] n))
       (\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 CCTypeCheck.ax)
       (\n:Nat
        \rec:(CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
              CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                 (Term.shiftn Term.* n)
				 (Term.shiftn Term.[] n))
	\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
	rec (I.rsubst (deletenil n)
		      (\x:VarList -> CCTypeCheck x T0 (Term.univ vt))
		      prfT0)))
    ;var
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.var vt1 Nat.0) n)
			  (Term.shiftn (Term.shiftvar T1) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.var prf1))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.var vt1 Nat.0) n)
			 (Term.shiftn (Term.shiftvar T1) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst (Term.shiftvarn.commutes T1 n)
	        (\x:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       (Term.var vt1 Nat.0)  x)
	 (CCTypeCheck.var (Hyp n prfT0))))
    ;weak
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \M : Term \S:Term
     \prf2: CCTypeCheck Gamma M S
     \Hyp2: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma) 
	              (Term.shiftn M n) (Term.shiftn S n)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.shiftvar M) n)
			  (Term.shiftn (Term.shiftvar S) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.weak prf1 prf2))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.shiftvar M) n)
			 (Term.shiftn (Term.shiftvar S) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst2 (Term.shiftvarn.commutes M n)
		 (Term.shiftvarn.commutes S n)
	         (\x:Term \y:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       x y)
	 (CCTypeCheck.weak (Hyp1 n prfT0) (Hyp2 n prfT0))))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \vt2:VarType \S:Term
     \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n
     	    	          (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                 (Term.shiftn S n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.pi (Hyp1 n prfT0) (Hyp2 (Nat.s n) prfT0))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	    		T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                (Term.shiftn M n) (Term.shiftn S n)) ->
     \vt2:VarType
     \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn (Term.pi vt1 T1 S) n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.lam (Hyp1 (Nat.s n) prfT0) (Hyp2 n prfT0))
    ;app
    (\Gamma:VarList \M:Term \vt1:VarType \T1:Term \S:Term
     \prf1: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn (Term.pi vt1 T1 S) n)) ->
     \N:Term
     \prf2:CCTypeCheck Gamma N T1
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn N n) (Term.shiftn T1 n))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     I.rsubst (Term.subst.shift S N n)
	      (\x: Term -> CCTypeCheck (VarList.insertn n vt T0 Gamma)
	      	                       (Term.shiftn (Term.app M N) n) x)
     (CCTypeCheck.app (Hyp1 n prfT0) (Hyp2 n prfT0)))
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \prf1: CCTypeCheck Gamma M T
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn T n))
     \S:Term \step:ConvSymmStep T S
     \n:Nat 
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     (CCTypeCheck.conv (Hyp1 n prfT0) (ConvSymmStep.shiftn step n)))

Definition VarList.subst.nth = \N:Term ->
  VarList.rec (\_:VarList -> Nat -> VarList)
    (\n:Nat -> VarList.nil)
    (\vt1:VarType \T1:Term \Gamma:VarList \Hyp:(Nat -> VarList) ->
    Nat.rec (\i:Nat -> VarList)
      Gamma
      (\i:Nat \_:VarList -> VarList.cons vt1 (Term.substn T1 i N) (Hyp i)))

Definition VarList.TypeCheck.nth = \N:Term ->
  VarList.rec (\_:VarList -> Nat -> U)
    (\n:Nat -> F)
    (\vt1:VarType \T1:Term \Gamma:VarList \Hyp:(Nat -> U) ->
    Nat.rec (\i:Nat -> U)
      (CCTypeCheck Gamma N T1)
      (\i:Nat \_:U -> Hyp i))

Definition CCTypeCheck.substn = \vt:VarType \T0:Term \N:Term ->
  Let Thesis = (\Gamma:VarList \M:Term \S:Term \n:Nat ->
     VarList.TypeCheck.nth N Gamma n ->
     CCTypeCheck (VarList.subst.nth N Gamma n)
     		 (Term.substn M n N) (Term.substn S n N)) ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term
                   \_:CCTypeCheck Gamma M S -> n:Nat -> Thesis Gamma M S n)
     ;ax
     (\n:Nat -> F.rec (\_:F -> CCTypeCheck VarList.nil Term.* Term.[]))
     ; var
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n) ->
      Nat.rec (\n:Nat -> Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	 	(Term.var vt1 Nat.0) (Term.shiftvar T1) n)
	  (I.rsubst (Term.shiftvar.subst.id T1 N)
	   	    (\x:Term -> CCTypeCheck Gamma N x))
	  (\n:Nat\_:(Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	    (Term.var vt1 Nat.0) (Term.shiftvar T1) n) ->
	   \prfN: VarList.TypeCheck.nth N Gamma n ->
	   I.rsubst (Term.subst.shiftvar.commutes T1 n N)
		    (\x:Term -> CCTypeCheck
		    	 (VarList.subst.nth N (VarList.cons vt1 T1 Gamma)
			 		    (Nat.s n))
			 (Term.var vt1 Nat.0) x)
		    (CCTypeCheck.var (Hyp n prfN))))
     ; weak
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n)
      \M1:Term \S1:Term
      \prf2:CCTypeCheck Gamma M1 S1
      \Hyp2:(n:Nat -> Thesis Gamma M1 S1 n) ->
      Nat.rec (\n:Nat -> Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	 	(Term.shiftvar M1) (Term.shiftvar S1) n)
	  (\_:CCTypeCheck Gamma N T1 ->
	   I.subst2 (I.symm (Term.shiftvar.subst.id M1 N))
	  	    (I.symm (Term.shiftvar.subst.id S1 N))
	   	    (\x:Term \y:Term -> CCTypeCheck Gamma x y)
		    prf2)
	  (\n:Nat\_:(Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	    (Term.shiftvar M1) (Term.shiftvar S1) n) ->
	   \prfN: VarList.TypeCheck.nth N Gamma n ->
	   I.subst2 (I.symm (Term.subst.shiftvar.commutes M1 n N))
	   	    (I.symm (Term.subst.shiftvar.commutes S1 n N))
		    (\x:Term \y:Term ->
		     CCTypeCheck (VarList.subst.nth N
		    		  (VarList.cons vt1 T1 Gamma) (Nat.s n)) x y)
		    (CCTypeCheck.weak (Hyp1 n prfN) (Hyp2 n prfN))))
     ; pi
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n)
      \vt2:VarType \S:Term
      \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
      \Hyp2:(n:Nat -> Thesis (VarList.cons vt1 T1 Gamma) S (Term.univ vt2) n)
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      CCTypeCheck.pi (Hyp1 n prfN) (Hyp2 (Nat.s n) prfN))
     ; lam
     (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
      \prf1:CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
      \Hyp1:(n:Nat -> Thesis (VarList.cons vt1 T1 Gamma) M S n)
      \vt2:VarType
      \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
      \Hyp2:(n:Nat -> Thesis Gamma (Term.pi vt1 T1 S) (Term.univ vt2) n)
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      CCTypeCheck.lam (Hyp1 (Nat.s n) prfN) (Hyp2 n prfN))
     ; app
     (\Gamma:VarList \M1:Term \vt1:VarType \T1:Term \S:Term
      \prf1:CCTypeCheck Gamma M1 (Term.pi vt1 T1 S)
      \Hyp1:(n:Nat -> Thesis Gamma M1 (Term.pi vt1 T1 S) n)
      \M2:Term
      \prf2:CCTypeCheck Gamma M2 T1
      \Hyp2:(n:Nat -> Thesis Gamma M2 T1 n)
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      I.subst (Term.subst.substn.commutes S M2 n N)
	     (\x:Term ->
	      CCTypeCheck (VarList.subst.nth N Gamma n)
	      		  (Term.substn (Term.app M1 M2) n N) x)
             (CCTypeCheck.app (Hyp1 n prfN) (Hyp2 n prfN)))
     ; conv
     (\Gamma:VarList \M:Term \S1:Term
      \prf1:CCTypeCheck Gamma M S1
      \Hyp1:(n:Nat -> Thesis Gamma M S1 n)
      \S2:Term
      \prf2:ConvSymmStep S1 S2
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      CCTypeCheck.conv (Hyp1 n prfN) (ConvSymmStep.substn prf2 n N))

Definition CCTypeCheck.subst =
  {\vt0:VarType} {\T0:Term} {\Gamma:VarList} {\M:Term} {\S:Term}
  \prf:CCTypeCheck (VarList.cons vt0 T0 Gamma) M S {\N:Term} ->
  CCTypeCheck.substn vt0 T0 N prf Nat.0

TypeCheck CCTypeCheck.subst :
  (vt0:VarType -> T0:Term -> Gamma:VarList -> M:Term -> S:Term ->
  CCTypeCheck (VarList.cons vt0 T0 Gamma) M S -> N:Term -> 
  CCTypeCheck Gamma N T0 ->
  CCTypeCheck Gamma (Term.subst M N) (Term.subst S N))

;=================================
; Term accessors
;=================================

Definition Term.vt = Term.rec (\_:Term -> VarType)
  (\vt:VarType \_:Term \_:VarType \_:Term \_:VarType -> vt)
  (\vt:VarType \_:Term \_:VarType \_:Term \_:VarType -> vt)
  (\_:Term \_:VarType \_:Term \_:VarType -> VarType.*)
  (\vt:VarType \_:Nat -> vt)
  (\vt:VarType -> vt)
Definition Term.arg1 = Term.rec (\_:Term -> Term)
  (\_:VarType \t1:Term \_:Term \_:Term \_:Term -> t1)
  (\_:VarType \t1:Term \_:Term \_:Term \_:Term -> t1)
  (\t1:Term \_:Term \_:Term \_:Term -> t1)
  (\_:VarType \_:Nat -> Term.*)
  (\_:VarType -> Term.*)
Definition Term.arg2 = Term.rec (\_:Term -> Term)
  (\_:VarType \t1:Term \_:Term \t2:Term \_:Term -> t2)
  (\_:VarType \t1:Term \_:Term \t2:Term \_:Term -> t2)
  (\t1:Term \_:Term \t2:Term \_:Term -> t2)
  (\_:VarType \_:Nat -> Term.*)
  (\_:VarType -> Term.*)
Definition Term.n = Term.rec (\_:Term -> Nat)
  (\_:VarType \t1:Term \_:Nat \t2:Term \_:Nat -> Nat.0)
  (\_:VarType \t1:Term \_:Nat \t2:Term \_:Nat -> Nat.0)
  (\t1:Term \_:Nat \t2:Term \_:Nat -> Nat.0)
  (\_:VarType \n:Nat -> n)
  (\_:VarType -> Nat.0)
Definition Term.isLam = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.tt)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.ff)
Definition Term.isPi = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.tt)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.ff)
Definition Term.isApp = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.tt)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.ff)
Definition Term.isVar = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.tt)
  (\_:VarType -> Bool.ff)
Definition Term.isUniv = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.tt)

;=================================
; ConvStep*
;=================================

Inductive ConvStep* : Term -> Term -> U =
  id  : t:Term -> ConvStep* t t,
  cons: t:Term -> t':Term -> ConvStep t t' -> t'':Term -> ConvStep* t' t'' ->
        ConvStep* t t''

Definition ConvStep*.app =
  ConvStep*.rec (\t:Term \t':Term \_:ConvStep* t t' ->
  	        t'':Term -> ConvStep* t' t'' -> ConvStep* t t'')
    (\t:Term \t'':Term \step2:ConvStep* t t'' -> step2)
    (\t:Term \t':Term \step0:ConvStep t t' \t'':Term \step1:ConvStep* t' t''
     \Hyp:(t''':Term -> ConvStep* t'' t''' -> ConvStep* t' t''')
     \t''':Term \step2:ConvStep* t'' t''' ->
     ConvStep*.cons step0 (Hyp t''' step2))

Definition ConvStep*.lift =
  \f:(Term -> Term)
  \liftstep:(t:Term -> t':Term -> ConvStep t t' -> ConvStep (f t) (f t')) ->
  Let Thesis = (\t:Term \t':Term \_:ConvStep* t t' -> ConvStep* (f t) (f t')) ->
  ConvStep*.rec Thesis
    (\t:Term -> ConvStep*.id (f t))
    (\t:Term \t':Term \step:ConvStep t t'
     \t'':Term \path:ConvStep* t' t'' \Hyp:Thesis path ->
     ConvStep*.cons (liftstep step) Hyp)
  
Definition ConvStep*.lam1 =
  \vt:VarType \t:Term \t':Term \path: ConvStep* t t' \m:Term ->
  ConvStep*.lift (\t:Term -> Term.lam vt t m)
  		 (\t:Term \t':Term \st:ConvStep t t' -> ConvStep.lam1 vt st m)
		 path
Definition ConvStep*.lam2 =
  \vt:VarType \t:Term ->
  ConvStep*.lift (\m:Term -> Term.lam vt t m)
  		 (\m:Term \m':Term \st:ConvStep m m' -> ConvStep.lam2 vt st t)
Definition ConvStep*.pi1 =
  \vt:VarType \t:Term \t':Term \path: ConvStep* t t' \m:Term ->
  ConvStep*.lift (\t:Term -> Term.pi vt t m)
  		 (\t:Term \t':Term \st:ConvStep t t' -> ConvStep.pi1 vt st m)
		 path
Definition ConvStep*.pi2 =
  \vt:VarType \t:Term ->
  ConvStep*.lift (\m:Term -> Term.pi vt t m)
  		 (\m:Term \m':Term \st:ConvStep m m' -> ConvStep.pi2 vt st t)
Definition ConvStep*.app1 =
  \t:Term \t':Term \path: ConvStep* t t' \m:Term ->
  ConvStep*.lift (\t:Term -> Term.app t m)
  		 (\t:Term \t':Term \st:ConvStep t t' -> ConvStep.app1 st m)
		 path
Definition ConvStep*.app2 =
  \t:Term ->
  ConvStep*.lift (\m:Term -> Term.app t m)
  		 (\m:Term \m':Term \st:ConvStep m m' -> ConvStep.app2 t st)
Definition ConvStep*.shiftn =
  \t:Term \t':Term \path:ConvStep* t t' \n:Nat ->
  ConvStep*.lift (\m:Term -> Term.shiftn m n)
  		 (\m:Term \m':Term \st:ConvStep m m' -> ConvStep.shiftn st n)
		 path

Definition ConvStep*.substn.2 = \N:Term \N':Term \step:ConvStep N N'
  Let Thesis = (\M:Term -> n:Nat ->
      ConvStep* (Term.substn M n N) (Term.substn M n N')) ->
  Term.rec Thesis
    (\vt:VarType \t:Term \HypT:Thesis t \m:Term \HypM:Thesis m
     \n:Nat ->
     ConvStep*.app (ConvStep*.lam1 vt (HypT n) (Term.substn m (Nat.s n) N)) 
     		   (ConvStep*.lam2 vt (Term.substn t n N') (HypM (Nat.s n))))
    (\vt:VarType \t:Term \HypT:Thesis t \m:Term \HypM:Thesis m
     \n:Nat ->
     ConvStep*.app (ConvStep*.pi1 vt (HypT n) (Term.substn m (Nat.s n) N)) 
     		   (ConvStep*.pi2 vt (Term.substn t n N') (HypM (Nat.s n))))
    (\t:Term \HypT:Thesis t \m:Term \HypM:Thesis m \n:Nat ->
     ConvStep*.app (ConvStep*.app1 (HypT n) (Term.substn m n N)) 
     		   (ConvStep*.app2 (Term.substn t n N') (HypM n)))
    (\vt:VarType \i:Nat \n:Nat ->
     Let Aux = (\n:Nat \i:Nat ->
          ConvStep* (Term.var.substn vt N n i) (Term.var.substn vt N' n i)) ->
     Nat.rec (\n:Nat -> i:Nat -> Aux n i)
        (Nat.rec (\i:Nat -> Aux Nat.0 i)
	   (ConvStep*.cons step (ConvStep*.id N'))
           (\i:Nat \_:Aux Nat.0 i -> ConvStep*.id (Term.var vt i)))
        (\n:Nat \Hyp:(i:Nat -> Aux n i) ->
          Nat.rec (\i:Nat -> Aux (Nat.s n) i)
             (ConvStep*.id (Term.var vt Nat.0))
             (\i:Nat \_:(Aux (Nat.s n) i) ->
	      ConvStep*.shiftn (Hyp i) Nat.0))
     n i)
    (\vt:VarType \n:Nat -> ConvStep*.id (Term.univ vt))

;=================================
; ConvStep and TypeCheck
;=================================

; ConvStep Induction by Type
Definition ConvStep.lam.case =
  \vt:VarType \M0:Term \M1:Term \Thesis:(N:Term -> U)
  \case1: (N0:Term -> ConvStep M0 N0 -> Thesis (Term.lam vt N0 M1))
  \case2: (N1:Term -> ConvStep M1 N1 -> Thesis (Term.lam vt M0 N1))
  \N:Term \step: (ConvStep (Term.lam vt M0 M1) N) ->
  ConvStep.rec (\M:Term \N:Term \cv:ConvStep M N ->
                I (Term.lam vt M0 M1) M -> Thesis N)
    ;beta
    (\vt':VarType \M11:Term \M12:Term \M2:Term ->
     \eq:I (Term.lam vt M0 M1) (Term.app (Term.lam vt' M11 M12) M2) ->
     F.rec (\_:F -> Thesis (Term.subst M12 M2))
	(I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    ;lam1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.lam vt M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.lam vt M0 M1) (Term.lam vt' M0' M1') ->
     I.subst eq (\x:Term -> Thesis (Term.lam (Term.vt x) N0 (Term.arg2 x)))
       (case1 N0 (I.rsubst eq (\x:Term -> ConvStep (Term.arg1 x) N0) step)))
    ;lam2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.lam vt M0 M1) M1' -> Thesis N1)
     \M0':Term
     \eq:I (Term.lam vt M0 M1) (Term.lam vt' M0' M1') ->
     I.subst eq (\x:Term -> Thesis (Term.lam (Term.vt x) (Term.arg1 x) N1))
       (case2 N1 (I.rsubst eq (\x:Term -> ConvStep (Term.arg2 x) N1) step)))
    ;pi1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.lam vt M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.lam vt M0 M1) (Term.pi vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.pi vt' N0 M1'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    ;pi2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.lam vt M0 M1) M1' -> Thesis N1)
     \M0':Term
     \eq:I (Term.lam vt M0 M1) (Term.pi vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.pi vt' M0' N1))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    ;app1
    (\M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.lam vt M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.lam vt M0 M1) (Term.app M0' M1') ->
     F.rec (\_:F -> Thesis (Term.app N0 M1'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    ;app2
    (\M0':Term \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.lam vt M0 M1) M1' -> Thesis N1)
     \eq:I (Term.lam vt M0 M1) (Term.app M0' M1') ->
     F.rec (\_:F -> Thesis (Term.app M0' N1))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    step
    (I.r (Term.lam vt M0 M1))
TypeCheck ConvStep.lam.case :
  vt:VarType -> M0:Term -> M1:Term -> Thesis:(N:Term -> U) ->
  case1: (N0:Term -> ConvStep M0 N0 -> Thesis (Term.lam vt N0 M1)) ->
  case2: (N1:Term -> ConvStep M1 N1 -> Thesis (Term.lam vt M0 N1)) ->
  N:Term -> step: (ConvStep (Term.lam vt M0 M1) N) -> Thesis N


Definition ConvStep.pi.case =
  \vt:VarType \M0:Term \M1:Term \Thesis:(N:Term -> U)
  \case1: (N0:Term -> ConvStep M0 N0 -> Thesis (Term.pi vt N0 M1))
  \case2: (N1:Term -> ConvStep M1 N1 -> Thesis (Term.pi vt M0 N1))
  \N:Term \step: (ConvStep (Term.pi vt M0 M1) N) ->
  ConvStep.rec (\M:Term \N:Term \cv:ConvStep M N ->
                I (Term.pi vt M0 M1) M -> Thesis N)
    ;beta
    (\vt':VarType \M11:Term \M12:Term \M2:Term ->
     \eq:I (Term.pi vt M0 M1) (Term.app (Term.lam vt' M11 M12) M2) ->
     F.rec (\_:F -> Thesis (Term.subst M12 M2))
	(I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
    ;lam1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.pi vt M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.pi vt M0 M1) (Term.lam vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.lam vt' N0 M1'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
    ;lam2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.pi vt M0 M1) M1' -> Thesis N1)
     \M0':Term
     \eq:I (Term.pi vt M0 M1) (Term.lam vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.lam vt' M0' N1))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
    ;pi1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.pi vt M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.pi vt M0 M1) (Term.pi vt' M0' M1') ->
     I.subst eq (\x:Term -> Thesis (Term.pi (Term.vt x) N0 (Term.arg2 x)))
       (case1 N0 (I.rsubst eq (\x:Term -> ConvStep (Term.arg1 x) N0) step)))
    ;pi2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.pi vt M0 M1) M1' -> Thesis N1)
     \M0':Term
     \eq:I (Term.pi vt M0 M1) (Term.pi vt' M0' M1') ->
     I.subst eq (\x:Term -> Thesis (Term.pi (Term.vt x) (Term.arg1 x) N1))
       (case2 N1 (I.rsubst eq (\x:Term -> ConvStep (Term.arg2 x) N1) step)))
    ;app1
    (\M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.pi vt M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.pi vt M0 M1) (Term.app M0' M1') ->
     F.rec (\_:F -> Thesis (Term.app N0 M1'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
    ;app2
    (\M0':Term \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.pi vt M0 M1) M1' -> Thesis N1)
     \eq:I (Term.pi vt M0 M1) (Term.app M0' M1') ->
     F.rec (\_:F -> Thesis (Term.app M0' N1))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
    step
    (I.r (Term.pi vt M0 M1))
TypeCheck ConvStep.pi.case :
  vt:VarType -> M0:Term -> M1:Term -> Thesis:(N:Term -> U) ->
  case1: (N0:Term -> ConvStep M0 N0 -> Thesis (Term.pi vt N0 M1)) ->
  case2: (N1:Term -> ConvStep M1 N1 -> Thesis (Term.pi vt M0 N1)) ->
  N:Term -> step: (ConvStep (Term.pi vt M0 M1) N) -> Thesis N

Definition ConvStep.app.case =
  \M0:Term \M1:Term \Thesis:(N:Term -> U)
  \casebeta: (vt:VarType -> M11:Term -> M12:Term ->
  	      I M0 (Term.lam vt M11 M12) ->
              Thesis (Term.subst M12 M1))
  \case1: (N0:Term -> ConvStep M0 N0 -> Thesis (Term.app N0 M1))
  \case2: (N1:Term -> ConvStep M1 N1 -> Thesis (Term.app M0 N1))
  \N:Term \step: (ConvStep (Term.app M0 M1) N) ->
  ConvStep.rec (\M:Term \N:Term \cv:ConvStep M N ->
                I (Term.app M0 M1) M -> Thesis N)
    ;beta
    (\vt':VarType \M11:Term \M12:Term \M2:Term ->
     \eq:I (Term.app M0 M1) (Term.app (Term.lam vt' M11 M12) M2) ->
     I.subst eq (\x:Term -> Thesis (Term.subst M12 (Term.arg2 x)))
       (casebeta vt' M11 M12 (I.cong Term.arg1 eq)))
    ;lam1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.app M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.app M0 M1) (Term.lam vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.lam vt' N0 M1'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
    ;lam2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.app M0 M1) M1' -> Thesis N1)
     \M0':Term
     \eq:I (Term.app M0 M1) (Term.lam vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.lam vt' M0' N1))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
    ;pi1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.app M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.app M0 M1) (Term.pi vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.pi vt' N0 M1'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
    ;pi2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.app M0 M1) M1' -> Thesis N1)
     \M0':Term
     \eq:I (Term.app M0 M1) (Term.pi vt' M0' M1') ->
     F.rec (\_:F -> Thesis (Term.pi vt' M0' N1))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
    ;app1
    (\M0':Term \N0:Term \step:ConvStep M0' N0
     \_:(I (Term.app M0 M1) M0' -> Thesis N0)
     \M1':Term
     \eq:I (Term.app M0 M1) (Term.app M0' M1') ->
     I.subst eq (\x:Term -> Thesis (Term.app N0 (Term.arg2 x)))
       (case1 N0 (I.rsubst eq (\x:Term -> ConvStep (Term.arg1 x) N0) step)))
    ;app2
    (\M0':Term \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:(I (Term.app M0 M1) M1' -> Thesis N1)
     \eq:I (Term.app M0 M1) (Term.app M0' M1') ->
     I.subst eq (\x:Term -> Thesis (Term.app (Term.arg1 x) N1))
       (case2 N1 (I.rsubst eq (\x:Term -> ConvStep (Term.arg2 x) N1) step)))
    step
    (I.r (Term.app M0 M1))
TypeCheck ConvStep.app.case :
  M0:Term -> M1:Term -> Thesis:(N:Term -> U) ->
  casebeta: (vt:VarType -> M11:Term -> M12:Term ->
  	     I M0 (Term.lam vt M11 M12) ->
             Thesis (Term.subst M12 M1)) ->
  case1: (N0:Term -> ConvStep M0 N0 -> Thesis (Term.app N0 M1)) ->
  case2: (N1:Term -> ConvStep M1 N1 -> Thesis (Term.app M0 N1)) ->
  N:Term -> step: (ConvStep (Term.app M0 M1) N) -> Thesis N

Definition ConvStep.var.case =
  \vt:VarType \n:Nat ->
  ConvStep.rec (\M:Term \N:Term \cv:ConvStep M N -> Bool.ite (Term.isVar M) F T)
    ;beta
    (\vt':VarType \M11:Term \M12:Term \M2:Term -> T.tt)
    ;lam1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:Bool.ite (Term.isVar M0') F T
     \M1':Term -> T.tt)
    ;lam2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:Bool.ite (Term.isVar M1') F T
     \M0':Term -> T.tt)
    ;pi1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:Bool.ite (Term.isVar M0') F T
     \M1':Term -> T.tt)
    ;pi2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:Bool.ite (Term.isVar M1') F T
     \M0':Term -> T.tt)
    ;app1
    (\M0':Term \N0:Term \step:ConvStep M0' N0
     \_:Bool.ite (Term.isVar M0') F T \M1':Term -> T.tt)
    ;app2
    (\M0':Term \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:Bool.ite (Term.isVar M1') F T -> T.tt)
    (Term.var vt n)
TypeCheck ConvStep.var.case :
  vt:VarType -> n:Nat -> N:Term -> ConvStep (Term.var vt n) N -> F
Definition ConvStep.univ.case =
  \vt:VarType ->
  ConvStep.rec (\M:Term \N:Term \cv:ConvStep M N -> Bool.ite (Term.isUniv M) F T)
    ;beta
    (\vt':VarType \M11:Term \M12:Term \M2:Term -> T.tt)
    ;lam1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:Bool.ite (Term.isUniv M0') F T
     \M1':Term -> T.tt)
    ;lam2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:Bool.ite (Term.isUniv M1') F T
     \M0':Term -> T.tt)
    ;pi1
    (\vt':VarType \M0':Term \N0:Term \step:ConvStep M0' N0
     \_:Bool.ite (Term.isUniv M0') F T
     \M1':Term -> T.tt)
    ;pi2
    (\vt':VarType \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:Bool.ite (Term.isUniv M1') F T
     \M0':Term -> T.tt)
    ;app1
    (\M0':Term \N0:Term \step:ConvStep M0' N0
     \_:Bool.ite (Term.isUniv M0') F T \M1':Term -> T.tt)
    ;app2
    (\M0':Term \M1':Term \N1:Term \step:ConvStep M1' N1
     \_:Bool.ite (Term.isUniv M1') F T -> T.tt)
    (Term.univ vt)

Definition ConvStep.unshiftn.rec =
  \Thesis:(N:Term -> U)
  \M:Term \n:Nat
  \case:(N:Term -> ConvStep M N -> Thesis (Term.shiftn N n))
  \Ns:Term \step:ConvStep (Term.shiftn M n) Ns
  Let SigmaType = (\M:Term \n:Nat \Ns:Term \N:Term ->
                   * (ConvStep M N) (I (Term.shiftn N n) Ns))
  Let Th = (\M:Term -> n:Nat -> Ns:Term ->
            ConvStep (Term.shiftn M n) Ns ->
	    Sigma (SigmaType M n Ns)) ->
  Let sigma = Term.rec Th
    (\vt:VarType \M1:Term \Hyp1:Th M1 \M2:Term \Hyp2:Th M2
     \n:Nat ->
     ConvStep.lam.case vt (Term.shiftn M1 n) (Term.shiftn M2 (Nat.s n))
        (\Ns:Term -> Sigma (SigmaType (Term.lam vt M1 M2) n Ns))
	(\Ns1:Term \step:ConvStep (Term.shiftn M1 n) Ns1 ->
	 Let sigma = (Hyp1 n Ns1 step) ->
	 Sigma.mk (SigmaType (Term.lam vt M1 M2) n (Term.lam vt Ns1 (Term.shiftn M2 (Nat.s n))))
	     (Term.lam vt (Sigma.1 sigma) M2)
	     (*.mk (ConvStep.lam1 vt (*.1 (Sigma.2 sigma)) M2)
	           (I.cong (\x:Term -> Term.lam vt x (Term.shiftn M2 (Nat.s n)))
		           (*.2 (Sigma.2 sigma)))))
	(\Ns2:Term \step:ConvStep (Term.shiftn M2 (Nat.s n)) Ns2 ->
	 Let sigma = (Hyp2 (Nat.s n) Ns2 step) ->
	 Sigma.mk (SigmaType (Term.lam vt M1 M2) n (Term.lam vt (Term.shiftn M1 n) Ns2))
	     (Term.lam vt M1 (Sigma.1 sigma))
	     (*.mk (ConvStep.lam2 vt (*.1 (Sigma.2 sigma)) M1)
	           (I.cong (\x:Term -> Term.lam vt (Term.shiftn M1 n) x)
		           (*.2 (Sigma.2 sigma))))))
    (\vt:VarType \M1:Term \Hyp1:Th M1 \M2:Term \Hyp2:Th M2
     \n:Nat ->
     ConvStep.pi.case vt (Term.shiftn M1 n) (Term.shiftn M2 (Nat.s n))
        (\Ns:Term -> Sigma (SigmaType (Term.pi vt M1 M2) n Ns))
	(\Ns1:Term \step:ConvStep (Term.shiftn M1 n) Ns1 ->
	 Let sigma = (Hyp1 n Ns1 step) ->
	 Sigma.mk (SigmaType (Term.pi vt M1 M2) n (Term.pi vt Ns1 (Term.shiftn M2 (Nat.s n))))
	     (Term.pi vt (Sigma.1 sigma) M2)
	     (*.mk (ConvStep.pi1 vt (*.1 (Sigma.2 sigma)) M2)
	           (I.cong (\x:Term -> Term.pi vt x (Term.shiftn M2 (Nat.s n)))
		           (*.2 (Sigma.2 sigma)))))
	(\Ns2:Term \step:ConvStep (Term.shiftn M2 (Nat.s n)) Ns2 ->
	 Let sigma = (Hyp2 (Nat.s n) Ns2 step) ->
	 Sigma.mk (SigmaType (Term.pi vt M1 M2) n (Term.pi vt (Term.shiftn M1 n) Ns2))
	     (Term.pi vt M1 (Sigma.1 sigma))
	     (*.mk (ConvStep.pi2 vt (*.1 (Sigma.2 sigma)) M1)
	           (I.cong (\x:Term -> Term.pi vt (Term.shiftn M1 n) x)
		           (*.2 (Sigma.2 sigma))))))
    (\M1:Term \Hyp1:Th M1 \M2:Term \Hyp2:Th M2
     \n:Nat ->
     ConvStep.app.case (Term.shiftn M1 n) (Term.shiftn M2 n)
        (\Ns:Term -> Sigma (SigmaType (Term.app M1 M2) n Ns))
	(\vt:VarType \M11s:Term \M12s:Term
	 \eq:I (Term.shiftn M1 n) (Term.lam vt M11s M12s) ->
	 I.subst eq (\x:Term -> Bool.ite (Term.isLam x)
	      (Sigma (SigmaType (Term.app M1 M2) n (Term.subst (Term.arg2 x) (Term.shiftn M2 n))))
	      T)
	 (Let Th2 =
	   (\M1:Term -> Bool.ite (Term.isLam (Term.shiftn M1 n))
	      (Sigma (SigmaType (Term.app M1 M2) n (Term.subst (Term.arg2 (Term.shiftn M1 n)) (Term.shiftn M2 n))))
	      T) ->
	  Term.rec Th2
	   (\vt:VarType \M11:Term \_:Th2 M11 \M12:Term \_:Th2 M12 ->
	    Sigma.mk (SigmaType (Term.app (Term.lam vt M11 M12) M2) n (Term.subst (Term.shiftn M12 (Nat.s n)) (Term.shiftn M2 n)))
	     (Term.subst M12 M2)
	     (*.mk (ConvStep.beta vt M11 M12 M2)
	     	   (I.symm (Term.subst.shiftn M2 n M12 Nat.0))))
	   (\vt:VarType \M11:Term \_:Th2 M11 \M12:Term \_:Th2 M12 ->T.tt)
	   (\M11:Term \_:Th2 M11 \M12:Term \_:Th2 M12 -> T.tt)
	   (\vt:VarType \n:Nat -> T.tt)
	   (\vt:VarType -> T.tt)
	   M1))
	(\Ns1:Term \step:ConvStep (Term.shiftn M1 n) Ns1 ->
	 Let sigma = (Hyp1 n Ns1 step) ->
	 Sigma.mk (SigmaType (Term.app M1 M2) n (Term.app Ns1 (Term.shiftn M2 n)))
	     (Term.app (Sigma.1 sigma) M2)
	     (*.mk (ConvStep.app1 (*.1 (Sigma.2 sigma)) M2)
	           (I.cong (\x:Term -> Term.app x (Term.shiftn M2 n))
		           (*.2 (Sigma.2 sigma)))))
	(\Ns2:Term \step:ConvStep (Term.shiftn M2 n) Ns2 ->
	 Let sigma = (Hyp2 n Ns2 step) ->
	 Sigma.mk (SigmaType (Term.app M1 M2) n (Term.app (Term.shiftn M1 n) Ns2))
	     (Term.app M1 (Sigma.1 sigma))
	     (*.mk (ConvStep.app2 M1 (*.1 (Sigma.2 sigma)))
	           (I.cong (\x:Term -> Term.app (Term.shiftn M1 n) x)
		           (*.2 (Sigma.2 sigma))))))
    (\vt:VarType \i:Nat
     \n:Nat ->
     \Ns:Term \step: ConvStep (Term.shiftn (Term.var vt i) n) Ns ->
     F.rec (\_:F -> Sigma (SigmaType (Term.var vt i) n Ns))
       (ConvStep.var.case step))
    (\vt:VarType
     \n:Nat ->
     \Ns:Term \step: ConvStep (Term.shiftn (Term.univ vt) n) Ns ->
     F.rec (\_:F -> Sigma (SigmaType (Term.univ vt) n Ns))
       (ConvStep.univ.case step)) M n Ns step ->
  I.subst (*.2 (Sigma.2 sigma))
    (\x:Term -> Thesis x)
    (case (Sigma.1 sigma) (*.1 (Sigma.2 sigma)))
TypeCheck ConvStep.unshiftn.rec :
  Thesis:(N:Term -> U) ->
  M:Term -> n:Nat -> 
  case:(N:Term -> ConvStep M N -> Thesis (Term.shiftn N n)) ->
  Ns:Term -> step:ConvStep (Term.shiftn M n) Ns ->
  Thesis Ns

Assume CCTypeCheck.Pi.Univ :
  Gamma:VarList -> vt:VarType -> S1:Term -> S2:Term -> vt1:VarType ->
  CCTypeCheck Gamma (Term.pi vt S1 S2) (Term.univ vt1) ->
  CCTypeCheck Gamma S1 (Term.univ vt)
Assume ConvStep.TC.Gamma :
  M1:Term -> M2:Term -> ConvStep M1 M2 ->
  Gamma:VarList -> vt:VarType -> CCTypeCheck Gamma M2 (Term.univ vt) ->
  S1:Term -> S2:Term ->
  CCTypeCheck (VarList.cons vt M1 Gamma) S1 S2 ->
  CCTypeCheck (VarList.cons vt M2 Gamma) S1 S2

Definition CCTypeCheck.convback* =
  \Gamma:VarList \S1:Term \S2': Term -> \tc:CCTypeCheck Gamma S1 S2'
  \S2:Term \step:ConvStep* S2 S2'->
  ConvStep*.rec (\S2:Term \S2':Term \_:ConvStep* S2 S2' ->
  		 CCTypeCheck Gamma S1 S2' -> CCTypeCheck Gamma S1 S2)
    (\S2:Term \tc:CCTypeCheck Gamma S1 S2 -> tc)
    (\S2:Term \S2':Term \step:ConvStep S2 S2'
     \S2'':Term \_:ConvStep* S2' S2''
     \Hyp: (CCTypeCheck Gamma S1 S2'' -> CCTypeCheck Gamma S1 S2')
     \tc:CCTypeCheck Gamma S1 S2'' ->
     CCTypeCheck.conv (Hyp tc) (ConvSymmStep.back step))
    step
    tc
TypeCheck CCTypeCheck.convback* :
  Gamma:VarList -> S1:Term -> S2': Term -> CCTypeCheck Gamma S1 S2' ->
  S2:Term -> ConvStep* S2 S2' -> CCTypeCheck Gamma S1 S2

; Lemma: CCTypeCheck Gamma M T0 -> ConvStep M N -> CCTypeCheck Gamma N T0
Definition ConvStep.TC =
  Let Thesis = (\Gamma:VarList \M:Term \T0:Term ->
                N:Term -> ConvStep M N -> CCTypeCheck Gamma N T0) ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T0:Term \_:CCTypeCheck Gamma M T0 ->
                   Thesis Gamma M T0)
     ;ax
     (\N:Term \step:ConvStep Term.* N ->
      F.rec (\_:F -> CCTypeCheck VarList.nil N Term.[])
        (ConvStep.univ.case step))
     ; var
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp:Thesis Gamma T1 (Term.univ vt1) ->
      \N:Term \step:ConvStep (Term.var vt1 Nat.0) N ->
      F.rec (\_:F -> CCTypeCheck (VarList.cons vt1 T1 Gamma) N (Term.shiftvar T1))
        (ConvStep.var.case step))
     ; weak
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:Thesis Gamma T1 (Term.univ vt1)
      \M1:Term \S1:Term
      \prf2:CCTypeCheck Gamma M1 S1
      \Hyp2:Thesis Gamma M1 S1 ->
      ConvStep.unshiftn.rec
        (\Ns: Term -> CCTypeCheck (VarList.cons vt1 T1 Gamma) Ns (Term.shiftvar S1))
        M1 Nat.0
	(\N: Term \step: ConvStep M1 N ->
	 CCTypeCheck.weak prf1 (Hyp2 N step)))
     ; pi
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:Thesis Gamma T1 (Term.univ vt1)
      \vt2:VarType \S:Term
      \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
      \Hyp2:Thesis (VarList.cons vt1 T1 Gamma) S (Term.univ vt2) ->
      ConvStep.pi.case vt1 T1 S
         (\N:Term -> CCTypeCheck Gamma N (Term.univ vt2))
	 (\N1:Term \step: ConvStep T1 N1 ->
	  CCTypeCheck.pi (Hyp1 N1 step)
	    (ConvStep.TC.Gamma step (Hyp1 N1 step) prf2))
	 (\N2:Term \step: ConvStep S N2 ->
	  CCTypeCheck.pi prf1 (Hyp2 N2 step)))
      ; lam
     (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
      \prf1:CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
      \Hyp1:Thesis (VarList.cons vt1 T1 Gamma) M S
      \vt2:VarType
      \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
      \Hyp2:Thesis Gamma (Term.pi vt1 T1 S) (Term.univ vt2) ->
      ConvStep.lam.case vt1 T1 M
         (\N:Term -> CCTypeCheck Gamma N (Term.pi vt1 T1 S))
	 (\N1:Term \step: ConvStep T1 N1 ->
	  CCTypeCheck.conv
	    (CCTypeCheck.lam
	      (ConvStep.TC.Gamma step (CCTypeCheck.Pi.Univ (Hyp2 (Term.pi vt1 N1 S) (ConvStep.pi1 vt1 step S))) prf1)
              (Hyp2 (Term.pi vt1 N1 S) (ConvStep.pi1 vt1 step S)))
	    (ConvSymmStep.back (ConvStep.pi1 vt1 step S)))
	 (\N2:Term \step: ConvStep M N2 ->
	  CCTypeCheck.lam (Hyp1 N2 step) prf2))
     ; app
     (\Gamma:VarList \M1:Term \vt1:VarType \T1:Term \S:Term
      \prf1:CCTypeCheck Gamma M1 (Term.pi vt1 T1 S)
      \Hyp1:Thesis Gamma M1 (Term.pi vt1 T1 S)
      \M2:Term
      \prf2:CCTypeCheck Gamma M2 T1
      \Hyp2:Thesis Gamma M2 T1 ->
      ConvStep.app.case M1 M2 (\N:Term -> CCTypeCheck Gamma N (Term.subst S M2))
         (\vt:VarType \M11:Term \M12:Term
	  \_:I M1 (Term.lam vt M11 M12) ->
	  Assume CCTypeCheck Gamma (Term.subst M12 M2) (Term.subst S M2))
	 (\N1:Term \step:ConvStep M1 N1 ->
	  CCTypeCheck.app (Hyp1 N1 step) prf2)
	 (\N2:Term \step:ConvStep M2 N2 ->
	  CCTypeCheck.convback*
	    (CCTypeCheck.app prf1 (Hyp2 N2 step))
	    (ConvStep*.substn.2 step S Nat.0)))
     ; conv
     (\Gamma:VarList \M:Term \S1:Term
      \prf1:CCTypeCheck Gamma M S1
      \Hyp1:Thesis Gamma M S1
      \S2:Term
      \prf2:ConvSymmStep S1 S2
      \N:Term \step: ConvStep M N ->
      CCTypeCheck.conv (Hyp1 N step) prf2)
    
;=================================
; Strong Normalizer
;=================================

Definition NotLam = \t:Term -> Bool.ite (Term.isLam t) F T

Definition Term.eqLam.type = \t:Term ->
  (I (Term.lam (Term.vt t) (Term.arg1 t) (Term.arg2 t)) t)
Definition Term.classifyLam =
  Let Type = (\t:Term ->
      Bool.ite (Term.isLam t) (Term.eqLam.type t) (NotLam t)) ->
  Term.rec Type
	   (\vt:VarType \t1:Term \_:Type t1 \t2:Term \_:Type t2 ->
	    I.r (Term.lam vt t1 t2))
	   (\vt:VarType \t1:Term \_:Type t1 \t2:Term \_:Type t2 -> T.tt)
	   (\t1:Term \_:Type t1 \t2:Term \_:Type t2 -> T.tt)
	   (\vt:VarType \i:Nat -> T.tt)
	   (\vt:VarType -> T.tt)

; SN t -- holds if all conversion sequences are finite
Inductive SN : Term -> U =
  def   : M:Term -> (M':Term -> ConvStep M M' -> SN M') -> SN M

Definition SN.destruct =
  Let Thesis = (\t:Term \snt: SN t -> t':Term -> ConvStep t t' -> SN t') ->
  SN.rec Thesis
    (\t:Term \f:(t':Term -> ConvStep t t' -> SN t')
     \_:(t':Term -> step:ConvStep t t' -> Thesis (f step)) -> f)

; True if "t" is normalized (no conversion step posssible)
Inductive Normalized : t:Term -> U =
  def : (t':Term -> ConvStep t t' -> F) -> Normalized t

; Normalized t -> SN t
Definition Normalized.SN = \t:Term ->
  Normalized.rec (\n:Normalized t -> SN t)
   (\f:(t':Term -> ConvStep t t' -> F) ->
    SN.def (\t':Term \step:ConvStep t t' ->
            F.rec (\_:F -> SN t') (f step)))

Definition Normalized.* =
  Let Thesis = (\t:Term \t':Term \_:ConvStep t t' -> I t Term.* -> F) ->
  Normalized.def (\t':Term \step:ConvStep Term.* t' ->
    (ConvStep.rec Thesis
    (\vt:VarType \M1:Term \M2:Term \N:Term
     \eq:I (Term.app (Term.lam vt M1 M2) N) Term.* ->
     I.subst eq (\x:Term -> Bool.ite (Term.isUniv x) F T) T.tt)
    (\vt:VarType \M1:Term \M1':Term \step:ConvStep M1 M1' \_:Thesis step
     \M2:Term \eq:I (Term.lam vt M1 M2) Term.* ->
     I.subst eq (\x:Term -> Bool.ite (Term.isUniv x) F T) T.tt)
    (\vt:VarType \M2:Term \M2':Term \step:ConvStep M2 M2' \_:Thesis step
     \M1:Term \eq:I (Term.lam vt M1 M2) Term.* ->
     I.subst eq (\x:Term -> Bool.ite (Term.isUniv x) F T) T.tt)
    (\vt:VarType \M1:Term \M1':Term \step:ConvStep M1 M1' \_:Thesis step
     \M2:Term \eq:I (Term.pi vt M1 M2) Term.* ->
     I.subst eq (\x:Term -> Bool.ite (Term.isUniv x) F T) T.tt)
    (\vt:VarType \M2:Term \M2':Term \step:ConvStep M2 M2' \_:Thesis step
     \M1:Term \eq:I (Term.pi vt M1 M2) Term.* ->
     I.subst eq (\x:Term -> Bool.ite (Term.isUniv x) F T) T.tt)
    (\M1:Term \M1':Term \step:ConvStep M1 M1' \_:Thesis step
     \M2:Term \eq:I (Term.app M1 M2) Term.* ->
     I.subst eq (\x:Term -> Bool.ite (Term.isUniv x) F T) T.tt)
    (\M1:Term \M2:Term \M2':Term \step:ConvStep M2 M2' \_:Thesis step
     \eq:I (Term.app M1 M2) Term.* ->
     I.subst eq (\x:Term -> Bool.ite (Term.isUniv x) F T) T.tt)
    step (I.r Term.*)))

Definition SN.* = Normalized.SN (Normalized.*)

; SN t -> SN (Term.arg1 t)
Definition SN.arg1 =
  Let Thesis = (\t:Term -> \_:SN t -> SN (Term.arg1 t)) ->
  SN.rec Thesis
    (Let Th2 = (\t:Term -> f:(t':Term -> ConvStep t t' -> SN t') ->
		Hyp:(t':Term -> step:ConvStep t t' -> Thesis (f step)) ->
		SN (Term.arg1 t)) ->
     Term.rec Th2
       (\vt:VarType \M1:Term \_:Th2 M1 \M2:Term \_:Th2 M2 ->
        \f:(t':Term -> ConvStep (Term.lam vt M1 M2) t' -> SN t')
	\Hyp:(t':Term -> step:ConvStep (Term.lam vt M1 M2) t' -> Thesis (f step)) ->
	SN.def (\M1':Term \step:ConvStep M1 M1' ->
	        Hyp (ConvStep.lam1 vt step M2)))
       (\vt:VarType \M1:Term \_:Th2 M1 \M2:Term \_:Th2 M2 ->
        \f:(t':Term -> ConvStep (Term.pi vt M1 M2) t' -> SN t')
	\Hyp:(t':Term -> step:ConvStep (Term.pi vt M1 M2) t' -> Thesis (f step)) ->
	SN.def (\M1':Term \step:ConvStep M1 M1' ->
	        Hyp (ConvStep.pi1 vt step M2)))
       (\M1:Term \_:Th2 M1 \M2:Term \_:Th2 M2 ->
        \f:(t':Term -> ConvStep (Term.app M1 M2) t' -> SN t')
	\Hyp:(t':Term -> step:ConvStep (Term.app M1 M2) t' -> Thesis (f step)) ->
	SN.def (\M1':Term \step:ConvStep M1 M1' ->
	        Hyp (ConvStep.app1 step M2)))
       (\vt:VarType \i:Nat
        \f:(t':Term -> ConvStep (Term.var vt i) t' -> SN t')
	\_:(t':Term -> step:ConvStep (Term.var vt i) t' -> Thesis (f step)) ->
	SN.*)
       (\vt:VarType
        \f:(t':Term -> ConvStep (Term.univ vt) t' -> SN t')
	\_:(t':Term -> step:ConvStep (Term.univ vt) t' -> Thesis (f step)) ->
	SN.*))

; SN t -> SN (Term.arg2 t)
Definition SN.arg2 =
  Let Thesis = (\t:Term -> \snt:SN t -> SN (Term.arg2 t)) ->
  SN.rec Thesis
    (Let Th2 = (\t:Term -> f:(t':Term -> ConvStep t t' -> SN t') ->
		Hyp:(t':Term -> step:ConvStep t t' -> Thesis (f step)) ->
		SN (Term.arg2 t)) ->
     Term.rec Th2
       (\vt:VarType \M1:Term \_:Th2 M1 \M2:Term \_:Th2 M2 ->
        \f:(t':Term -> ConvStep (Term.lam vt M1 M2) t' -> SN t')
	\Hyp:(t':Term -> step:ConvStep (Term.lam vt M1 M2) t' -> Thesis (f step)) ->
	SN.def (\M2':Term \step:ConvStep M2 M2' ->
	        Hyp (ConvStep.lam2 vt step M1)))
       (\vt:VarType \M1:Term \_:Th2 M1 \M2:Term \_:Th2 M2 ->
        \f:(t':Term -> ConvStep (Term.pi vt M1 M2) t' -> SN t')
	\Hyp:(t':Term -> step:ConvStep (Term.pi vt M1 M2) t' -> Thesis (f step)) ->
	SN.def (\M2':Term \step:ConvStep M2 M2' ->
	        Hyp (ConvStep.pi2 vt step M1)))
       (\M1:Term \_:Th2 M1 \M2:Term \_:Th2 M2 ->
        \f:(t':Term -> ConvStep (Term.app M1 M2) t' -> SN t')
	\Hyp:(t':Term -> step:ConvStep (Term.app M1 M2) t' -> Thesis (f step)) ->
	SN.def (\M2':Term \step:ConvStep M2 M2' ->
	        Hyp (ConvStep.app2 M1 step)))
       (\vt:VarType \i:Nat
        \f:(t':Term -> ConvStep (Term.var vt i) t' -> SN t')
	\_:(t':Term -> step:ConvStep (Term.var vt i) t' -> Thesis (f step)) ->
	SN.*)
       (\vt:VarType
        \f:(t':Term -> ConvStep (Term.univ vt) t' -> SN t')
	\_:(t':Term -> step:ConvStep (Term.univ vt) t' -> Thesis (f step)) ->
	SN.*))

Definition SN.arg3.type = \t:Term ->
  Bool.ite (Term.isApp t)
     (Bool.ite (Term.isLam (Term.arg1 t))
	 (SN (Term.subst (Term.arg2 (Term.arg1 t)) (Term.arg2 t))) T) T

; SN (app (lam t1 t2) t3) -> SN (subst t2 t3)
Definition SN.arg3 =
  Let Thesis = (\t:Term -> SN t -> SN.arg3.type t) ->
  Term.rec Thesis
    (\vt:VarType \M1:Term \_:Thesis M1 \M2:Term \_:Thesis M2
     \_:SN (Term.lam vt M1 M2) -> T.tt)
    (\vt:VarType \M1:Term \_:Thesis M1 \M2:Term \_:Thesis M2
     \_:SN (Term.pi vt M1 M2) -> T.tt)
    (\M1:Term \_:Thesis M1 \M2:Term \_:Thesis M2
     \sn:SN (Term.app M1 M2) ->
     Bool.rec (\x:Bool -> Bool.ite x (Term.eqLam.type M1) (NotLam M1) ->
     	       Bool.ite x (SN (Term.subst (Term.arg2 M1) M2)) T)
       (\eq:Term.eqLam.type M1 ->
        SN.destruct (I.rsubst eq (\x:Term -> SN (Term.app x M2)) sn)
	   (ConvStep.beta (Term.vt M1) (Term.arg1 M1) (Term.arg2 M1) M2))
       (\nl:NotLam M1 -> T.tt)
       (Term.isLam M1)
       (Term.classifyLam M1))
    (\vt:VarType \i:Nat
     \_:SN (Term.var vt i) -> T.tt)
    (\vt:VarType 
     \_:SN (Term.univ vt) -> T.tt)

Definition Normalized.aux =
  Let Thesis = (\t:Term \t':Term \_:ConvStep t t' ->
  	        Normalized (Term.arg1 t) ->
		Normalized (Term.arg2 t) ->
		Bool.ite (Term.isApp t)
                  (Bool.ite (Term.isLam (Term.arg1 t)) F T) T -> F) ->
  ConvStep.rec Thesis
    (\vt:VarType \M1:Term \M2:Term \N:Term ->
     \_:Normalized (Term.lam vt M1 M2) \_:Normalized N \f:F -> f)
    (\vt:VarType \M1:Term \M1':Term \step:ConvStep M1 M1' \_:Thesis step
     \M2:Term \n1:Normalized M1 \_:Normalized M2 \_:T ->
     Normalized.rec (\_:Normalized M1 -> F)
       (\f:(t':Term -> ConvStep M1 t' -> F) -> f step) n1)
    (\vt:VarType \M2:Term \M2':Term \step:ConvStep M2 M2' \_:Thesis step
     \M1:Term \_:Normalized M1 \n2:Normalized M2 \_:T ->
     Normalized.rec (\_:Normalized M2 -> F)
       (\f:(t':Term -> ConvStep M2 t' -> F) -> f step) n2)
    (\vt:VarType \M1:Term \M1':Term \step:ConvStep M1 M1' \_:Thesis step
     \M2:Term \n1:Normalized M1 \_:Normalized M2 \_:T ->
     Normalized.rec (\_:Normalized M1 -> F)
       (\f:(t':Term -> ConvStep M1 t' -> F) -> f step) n1)
    (\vt:VarType \M2:Term \M2':Term \step:ConvStep M2 M2' \_:Thesis step
     \M1:Term \_:Normalized M1 \n2:Normalized M2 \_:T ->
     Normalized.rec (\_:Normalized M2 -> F)
       (\f:(t':Term -> ConvStep M2 t' -> F) -> f step) n2)
    (\M1:Term \M1':Term \step:ConvStep M1 M1' \_:Thesis step \M2:Term
     \n1:Normalized M1 \_:Normalized M2 \_:Bool.ite (Term.isLam M1) F T ->
     Normalized.rec (\_:Normalized M1 -> F)
       (\f:(t':Term -> ConvStep M1 t' -> F) -> f step) n1)
    (\M1:Term \M2:Term \M2':Term \step:ConvStep M2 M2' \_:Thesis step
     \_:Normalized M1 \n2:Normalized M2 \_:Bool.ite (Term.isLam M1) F T ->
     Normalized.rec (\_:Normalized M2 -> F)
       (\f:(t':Term -> ConvStep M2 t' -> F) -> f step) n2)

Definition Normalized.mk =
  \t:Term \n1:Normalized (Term.arg1 t) \n2:Normalized (Term.arg2 t)
  \n3:Bool.ite (Term.isApp t)
  	       (Bool.ite (Term.isLam (Term.arg1 t)) F T) T ->
  Normalized.def (\t':Term \step: ConvStep t t' ->
                  Normalized.aux step n1 n2 n3)

Definition SN.step =
  Let Thesis = (\t:Term -> + (Normalized t) (Sigma (ConvStep t))) ->
  Let Norm = (\t:Term \n:Normalized t ->
      +.1 (Normalized t) (Sigma (ConvStep t)) n) 
  Let Step = (\t:Term \t':Term \step:ConvStep t t' ->
      +.2 (Normalized t) (Sigma (ConvStep t)) (Sigma.mk (ConvStep t) step)) ->
  Term.rec Thesis 
    (\vt:VarType \t1:Term \Hyp1:Thesis t1 \t2:Term \Hyp2:Thesis t2 ->
     +.rec (\_: + (Normalized t1) (Sigma (ConvStep t1)) ->
            Thesis (Term.lam vt t1 t2))
       (\n1:Normalized t1 ->
        +.rec (\_: + (Normalized t2) (Sigma (ConvStep t2)) ->
               Thesis (Term.lam vt t1 t2))
	   (\n2:Normalized t2 ->
	    Norm (Normalized.mk (Term.lam vt t1 t2) n1 n2 T.tt))
	   (\step:Sigma (ConvStep t2) ->
	    Step (ConvStep.lam2 vt (Sigma.2 step) t1))
	   Hyp2)
       (\step:Sigma (ConvStep t1) ->
	Step (ConvStep.lam1 vt (Sigma.2 step) t2))
       Hyp1)
    (\vt:VarType \t1:Term \Hyp1:Thesis t1 \t2:Term \Hyp2:Thesis t2 ->
     +.rec (\_: + (Normalized t1) (Sigma (ConvStep t1)) ->
            Thesis (Term.pi vt t1 t2))
       (\n1:Normalized t1 ->
        +.rec (\_: + (Normalized t2) (Sigma (ConvStep t2)) ->
               Thesis (Term.pi vt t1 t2))
	   (\n2:Normalized t2 ->
	    Norm (Normalized.mk (Term.pi vt t1 t2) n1 n2 T.tt))
	   (\step:Sigma (ConvStep t2) ->
	    Step (ConvStep.pi2 vt (Sigma.2 step) t1))
	   Hyp2)
       (\step:Sigma (ConvStep t1) ->
	Step (ConvStep.pi1 vt (Sigma.2 step) t2))
       Hyp1)
    (\t1:Term \Hyp1:Thesis t1 \t2:Term \Hyp2:Thesis t2 ->
     +.rec (\_: + (Normalized t1) (Sigma (ConvStep t1)) ->
            Thesis (Term.app t1 t2))
       (\n1:Normalized t1 ->
        +.rec (\_: + (Normalized t2) (Sigma (ConvStep t2)) ->
               Thesis (Term.app t1 t2))
	   (\n2:Normalized t2 ->
	    Bool.rec (\x:Bool -> Bool.ite x (Term.eqLam.type t1) (NotLam t1) ->
	     	      Thesis (Term.app t1 t2))
	      (\eq:Term.eqLam.type t1 ->
	       I.subst eq (\x:Term -> Thesis (Term.app x t2))
	         (Step (ConvStep.beta (Term.vt t1)
				      (Term.arg1 t1) (Term.arg2 t1) t2)))
	      (\nl:NotLam t1 ->
	       Norm (Normalized.mk (Term.app t1 t2) n1 n2 nl))
	      (Term.isLam t1)
	      (Term.classifyLam t1))
	   (\step:Sigma (ConvStep t2) ->
	    Step (ConvStep.app2 t1 (Sigma.2 step)))
	   Hyp2)
       (\step:Sigma (ConvStep t1) ->
	Step (ConvStep.app1 (Sigma.2 step) t2))
       Hyp1)
    (\vt:VarType \i:Nat ->
     Norm (Normalized.mk (Term.var vt i) Normalized.* Normalized.* T.tt))
    (\vt:VarType ->
     Norm (Normalized.mk (Term.univ vt) Normalized.* Normalized.* T.tt))

TypeCheck SN.step : (t:Term -> + (Normalized t) (Sigma (ConvStep t)))

Definition SN.normalize.step =
  \t:Term \Hyp:(t':Term -> ConvStep t t' -> Sigma Normalized) ->
  +.rec (\_: + (Normalized t) (Sigma (ConvStep t)) -> Sigma Normalized)
        (\n:Normalized t -> Sigma.mk Normalized n)
	(\step:Sigma (ConvStep t) -> Hyp (Sigma.2 step))

Definition SN.normalize.aux =
  SN.rec (\t:Term \snt:SN t -> Sigma Normalized)
    (\t:Term \f:(t':Term -> ConvStep t t' -> SN t')
     \Hyp:(t':Term -> step:ConvStep t t' -> Sigma Normalized) ->
     SN.normalize.step t Hyp (SN.step t))
Definition SN.normalize = \t:Term \snt:SN t -> Sigma.1 (SN.normalize.aux snt)
TypeCheck SN.normalize : t:Term -> SN t -> Term

Definition SN.normalize.isNormalized = \t:Term \snt:SN t ->
   Sigma.2 (SN.normalize.aux snt)
TypeCheck SN.normalize.isNormalized :
   t:Term -> sn:SN t -> Normalized (SN.normalize sn)

Definition SN.steps =
  Let Thesis = (\t:Term \snt:SN t -> ConvStep* t (SN.normalize snt)) ->
  SN.rec Thesis
    (\t:Term \f:(t':Term -> ConvStep t t' -> SN t')
     \Hyp:(t':Term -> step:ConvStep t t' -> Thesis (f step)) ->
     Let step.aux = SN.normalize.step t
     	 (\t':Term \step:ConvStep t t' -> SN.normalize.aux (f t' step)) ->
     Let Th2 = (\stept:+ (Normalized t) (Sigma (ConvStep t))  ->
       ConvStep* t (Sigma.1 (step.aux stept))) ->
     +.rec Th2
        (\n:Normalized t -> ConvStep*.id t)
	(\step:Sigma (ConvStep t) ->
	  ConvStep*.cons (Sigma.2 step) (Hyp (Sigma.2 step)))
	(SN.step t))
TypeCheck SN.steps : t : Term -> sn:SN t -> ConvStep* t (SN.normalize sn)

Definition ConvStep.confluent.beta.lam1 =
  \vt:VarType \t:Term \m:Term \n:Term \m':Term
  \step:ConvStep (Term.lam vt t m) m' ->
  Let Goal = (\m': Term ->
      \t'':Term -> * (ConvStep* (Term.subst m n) t'')
		     (ConvStep* (Term.app m' n) t'')) ->
  Let Thesis = (\lamtm:Term \m':Term \_:ConvStep lamtm m' ->
    I (Term.lam vt t m) lamtm -> Sigma (Goal m')) ->
  ConvStep.rec Thesis
    (\vt1:VarType \t1:Term \m1:Term \n1:Term
     \eq:I (Term.lam vt t m) (Term.app (Term.lam vt1 t1 m1) n1) ->
     F.rec (\_:F -> Sigma (Goal (Term.subst m1 n1)))
       (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    (\vt1:VarType \t1:Term \t1':Term \st:ConvStep t1 t1' \_:Thesis st \m1:Term
     \eq:I (Term.lam vt t m) (Term.lam vt1 t1 m1) ->
     Sigma.mk (Goal (Term.lam vt1 t1' m1))
       (Term.subst m n)
       (*.mk (ConvStep*.id (Term.subst m n))
       	     (I.rsubst eq
       	  (\x:Term -> ConvStep* (Term.app (Term.lam vt1 t1' m1) n)
	  	                (Term.subst (Term.arg2 x) n))
	  (ConvStep*.cons (ConvStep.beta vt1 t1' m1 n)
			  (ConvStep*.id (Term.subst m1 n))))))
    (\vt1:VarType \m1:Term \m1':Term \st:ConvStep m1 m1' \_:Thesis st \t1:Term
     \eq:I (Term.lam vt t m) (Term.lam vt1 t1 m1) ->
     Sigma.mk (Goal (Term.lam vt1 t1 m1'))
       (I.rsubst eq 
       	 (\x:Term -> * (ConvStep* (Term.subst (Term.arg2 x) n) (Term.subst m1' n))
	 	       (ConvStep* (Term.app (Term.lam vt1 t1 m1') n)
		       		  (Term.subst m1' n)))
        (*.mk (ConvStep*.cons (ConvStep.substn st Nat.0 n)
			      (ConvStep*.id (Term.subst m1' n)))
	      (ConvStep*.cons (ConvStep.beta vt1 t1 m1' n)
			      (ConvStep*.id (Term.subst m1' n))))))
    (\vt1:VarType \t1:Term \t1':Term \st:ConvStep t1 t1' \_:Thesis st \m1:Term
     \eq:I (Term.lam vt t m) (Term.pi vt1 t1 m1) ->
     F.rec (\_:F -> Sigma (Goal (Term.pi vt1 t1' m1)))
       (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    (\vt1:VarType \m1:Term \m1':Term \st:ConvStep m1 m1' \_:Thesis st \t1:Term
     \eq:I (Term.lam vt t m) (Term.pi vt1 t1 m1) ->
     F.rec (\_:F -> Sigma (Goal (Term.pi vt1 t1 m1')))
       (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    (\t1:Term \t1':Term \st:ConvStep t1 t1' \_:Thesis st \m1:Term
     \eq:I (Term.lam vt t m) (Term.app t1 m1) ->
     F.rec (\_:F -> Sigma (Goal (Term.app t1' m1)))
       (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    (\t1:Term \m1:Term \m1':Term \st:ConvStep m1 m1' \_:Thesis st
     \eq:I (Term.lam vt t m) (Term.app t1 m1) ->
     F.rec (\_:F -> Sigma (Goal (Term.app t1 m1')))
       (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
    step (I.r (Term.lam vt t m))
       
Definition ConvStep.confluent.beta.lam2 =
  Let Confluence = (\t1:Term \t2:Term \t':Term ->
                    * (ConvStep* t1 t') (ConvStep* t2 t')) ->
  \vt:VarType \t:Term \m:Term \n:Term \n':Term
  \step:ConvStep n n' ->
  Sigma.mk (Confluence (Term.subst m n) (Term.app (Term.lam vt t m) n'))
    (*.mk (ConvStep*.substn.2 step m Nat.0)
    	  (ConvStep*.cons (ConvStep.beta vt t m n')
	  		  (ConvStep*.id (Term.subst m n'))))

Definition SN.confluent =
  Let Confluence = (\t1:Term \t2:Term \t':Term ->
                    * (ConvStep* t1 t') (ConvStep* t2 t')) ->
  Let Thesis = (\t1:Term \t2:Term -> Sigma (Confluence t1 t2))
  Let Th1 = (\t:Term \t1:Term \_:ConvStep t t1 ->
             t2:Term -> ConvStep t t2 -> Thesis t1 t2) ->
  ConvStep.rec Th1
    (\vt1:VarType \t1:Term \m1:Term \n1:Term ->
     \t2:Term \step2:ConvStep (Term.app (Term.lam vt1 t1 m1) n1) t2 ->
     Let Th2 = (\t:Term \t2:Term \_:ConvStep t t2 ->
                   I (Term.app (Term.lam vt1 t1 m1) n1) t ->
		   Thesis (Term.subst m1 n1) t2) ->
     ConvStep.rec Th2
       (\vt2:VarType \t2:Term \m2:Term \n2:Term
        \eq:I (Term.app (Term.lam vt1 t1 m1) n1)
	      (Term.app (Term.lam vt2 t2 m2) n2) ->
	Sigma.mk (Confluence (Term.subst m1 n1) (Term.subst m2 n2))
	(*.mk (ConvStep*.id (Term.subst m1 n1))
	     (I.subst eq (\x:Term ->
	       ConvStep* (Term.subst (Term.arg2 (Term.arg1 x)) (Term.arg2 x))
	   	         (Term.subst m1 n1))
	       (ConvStep*.id (Term.subst m1 n1)))))
       (\vt2:VarType \t2:Term \t2':Term \step:ConvStep t2 t2' \_:Th2 step
        \m2:Term
        \eq:I (Term.app (Term.lam vt1 t1 m1) n1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.subst m1 n1) (Term.lam vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step:ConvStep m2 m2' \_:Th2 step
        \t2:Term
        \eq:I (Term.app (Term.lam vt1 t1 m1) n1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.subst m1 n1) (Term.lam vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step:ConvStep t2 t2' \_:Th2 step
        \m2:Term
        \eq:I (Term.app (Term.lam vt1 t1 m1) n1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.subst m1 n1) (Term.pi vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step:ConvStep m2 m2' \_:Th2 step
        \t2:Term
        \eq:I (Term.app (Term.lam vt1 t1 m1) n1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.subst m1 n1) (Term.pi vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\m2:Term \m2':Term \step:ConvStep m2 m2' \_:Th2 step \n2:Term
        \eq:I (Term.app (Term.lam vt1 t1 m1) n1) (Term.app m2 n2) ->
	(I.subst eq
	  (\x:Term ->
	   ConvStep (Term.arg1 x) m2' ->
	   Thesis (Term.subst m1 n1) (Term.app m2' (Term.arg2 x)))
	  (ConvStep.confluent.beta.lam1 vt1 t1 m1 n1 m2')
	  step))
       (\m2:Term \n2:Term \n2':Term \step:ConvStep n2 n2' \_:Th2 step
        \eq:I (Term.app (Term.lam vt1 t1 m1) n1) (Term.app m2 n2) ->
	(I.subst eq
	  (\x:Term ->
	   ConvStep (Term.arg2 x) n2' ->
	   Thesis (Term.subst m1 n1) (Term.app (Term.arg1 x) n2'))
	  (ConvStep.confluent.beta.lam2 vt1 t1 m1 n1 n2')
	  step))
       (Term.app (Term.lam vt1 t1 m1) n1) t2 step2
       (I.r (Term.app (Term.lam vt1 t1 m1) n1)))
    (\vt1:VarType \t1:Term \t1':Term \step1: ConvStep t1 t1' \Hyp:Th1 step1
     \m1:Term
     \t2:Term \step2:ConvStep (Term.lam vt1 t1 m1) t2 ->
     Let Th2 = (\t:Term \t2:Term \_:ConvStep t t2 ->
                   I (Term.lam vt1 t1 m1) t ->
		   Thesis (Term.lam vt1 t1' m1) t2) ->
     ConvStep.rec Th2
       (\vt2:VarType \t2:Term \m2:Term \n2:Term
        \eq:I (Term.lam vt1 t1 m1)
	      (Term.app (Term.lam vt2 t2 m2) n2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1' m1) (Term.subst m2 n2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	Let Hyp1 = Hyp (I.rsubst eq (\x:Term -> ConvStep (Term.arg1 x) t2')
	               		 step2) ->
	I.subst eq (\x:Term ->
	  Sigma (Confluence (Term.lam vt1 t1' m1)
	  		    (Term.lam (Term.vt x) t2' (Term.arg2 x))))
	(Sigma.mk (Confluence (Term.lam vt1 t1' m1) (Term.lam vt1 t2' m1))
	  (Term.lam vt1 (Sigma.1 Hyp1) m1)
	  (*.mk (ConvStep*.lam1 vt1 (*.1 (Sigma.2 Hyp1)) m1)
	  	(ConvStep*.lam1 vt1 (*.2 (Sigma.2 Hyp1)) m1))))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	Sigma.mk (Confluence (Term.lam vt1 t1' m1) (Term.lam vt2 t2 m2'))
	  (Term.lam vt1 t1' m2')
	  (*.mk (ConvStep*.cons (I.rsubst eq
                       (\x:Term -> ConvStep (Term.lam vt1 t1' (Term.arg2 x))
					    (Term.lam vt1 t1' m2'))
		       (ConvStep.lam2 vt1 step2 t1'))
		    (ConvStep*.id (Term.lam vt1 t1' m2')))
		(ConvStep*.cons (I.subst eq
                       (\x:Term -> ConvStep (Term.lam (Term.vt x) (Term.arg1 x)
		       		   	    	      m2')
					    (Term.lam vt1 t1' m2'))
		       (ConvStep.lam1 vt1 step1 m2'))
		    (ConvStep*.id (Term.lam vt1 t1' m2')))))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1' m1) (Term.pi vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1' m1) (Term.pi vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1' m1) (Term.app t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\t2:Term \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \eq:I (Term.lam vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1' m1) (Term.app t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       step2
       (I.r (Term.lam vt1 t1 m1)))
    (\vt1:VarType \m1:Term \m1':Term \step1: ConvStep m1 m1' \Hyp:Th1 step1
     \t1:Term
     \t2:Term \step2:ConvStep (Term.lam vt1 t1 m1) t2 ->
     Let Th2 = (\t:Term \t2:Term \_:ConvStep t t2 ->
                   I (Term.lam vt1 t1 m1) t ->
		   Thesis (Term.lam vt1 t1 m1') t2) ->
     ConvStep.rec Th2
       (\vt2:VarType \t2:Term \m2:Term \n2:Term
        \eq:I (Term.lam vt1 t1 m1)
	      (Term.app (Term.lam vt2 t2 m2) n2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1 m1') (Term.subst m2 n2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	Sigma.mk (Confluence (Term.lam vt1 t1 m1') (Term.lam vt2 t2' m2))
	  (Term.lam vt1 t2' m1')
	  (*.mk (ConvStep*.cons (I.rsubst eq
                       (\x:Term -> ConvStep (Term.lam vt1 (Term.arg1 x) m1')
					    (Term.lam vt1 t2' m1'))
		       (ConvStep.lam1 vt1 step2 m1'))
		    (ConvStep*.id (Term.lam vt1 t2' m1')))
		(ConvStep*.cons (I.subst eq
                       (\x:Term -> ConvStep (Term.lam (Term.vt x) t2' (Term.arg2 x))
					    (Term.lam vt1 t2' m1'))
		       (ConvStep.lam2 vt1 step1 t2'))
		    (ConvStep*.id (Term.lam vt1 t2' m1')))))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	Let Hyp1 = Hyp (I.rsubst eq (\x:Term -> ConvStep (Term.arg2 x) m2')
	               		 step2) ->
	I.subst eq (\x:Term ->
	  Sigma (Confluence (Term.lam vt1 t1 m1')
	  		    (Term.lam (Term.vt x) (Term.arg1 x) m2')))
	(Sigma.mk (Confluence (Term.lam vt1 t1 m1') (Term.lam vt1 t1 m2'))
	  (Term.lam vt1 t1 (Sigma.1 Hyp1))
	  (*.mk (ConvStep*.lam2 vt1 t1 (*.1 (Sigma.2 Hyp1)))
	  	(ConvStep*.lam2 vt1 t1 (*.2 (Sigma.2 Hyp1))))))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1 m1') (Term.pi vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1 m1') (Term.pi vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.lam vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1 m1') (Term.app t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       (\t2:Term \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \eq:I (Term.lam vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.lam vt1 t1 m1') (Term.app t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isLam x) T F) T.tt))
       step2
       (I.r (Term.lam vt1 t1 m1)))
    (\vt1:VarType \t1:Term \t1':Term \step1: ConvStep t1 t1' \Hyp:Th1 step1
     \m1:Term
     \t2:Term \step2:ConvStep (Term.pi vt1 t1 m1) t2 ->
     Let Th2 = (\t:Term \t2:Term \_:ConvStep t t2 ->
                   I (Term.pi vt1 t1 m1) t ->
		   Thesis (Term.pi vt1 t1' m1) t2) ->
     ConvStep.rec Th2
       (\vt2:VarType \t2:Term \m2:Term \n2:Term
        \eq:I (Term.pi vt1 t1 m1)
	      (Term.app (Term.lam vt2 t2 m2) n2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1' m1) (Term.subst m2 n2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1' m1) (Term.lam vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1' m1) (Term.lam vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	Let Hyp1 = Hyp (I.rsubst eq (\x:Term -> ConvStep (Term.arg1 x) t2')
	               		 step2) ->
	I.subst eq (\x:Term ->
	  Sigma (Confluence (Term.pi vt1 t1' m1)
	  		    (Term.pi (Term.vt x) t2' (Term.arg2 x))))
	(Sigma.mk (Confluence (Term.pi vt1 t1' m1) (Term.pi vt1 t2' m1))
	  (Term.pi vt1 (Sigma.1 Hyp1) m1)
	  (*.mk (ConvStep*.pi1 vt1 (*.1 (Sigma.2 Hyp1)) m1)
	  	(ConvStep*.pi1 vt1 (*.2 (Sigma.2 Hyp1)) m1))))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	Sigma.mk (Confluence (Term.pi vt1 t1' m1) (Term.pi vt2 t2 m2'))
	  (Term.pi vt1 t1' m2')
	  (*.mk (ConvStep*.cons (I.rsubst eq
                       (\x:Term -> ConvStep (Term.pi vt1 t1' (Term.arg2 x))
					    (Term.pi vt1 t1' m2'))
		       (ConvStep.pi2 vt1 step2 t1'))
		    (ConvStep*.id (Term.pi vt1 t1' m2')))
		(ConvStep*.cons (I.subst eq
                       (\x:Term -> ConvStep (Term.pi (Term.vt x) (Term.arg1 x)
		       		   	    	      m2')
					    (Term.pi vt1 t1' m2'))
		       (ConvStep.pi1 vt1 step1 m2'))
		    (ConvStep*.id (Term.pi vt1 t1' m2')))))
       (\t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1' m1) (Term.app t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\t2:Term \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \eq:I (Term.pi vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1' m1) (Term.app t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       step2
       (I.r (Term.pi vt1 t1 m1)))
    (\vt1:VarType \m1:Term \m1':Term \step1: ConvStep m1 m1' \Hyp:Th1 step1
     \t1:Term
     \t2:Term \step2:ConvStep (Term.pi vt1 t1 m1) t2 ->
     Let Th2 = (\t:Term \t2:Term \_:ConvStep t t2 ->
                   I (Term.pi vt1 t1 m1) t ->
		   Thesis (Term.pi vt1 t1 m1') t2) ->
     ConvStep.rec Th2
       (\vt2:VarType \t2:Term \m2:Term \n2:Term
        \eq:I (Term.pi vt1 t1 m1)
	      (Term.app (Term.lam vt2 t2 m2) n2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1 m1') (Term.subst m2 n2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1 m1') (Term.lam vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1 m1') (Term.lam vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	Sigma.mk (Confluence (Term.pi vt1 t1 m1') (Term.pi vt2 t2' m2))
	  (Term.pi vt1 t2' m1')
	  (*.mk (ConvStep*.cons (I.rsubst eq
                       (\x:Term -> ConvStep (Term.pi vt1 (Term.arg1 x) m1')
					    (Term.pi vt1 t2' m1'))
		       (ConvStep.pi1 vt1 step2 m1'))
		    (ConvStep*.id (Term.pi vt1 t2' m1')))
		(ConvStep*.cons (I.subst eq
                       (\x:Term -> ConvStep (Term.pi (Term.vt x) t2' (Term.arg2 x))
					    (Term.pi vt1 t2' m1'))
		       (ConvStep.pi2 vt1 step1 t2'))
		    (ConvStep*.id (Term.pi vt1 t2' m1')))))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.pi vt2 t2 m2) ->
	Let Hyp1 = Hyp (I.rsubst eq (\x:Term -> ConvStep (Term.arg2 x) m2')
	               		 step2) ->
	I.subst eq (\x:Term ->
	  Sigma (Confluence (Term.pi vt1 t1 m1')
	  		    (Term.pi (Term.vt x) (Term.arg1 x) m2')))
	(Sigma.mk (Confluence (Term.pi vt1 t1 m1') (Term.pi vt1 t1 m2'))
	  (Term.pi vt1 t1 (Sigma.1 Hyp1))
	  (*.mk (ConvStep*.pi2 vt1 t1 (*.1 (Sigma.2 Hyp1)))
	  	(ConvStep*.pi2 vt1 t1 (*.2 (Sigma.2 Hyp1))))))
       (\t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.pi vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1 m1') (Term.app t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       (\t2:Term \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \eq:I (Term.pi vt1 t1 m1) (Term.app t2 m2) ->
	F.rec (\_:F -> Thesis (Term.pi vt1 t1 m1') (Term.app t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isPi x) T F) T.tt))
       step2
       (I.r (Term.pi vt1 t1 m1)))
    (\m1:Term \m1':Term \step1: ConvStep m1 m1' \Hyp:Th1 step1
     \n1:Term
     \t2:Term \step2:ConvStep (Term.app m1 n1) t2 ->
     Let Th2 = (\t:Term \t2:Term \_:ConvStep t t2 ->
                   I (Term.app m1 n1) t ->
		   Thesis (Term.app m1' n1) t2) ->
     ConvStep.rec Th2
       (\vt2:VarType \t2:Term \m2:Term \n2:Term
        \eq:I (Term.app m1 n1)
	      (Term.app (Term.lam vt2 t2 m2) n2) ->
	Let confluence = Sigma.2 (I.rsubst eq
	  (\x:Term ->
	   ConvStep (Term.arg1 x) m1' ->
	   Thesis (Term.subst m2 n2) (Term.app m1' (Term.arg2 x)))
	  (ConvStep.confluent.beta.lam1 vt2 t2 m2 n2 m1')
	  step1) ->
	Sigma.mk (Confluence (Term.app m1' n1) (Term.subst m2 n2))
	  (*.mk (*.2 confluence) (*.1 confluence)))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.app m1 n1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1' n1) (Term.lam vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.app m1 n1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1' n1) (Term.lam vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.app m1 n1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1' n1) (Term.pi vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.app m1 n1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1' n1) (Term.pi vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \n2:Term
        \eq:I (Term.app m1 n1) (Term.app m2 n2) ->
	Let Hyp1 = Hyp (I.rsubst eq (\x:Term -> ConvStep (Term.arg1 x) m2')
	               		 step2) ->
	I.subst eq (\x:Term ->
	  Sigma (Confluence (Term.app m1' n1)
	  		    (Term.app m2' (Term.arg2 x))))
	(Sigma.mk (Confluence (Term.app m1' n1) (Term.app m2' n1))
	  (Term.app (Sigma.1 Hyp1) n1)
	  (*.mk (ConvStep*.app1 (*.1 (Sigma.2 Hyp1)) n1)
	  	(ConvStep*.app1 (*.2 (Sigma.2 Hyp1)) n1))))
       (\m2:Term \n2:Term \n2':Term \step2:ConvStep n2 n2' \_:Th2 step2
        \eq:I (Term.app m1 n1) (Term.app m2 n2) ->
	Sigma.mk (Confluence (Term.app m1' n1) (Term.app m2 n2'))
	  (*.mk (ConvStep*.cons (I.rsubst eq
                       (\x:Term -> ConvStep (Term.app m1' (Term.arg2 x))
					    (Term.app m1' n2'))
		       (ConvStep.app2 m1' step2))
		    (ConvStep*.id (Term.app m1' n2')))
		(ConvStep*.cons (I.subst eq
                       (\x:Term -> ConvStep (Term.app (Term.arg1 x) n2')
					    (Term.app m1' n2'))
		       (ConvStep.app1 step1 n2'))
		    (ConvStep*.id (Term.app m1' n2')))))
       step2
       (I.r (Term.app m1 n1)))
    (\m1:Term \n1:Term \n1':Term \step1: ConvStep n1 n1' \Hyp:Th1 step1
     \t2:Term \step2:ConvStep (Term.app m1 n1) t2 ->
     Let Th2 = (\t:Term \t2:Term \_:ConvStep t t2 ->
                   I (Term.app m1 n1) t ->
		   Thesis (Term.app m1 n1') t2) ->
     ConvStep.rec Th2
       (\vt2:VarType \t2:Term \m2:Term \n2:Term
        \eq:I (Term.app m1 n1)
	      (Term.app (Term.lam vt2 t2 m2) n2) ->
	Let confluence = Sigma.2 (I.rsubst eq
	  (\x:Term ->
	   ConvStep (Term.arg2 x) n1' ->
	   Thesis (Term.subst m2 n2) (Term.app (Term.arg1 x) n1'))
	  (ConvStep.confluent.beta.lam2 vt2 t2 m2 n2 n1')
	  step1) ->
	Sigma.mk (Confluence (Term.app m1 n1') (Term.subst m2 n2))
	  (*.mk (*.2 confluence) (*.1 confluence)))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.app m1 n1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1 n1') (Term.lam vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.app m1 n1) (Term.lam vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1 n1') (Term.lam vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \t2:Term \t2':Term \step2:ConvStep t2 t2' \_:Th2 step2
        \m2:Term
        \eq:I (Term.app m1 n1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1 n1') (Term.pi vt2 t2' m2))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\vt2:VarType \m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2
        \t2:Term
        \eq:I (Term.app m1 n1) (Term.pi vt2 t2 m2) ->
	F.rec (\_:F -> Thesis (Term.app m1 n1') (Term.pi vt2 t2 m2'))
	  (I.subst eq (\x:Term -> Bool.ite (Term.isApp x) T F) T.tt))
       (\m2:Term \m2':Term \step2:ConvStep m2 m2' \_:Th2 step2 \n2:Term 
        \eq:I (Term.app m1 n1) (Term.app m2 n2) ->
	Sigma.mk (Confluence (Term.app m1 n1') (Term.app m2' n2))
	  (*.mk (ConvStep*.cons (I.rsubst eq
                       (\x:Term -> ConvStep (Term.app (Term.arg1 x) n1')
					    (Term.app m2' n1'))
		       (ConvStep.app1 step2 n1'))
		    (ConvStep*.id (Term.app m2' n1')))
		(ConvStep*.cons (I.subst eq
                       (\x:Term -> ConvStep (Term.app m2' (Term.arg2 x))
					    (Term.app m2' n1'))
		       (ConvStep.app2 m2' step1))
		    (ConvStep*.id (Term.app m2' n1')))))
       (\m2:Term \n2:Term \n2':Term \step2:ConvStep n2 n2' \_:Th2 step2
        \eq:I (Term.app m1 n1) (Term.app m2 n2) ->
	Let Hyp1 = Hyp (I.rsubst eq (\x:Term -> ConvStep (Term.arg2 x) n2')
				 step2) ->
	I.subst eq (\x:Term ->
	  Sigma (Confluence (Term.app m1 n1')
	  		    (Term.app (Term.arg1 x) n2')))
	(Sigma.mk (Confluence (Term.app m1 n1') (Term.app m1 n2'))
	  (*.mk (ConvStep*.app2 m1 (*.1 (Sigma.2 Hyp1)))
	  	(ConvStep*.app2 m1 (*.2 (Sigma.2 Hyp1))))))
       step2
       (I.r (Term.app m1 n1)))

TypeCheck SN.confluent : t: Term -> t1:Term -> ConvStep t t1 ->
        t2:Term -> ConvStep t t2 ->
 	Sigma (\t':Term -> * (ConvStep* t1 t') (ConvStep* t2 t'))

Definition Normalize.SN = \t:Term \sn: SN t ->
  Normalized.SN (SN.normalize.isNormalized sn)
TypeCheck Normalize.SN : t:Term -> sn: SN t -> SN (SN.normalize sn)

Definition Normalized.ConvStep*.Id =
  \t: Term \n:Normalized t \t':Term \c: ConvStep* t t' ->
  ConvStep*.rec (\t:Term \t':Term \_:ConvStep* t t' ->
                 n:Normalized t -> I t t')
    (\t:Term \n:Normalized t -> I.r t)
    (\t:Term \t2:Term \step1:ConvStep t t2 \t':Term \step2:ConvStep* t2 t'
     \_: (Normalized t2 -> I t2 t') ->
     Normalized.rec (\n:Normalized t -> I t t')
      (\f:(t2:Term -> ConvStep t t2 -> F) ->
       F.rec (\_:F -> I t t') (f step1)))
    c n

Definition Normalize.Normalized = \t:Term \n:Normalized t ->
  Normalized.ConvStep*.Id n (SN.steps (Normalized.SN n))
TypeCheck Normalize.Normalized : t:Term -> n:Normalized t ->
  I t (SN.normalize (Normalized.SN n))


;===========================================
;  Term classification
;===========================================

Inductive Class : U =
  []     : Class,
  kind   : Class,
  type   : Class,
  constr : Class,
  obj    : Class

; Definition 2.3
Inductive Classified : Gamma:VarList -> t:Term -> Term -> Class -> U =
  kind  : CCTypeCheck Gamma t Term.[] -> Classified Gamma t Term.[] Class.kind,
  type  : CCTypeCheck Gamma t Term.*  -> Classified Gamma t Term.* Class.type,
  constr: A:Term -> CCTypeCheck Gamma t A -> CCTypeCheck Gamma A Term.[] ->
	  Classified Gamma t A Class.constr,
  obj   : A:Term -> CCTypeCheck Gamma t A -> CCTypeCheck Gamma A Term.* ->
          Classified Gamma t A Class.obj

Definition Class.constr2type =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.type Class.type Class.[]
Definition Class.type2constr =
  Class.rec (\_:Class -> Class)
    Class.[] Class.[] Class.constr Class.constr Class.obj
Definition Class.constrobj =
  VarType.rec (\_:VarType -> Class) Class.constr Class.obj
Definition Class.kindtype =
  VarType.rec (\_:VarType -> Class) Class.kind Class.type
Definition Class.boxkind =
  VarType.rec (\_:VarType -> Class) Class.[] Class.kind

; Classification Lemma
; Term.classify:  maps a term to its candidate class
;   Univ.[]   -> []
;   Univ.*    -> kind
;   Var.[] x  -> constr
;   Var.*     -> obj
;   app A B   -> class of A
;   lam A B   -> obj if class of B == obj else constr
;   pi  A B   -> kind if class of B == kind else type
Definition Term.classify =
  Term.rec (\t:Term -> Class)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; lam
        Class.type2constr Nc)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; pi
        Class.constr2type Nc)
    (\M:Term \Mc:Class \N:Term \_:Class -> Mc)          ; app
    (\vt:VarType \n:Nat -> Class.constrobj vt)          ; var
    Class.boxkind                                       ; univ

; Lemma: Term.shiftn doesn't change class
Definition Term.shiftn.classify =
  Term.rec (\M:Term -> n:Nat ->
            I (Term.classify (Term.shiftn M n)) (Term.classify M))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class.type2constr (Hyp (Nat.s n)))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class.constr2type (Hyp (Nat.s n)))
    (\M:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> Hyp n)
    (\vt:VarType \i:Nat \n:Nat -> I.r (Class.constrobj vt))
    (\vt:VarType \n:Nat -> I.r (Class.boxkind vt))

Assume Class.classification.1 :
  Gamma:VarList -> t:Term -> A:Term -> CCTypeCheck Gamma t A ->
  Classified Gamma t A (Term.classify t)

Assume Class.classification.2 :
  Gamma:VarList -> t:Term -> A:Term -> Classified Gamma t A class ->
  Match class (Term.classify t)

Inductive Base : Term -> U =
  pi   : {vt:VarType} -> {M:Term} -> {N:Term} -> SN (Term.pi vt M N) ->
	 Base (Term.pi vt M N),
  app  : {M:Term} -> Base M -> {N:Term} -> SN N -> Base (Term.app M N),
  var  : vt:VarType -> n:Nat -> Base (Term.var vt n),
  univ : vt:VarType -> Base (Term.univ vt)


; Reduce key reduct, if applicable.
Definition SN.redk =
  Term.rec (\T:Term -> Term)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.lam vt M N)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.pi vt M N)
    (\func:Term \Hyp:Term \arg:Term \_:Term ->
     Bool.ite (Term.isLam func)
        (Term.subst (Term.arg2 func) arg)
	(Term.app Hyp arg))
    (\vt:VarType \n:Nat -> Term.var vt n)
    (\vt:VarType -> Term.univ vt)

Definition SN.redk.arg =
  Term.rec (\T:Term -> Term)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.lam vt M N)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.pi vt M N)
    (\func:Term \Hyp:Term \arg:Term \_:Term ->
     Bool.ite (Term.isLam func) arg Hyp)
    (\vt:VarType \n:Nat -> Term.var vt n)
    (\vt:VarType -> Term.univ vt)

Definition pow = \X : U -> (X -> U)
Inductive SAT : X : (pow Term) -> U =
  def : (t:Term -> X t -> SN t) ->
        (t:Term -> Base t -> X t) ->
        (t:Term -> SN t -> X (SN.redk t) -> X t) -> SAT X
Definition SAT.sn = {\X:(pow Term)} ->
  SAT.rec X (\_:SAT X -> t:Term -> X t -> SN t)
    (\x:(t:Term -> X t -> SN t)
     \_:({t:Term} -> Base t -> X t)
     \_:({t:Term} -> SN t -> X (SN.redk t) -> X t) -> x)
Definition SAT.base = {\X:(pow Term)} ->
  SAT.rec X (\_:SAT X -> {t:Term} -> Base t -> X t)
    (\_:(t:Term -> X t -> SN t)
     \x:({t:Term} -> Base t -> X t)
     \_:({t:Term} -> SN t -> X (SN.redk t) -> X t) -> x)
Definition SAT.red = {\X:(pow Term)} ->
  SAT.rec X (\_:SAT X -> {t:Term} -> SN t -> X (SN.redk t) -> X t)
    (\_:(t:Term -> X t -> SN t)
     \_:({t:Term} -> Base t -> X t)
     \x:({t:Term} -> SN t -> X (SN.redk t) -> X t) -> x)

Inductive Kind : t:Term -> U =
  mk : Gamma:VarList -> A:Term -> Classified Gamma t A Class.kind -> Kind t

Assume Kind.rec2 : C:(\t:Term -> U1)
       C Term.*
       (M: Term -> Kind M -> C M ->
        N: Term -> Kind N -> C N -> C (Term.pi M N)) ->
       (M: Term -> Type M -> N: Term -> Kind N -> C N -> C (Term.pi M N)) ->
       t:Term -> Kind t -> C t

Inductive Vuniv : U =
  sat : Vuniv
  func: dom:Vuniv -> ran:Vuniv -> Vuniv

Definition VV =
  Kind.rec2 (\t:Term -> Vuniv)
    Vuniv.sat
    (\B:Term \_: Kind B \vB: Vuniv
     \C:Term \_: Kind C \vC: Vuniv -> Vuniv.func vB vC)
    (\B:Term \_: Type B \vB: Vuniv
     \C:Term \_: Kind C \vC: Vuniv -> vC)

Inductive SET : U =
  mk: (Term -> Bool) -> SET
Inductive FUN : A:U -> B:U -> U =
  mk: f:(A->B) -> FUN A B
Definition SAT* =
  Vuniv.rec (\_:Vuniv -> U2)
    pow Term 
    (\dom: Vuniv  \dom*:U \ran:Vuniv \ran*:U -> FUN dom* ran*)

Definition Eval = n:Nat -> SAT*
Definition constructorvaluation = \eval:(Nat -> SAT*) \Gamma:VarList
  VarList.rec
    eval


evalxi (Term.univ vt) = SN
evalxi (Term.app P Q) = (evalxi P) (evalxi Q)

Assume Lemma : goodevalxi Xi Gamma ->
  * (Classified Gamma Q A Class.constr -> inV A (evalxi xi Q))
    (Classified Gamma Q Term.[] Class.kind -> SAT (evalxi xi Q))

  sat : X : pow Term -> SAT X -> SAT* sat
  func: dom:Vuniv -> ran : Vuniv ->
        f : (SAT* dom -> SAT* ran) -> SAT* (func dom ran)


Definition Class.classification.1 =
  CCTypeCheck.rec (\Gamma:VarList \t:Term \A:Term
                   \_:CCTypeCheck Gamma t A -> Classified Gamma t A (Term.classify t))
    ; ax
    (Classified.kind CCTypeCheck.ax)
    ; var
    (\Gamma:VarList \vt:VarType \A:Term ->
     \tcA: CCTypeCheck Gamma A (Term.univ vt) ->
     \Hyp: Classified Gamma A (Term.univ vt) (Term.classify A) ->
     VarType.rec (\vt:VarType -> tcA: CCTypeCheck Gamma A (Term.univ vt) ->
                  Classified (VarList.cons vt A Gamma) (Term.var vt Nat.0) (Term.shiftvar A) (Class.constrobj vt))
	(\tcA: CCTypeCheck Gamma A Term.[] ->
	 Classified.constr (CCTypeCheck.var tcA) (CCTypeCheck.weak tcA tcA))
	(\tcA: CCTypeCheck Gamma A Term.* ->
	 Classified.obj (CCTypeCheck.var tcA) (CCTypeCheck.weak tcA tcA))
	vt tcA)
    ; weak
    (\Gamma:VarList \vt:VarType \A:Term ->
     \tcA: CCTypeCheck Gamma A (Term.univ vt) ->
     \Hyp1: Classified Gamma A (Term.univ vt) (Term.classify A) ->
     \t:Term \B:Term \tct: CCTypeCheck Gamma t B
     \Hyp2: Classified Gamma t B (Term.classify t) ->
     Let Gamma' = (VarList.cons vt A Gamma) ->
     Let t' = (Term.shiftvar t) ->
     Classified.rec Gamma t (\B':Term \c:Class \_:Classified Gamma t B' c ->
          I B' B -> I c (Term.classify t') ->
          Classified Gamma' t' (Term.shiftvar B) (Term.classify t'))
       ;kind
       (\cl1:CCTypeCheck Gamma t Term.[] -> \eq1: I Term.[] B ->
        \eq2:I Class.kind (Term.classify t') ->
	I.subst2 eq1 eq2 (\B:Term \c:Class -> Classified Gamma' t' (Term.shiftvar B) c)
           (Classified.kind (CCTypeCheck.weak tcA cl1)))
       ;type
       (\cl1:CCTypeCheck Gamma t Term.* -> \eq1: I Term.* B ->
        \eq2:I Class.type (Term.classify t') ->
	I.subst2 eq1 eq2 (\B:Term \c:Class -> Classified Gamma' t' (Term.shiftvar B) c)
           (Classified.type (CCTypeCheck.weak tcA cl1)))
       ;constr
       (\B':Term \cl1:CCTypeCheck Gamma t B' \cl2:CCTypeCheck Gamma B' Term.[]
        \eq1: I B' B ->
        \eq2:I Class.constr (Term.classify t') ->
	I.subst2 eq1 eq2 (\B:Term \c:Class -> Classified Gamma' t' (Term.shiftvar B) c)
           (Classified.constr (CCTypeCheck.weak tcA cl1) (CCTypeCheck.weak tcA cl2)))
       ;obj
       (\B':Term \cl1:CCTypeCheck Gamma t B' \cl2:CCTypeCheck Gamma B' Term.*
        \eq1: I B' B ->
        \eq2:I Class.obj (Term.classify t') ->
	I.subst2 eq1 eq2 (\B:Term \c:Class -> Classified Gamma' t' (Term.shiftvar B) c)
           (Classified.obj (CCTypeCheck.weak tcA cl1) (CCTypeCheck.weak tcA cl2)))
       Hyp2 (I.r B) (I.symm (Term.shiftn.classify t Nat.0)))
    ; pi
    (\Gamma:VarList \vt:VarType \A:Term ->
     \tcA: CCTypeCheck Gamma A (Term.univ vt) ->
     \Hyp1: Classified Gamma A (Term.univ vt) (Term.classify A) ->
     \vt2:VarType \B:Term
     \tct: CCTypeCheck (VarList.cons vt  A Gamma) B (Term.univ vt2)
     \Hyp2: Classified (VarList.cons vt  A Gamma) B (Term.univ vt2) (Term.classify t) ->
     )
    

Definition Class.classification =
TypeCheck Class.classification.k :
   t:Term -> Classified t Class.Kind -> I (Term.classify t) Class.Kind
TypeCheck Class.classfication.1 =
   t:Term -> Classified t Class.kind -> Classified t Class.type -> F
TypeCheck Class.classfication.2 =
   t:Term -> Classified t Class.constr -> Classified t Class.obj -> F
   




; Definition 2.3
Inductive TypedClass : Gamma:VarList -> S:Term -> A:Term -> Class -> U =
  kind  : CCTypeCheck Gamma S Term.[] -> TypedClass Gamma S A Class.kind,
  type  : CCTypeCheck Gamma S A -> CCTypeCheck Gamma A Term.[] ->
  	  CCTypeCheck Gamma S Term.*  -> TypedClass Gamma S A Class.type,
  constr: CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.[] -> TypedClass Gamma S A Class.constr,
  obj   : CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.* -> TypedClass Gamma S A Class.obj


; Classification Lemma
Definition Class.classfication.1 =
   \t:Term \A:Term

Definition CCTypeCheck.constraints = \Gamma:VarList ->
  Term.rec (\S:Term -> U)
    ; lam
    (\vt:VarType \M:Term \_:U \N:Term \_:U ->
       Sigma (\S:Term ->
          CCTypeCheck Gamma (Term.lam vt M N) (Term.pi vt M S)))
    ; pi
    (\vt:VarType \M:Term \_:U \N:Term \_:U ->
       Sigma VarType (\vt2:VarType ->
          CCTypeCheck (VarList.cons vt M Gamma) N (Term.univ vt2)))
    (\M:Term \_:U \N:Term \_:U -> T) ; app
    (\vt:VarType \n:Nat -> T)        ; var
    (\vt:VarType -> T)               ; univ

Definition CCTypeCheck.okay =
   CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term
   		    \_:CCTypeCheck Gamma M S ->
		          CCTypeCheck.constraints Gamma S)
     T.tt ; ax
     (\Gamma:VarList \vt:VarType \T0:Term                 ; var
      \prf:CCTypeCheck Gamma T0 (Term.univ vt)
      \Hyp:CCTypeCheck.constraints Gamma (Term.univ vt) ->
      )
     (\Gamma:VarList \vt:VarType \T0:Term                 ; weak
      \prf1:CCTypeCheck Gamma T0 (Term.univ vt)
      \_:CCTypeCheck.constraints Gamma (Term.univ vt)
      \prf2:CCTypeCheck Gamma M S
      \Hyp:CCTypeCheck.constraints Gamma S ->
      Term.rec (S:Term -> CCTypeCheck.constraints Gamma S ->
                CCTypeCheck.constraints (VarList.cons vt T0 Gamma) S)
	(\vt1:VarType \M:Term \_:U \N:Term \_:U ->
	 Sigma.rec Term (\S1:Term ->
         	         CCTypeCheck Gamma (Term.lam vt1 M N) (Term.pi vt1 M S1))
	     (\_:Sigma (\S1:Term -> CCTypeCheck Gamma (Term.lam vt1 M N) (Term.pi vt1 M S1)) ->
	       CCTypeCheck (VarList.cons vt T0 Gamma)
	       		   (Term.shiftvar (Term.lam vt1 M N)) (Term.shiftvar (Term.pi.vt1 M S1)))
	     (\S1:Term
	      \prf3:CCTypeCheck Gamma (Term.lam vt M N) (Term.pi vt M S1) ->
	      CCTypeCheck.weak prf1 prf3)))

      
Definition Term.classify.type.correct =
   CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \t:CCTypeCheck Gamma M S ->
                    TypedClass Gamma M S (Term.classify M))
    ;ax
    (TypedClass.kind VarList.nil Term.* Term.[] CCTypeCheck.ax)
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf:CCTypeCheck Gamma T0 (Term.univ vt)
     \_:TypedClass Gamma T0 (Term.univ vt) (Term.classify T0) ->
     VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term -> A:Term ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M A (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt (VarList.cons vt T0 Gamma) (Term.var vt Nat.0) (Term.shiftvar T0)
	(CCTypeCheck.var prf)
	(CCTypeCheck.weak prf prf))
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: TypedClass Gamma T0 (Term.univ vt) (Term.classify T0) ->
     \M: Term -> \S:Term -> \prf2:CCTypeCheck Gamma M S ->
     I.rsubst (Term.shiftn.classify M Nat.0)
     	 (\x:Class -> TypedClass Gamma M S (Term.classify M) ->
	 	   TypedClass (VarList.cons vt T0 Gamma)
		   	      (Term.shiftvar M) (Term.shiftvar S) x)
     (TypedClass.rec Gamma M S
         (\class: Class \_:TypedClass Gamma M S class ->
          TypedClass (VarList.cons vt T0 Gamma)
	  	     (Term.shiftvar M) (Term.shiftvar S) class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  TypedClass.kind (VarList.cons vt T0 Gamma)
	  		  (Term.shiftvar M) (Term.shiftvar S)
	                  (CCTypeCheck.weak prf prf3))
	 ; type
	 (\prf3: CCTypeCheck Gamma M S
	  \prf4: CCTypeCheck Gamma S Term.[] ->
	  \prf5: CCTypeCheck Gamma M Term.* ->
	  TypedClass.type (VarList.cons vt T0 Gamma)
	  		  (Term.shiftvar M) (Term.shiftvar S)
	                  (CCTypeCheck.weak prf prf3)
			  (CCTypeCheck.weak prf prf4)
			  (CCTypeCheck.weak prf prf5))
	 ; constr
	 (\prf3: CCTypeCheck Gamma M S
	  \prf4: CCTypeCheck Gamma S Term.[] ->
	  TypedClass.constr (VarList.cons vt T0 Gamma)
	  		    (Term.shiftvar M) (Term.shiftvar S)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 ; obj
	 (\prf3: CCTypeCheck Gamma M S
	  \prf4: CCTypeCheck Gamma S Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar S)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 (Term.classify M)))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \_: TypedClass Gamma T1 (Term.univ vt1) (Term.classify T1) ->
     \vt2: VarType -> \S:Term ->
     \prf2: CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp: TypedClass (VarList.cons vt1 T1 Gamma)
     	   	      S (Term.univ vt2) (Term.classify S) ->
     I.rsubst (Assume I (Class.constr2type (Term.classify S))
     	      	      	(Class.kindtype vt2))
	       (\x:Class -> TypedClass Gamma (Term.pi vt1 T1 S) (Term.univ vt2) x)
     (VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term ->
		  CCTypeCheck Gamma M (Term.univ vt) ->
                  TypedClass Gamma M (Term.univ vt) (Class.kindtype vt))
	(\Gamma:VarList \M:Term ->
         TypedClass.kind Gamma M Term.[])
	(\Gamma:VarList \M:Term \prf: CCTypeCheck Gamma M Term.* ->
	 TypedClass.type Gamma M Term.* prf
	                 (CCTypeCheck.ax2 Gamma
			    (CCTypeCheck.gammatc Gamma M Term.* prf)) prf)
	vt2 Gamma (Term.pi vt1 T1 S) (CCTypeCheck.pi prf1 prf2)))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \_: TypedClass (VarList.cons vt1 T1 Gamma) M S (Term.classify M) ->
     \vt2: VarType ->
     \prf2: CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp: TypedClass Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     	   	      (Class.constr2type (Term.classify S)) ->
     I.rsubst  (Assume I (Class.type2constr (Term.classify M)) (Class.constrobj vt2))
	       (\x:Class -> TypedClass Gamma (Term.lam vt1 T1 M)
	       		    	       	     (Term.pi vt1 T1 S) x)
     (VarType.rec (\vt:VarType ->
     		  {Gamma:VarList} -> {M:Term} -> {A:Term} ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M A (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt2 (CCTypeCheck.lam prf1 prf2) prf2))
    ;app
    (\Gamma:VarList \M:Term \vt1:VarType \T1:Term \S:Term
     \prf1: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
     \Hyp: TypedClass Gamma M (Term.pi vt1 T1 S) (Term.classify M) ->
     \N:Term
     \prf2: CCTypeCheck Gamma N T1
     \_: TypedClass Gamma N T1 (Term.classify N) ->
     Let SN = Term.subst S N ->
     (TypedClass.rec Gamma M (Term.pi vt1 T1 S)
         (\class: Class \_:TypedClass Gamma M (Term.pi vt1 T1 S) class ->
          TypedClass Gamma (Term.app M N) SN class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  Assume TypedClass Gamma (Term.app M N) SN Class.kind)
	 ; type
	 (\prf3: CCTypeCheck Gamma M (Term.pi vt1 T1 S) ->
	  \prf4: CCTypeCheck Gamma (Term.pi vt1 T1 S) Term.[] ->
	  \prf5: CCTypeCheck Gamma M Term.* ->
	  Assume TypedClass Gamma (Term.app M N) SN Class.type)
	 ; constr
	 (\prf3: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
	  \prf4: CCTypeCheck Gamma (Term.pi vt1 T1 S) Term.[] ->
	  TypedClass.constr Gamma (Term.app M N) SN
	     (CCTypeCheck.app prf1 prf2)
	     (CCTypeCheck.subst (CCTypeCheck.weak prf prf4) prf2))
	 ; obj
	 (\prf3: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
	  \prf4: CCTypeCheck Gamma (Term.pi vt1 T1 S) Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 (Term.classify M)))
     Class.rec (
     I.rsubst  (Assume I (Class.type2constr (Term.classify M)) (Class.constrobj vt2))
	       (\x:Class -> TypedClass Gamma (Term.lam vt1 T1 M) x)
     (VarType.rec (\vt:VarType ->
     		  {Gamma:VarList} -> {M:Term} -> {A:Term} ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt2 (CCTypeCheck.lam prf1 prf2) prf2))

Definition Term.ispi = 
   Term.rec (\t:Term -> U)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> F)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> T)
      (\M:Term \_:U \N:Term \_:U -> F)
      (\vt:VarType \n:Nat -> F)
      (\vt:VarType -> F)
Definition Term.casepi = \C:(t:Term -> U1)
   \case:(vt:VarType -> T:Term -> S:Term -> C (Term.pi vt T S)) ->
   Term.rec (\t:Term -> Term.ispi t -> C t)
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.lam vt M N)))
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         \_:T -> case vt M N)
      (\M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.app M N)))
      (\vt:VarType \n:Nat -> F.rec (\_:F -> C (Term.var vt n)))
      (\vt:VarType -> F.rec (\_:F -> C (Term.univ vt)))

Inductive KindOrType : Gamma:VarList -> S:Term -> U =
  kind: CCTypeCheck Gamma S Term.[] -> KindOrType Gamma S,
  type: CCTypeCheck Gamma S Term.*  -> KindOrType Gamma S



Definition PiRangeCorrectType = \Gamma:VarList ->
  Term.casepi (\_:Term -> U)
              (\vt0:VarType \T0:Term \S0:Term ->
	         KindOrType (VarList.cons vt0 T0 Gamma) S0)

Definition PiRangeCorrect = 
  CCTypeCheck.rec
     (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
      PiRangeCorrectType Gamma M)
    ;ax
    T.tt
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     T.tt)
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     Term.casepi (\M: Term -> S:Term -> CCTypeCheck Gamma M S ->
        PiRangeCorrectType Gamma M ->
        PiRangeCorrectType (VarList.cons vt T0 Gamma) (Term.shiftvar M))
        (\vt1:VarType \T1:Term \S1:Term
	 \S:Term \_:CCTypeCheck Gamma (Term.pi vt1 T1 S1) S ->
	 KindOrType.rec (VarList.cons vt1 T1 Gamma) S1
	    (\_:KindOrType (VarList.cons vt1 T1 Gamma) S1 ->
	     KindOrType (VarList.cons vt1 (Term.shiftvar T1) (VarList.cons vt T0 Gamma)) (Term.shiftn S1 Nat.1))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.[] ->
	     KindOrType.kind (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.* ->
	     KindOrType.type (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf)))
	(\M:Term \S:Term \_:CCTypeCheck Gamma M S
	 \_:PiRangeCorrectType Gamma M ->
	 T.tt))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Inductive TermClass : Gamma:VarList -> M:Term -> U =
  kind   : CCTypeCheck Gamma M Term.[] -> TermClass Gamma M,
  constr : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.[]
           -> TermClass Gamma M,
  obj    : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.*
           -> TermClass Gamma M
  
Definition Term.classify =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
  		   TermClass Gamma M)
    (TermClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList -> VarType.rec
        (\vt:VarType -> T:Term -> CCTypeCheck Gamma T (Term.univ vt) ->
	 TermClass Gamma T ->
	 TermClass (VarList.cons vt T Gamma) (Term.var vt Nat.0))
        (\T:Term \prf:CCTypeCheck Gamma T Term.[] \rec:TermClass Gamma T ->
	 TermClass.constr (VarList.cons VarType.[] T Gamma)
	 		  (Term.var VarType.[] Nat.0)
			  (Term.shiftvar T)
	                  (CCTypeCheck.var Gamma VarType.[] T prf)
	             (CCTypeCheck.weak Gamma VarType.[] T prf T Term.[] prf))
        (\T:Term \prf:CCTypeCheck Gamma T Term.* \rec:TermClass Gamma T ->
	 TermClass.obj (VarList.cons VarType.* T Gamma)
	 	       (Term.var VarType.* Nat.0)
		       (Term.shiftvar T)
	               (CCTypeCheck.var Gamma VarType.* T prf)
		       (CCTypeCheck.weak Gamma VarType.* T prf T Term.* prf)))
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prfvar: CCTypeCheck Gamma T (Term.univ vt) \_: TermClass Gamma T
     \M : Term \S:Term
     \_: CCTypeCheck Gamma M S ->
     TermClass.rec Gamma M (\_:TermClass Gamma M ->
                   TermClass (VarList.cons vt T Gamma) (Term.shiftvar M))
     	;kind
        (\prf1:CCTypeCheck Gamma M Term.[] ->
	 TermClass.kind (VarList.cons vt T Gamma) (Term.shiftvar M)
	                (CCTypeCheck.weak Gamma vt T prfvar
					  M Term.[] prf1))
     	;constr
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.[] ->
	 TermClass.constr (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.[] prf2))
     	;obj
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.* ->
	 TermClass.obj (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.* prf2)))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \prf1:CCTypeCheck Gamma T (Term.univ vt) \rec:TermClass Gamma T ->
     VarType.rec (\vt2:VarType -> S:Term ->
     		  CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
		  TermClass (VarList.cons vt T Gamma) S ->
		  TermClass Gamma (Term.pi vt T S))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.[]
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.kind Gamma (Term.pi vt T S)
	 		(CCTypeCheck.pi Gamma vt T prf1 VarType.[] S prf2))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.*
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.constr Gamma (Term.pi vt T S) Term.*
	 		  (CCTypeCheck.pi Gamma vt T prf1 VarType.* S prf2)
			  (CCTypeCheck.ax2 (CCTypeCheck.gammatc Gamma T
			  		                 (Term.univ vt) prf1))))
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \prf1:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:TermClass (VarList.cons vt T Gamma) M ->
     VarType.rec (\vt2:VarType -> 
     		  CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
		  TermClass Gamma (Term.pi vt T S) ->
		  TermClass Gamma (Term.lam vt T M))
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.[]
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.constr Gamma (Term.lam vt T M) (Term.pi vt T S)
	 		  (CCTypeCheck.lam Gamma vt T M S prf1 VarType.[] prf2)
			  prf2)
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.*
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.obj Gamma (Term.lam vt T M) (Term.pi vt T S)
	 	       (CCTypeCheck.lam Gamma vt T M S prf1 VarType.* prf2)
		       prf2))
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \prf1:CCTypeCheck Gamma M (Term.pi vt T S) \_:TermClass Gamma M
     \N:Term \prf2:CCTypeCheck Gamma N T \_:TermClass Gamma N ->
     Ter
     TermClass
     TermClass Gamma (Term.app M N)
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:TermClass Gamma M
     \S:Term \_:ConvSymmStep T S -> rec)
    







Definition Normalize.subst.up.aux =
  \M:Term \M':Term \nM:Normalize M M' ->
  \N:Term \N':Term \nN:Normalize N N' ->
  \n:Nat \snMN:SN (Term.substn M n N) \snMN':SN (Term.substn M' n N') ->
  \eq1:I (SN.normalize (SN.arg1 snMN)) (SN.normalize (SN.arg1 snMN')) ->
  \eq2:I (SN.normalize (SN.arg2 snMN)) (SN.normalize (SN.arg2 snMN')) ->
  \eq3: Bool.ite (Term.isApp (Term.substn M n N))
    (Bool.ite (Term.isLam (SN.normalize (SN.arg1 snMN)))
      (I (SN.normalize (SN.arg3 snMN)) (SN.normalize (SN.arg3 snMN')))
      T) T ->
  I.trans (I.trans (I.symm (Normalize.result.eq (SN.destruct snmN)))
    
  	  (I.cong3 (\x:Term \y:Term \z:Term ->
	            B
	  	    \z: Bool.ite (Term.isApp (Term.substn M n N))
		    	  (Bool.ite (Term.isLam x)) 
	  	    (
  	  
  I (SN.normalize snMN) (SN.normalize snMN')

  
Definition Normalize.subst.up =
  Let Thesis = (\MN:Term \M'':Term \nMN:Normalize MN M'' ->
     M:Term -> M':Term -> nM: Normalize M M' ->
     N:Term -> N':Term -> nN: Normalize N N' ->
     n: Nat -> I (Term.substn M n N) MN ->
     sn':SN (Term.substn M' n N') -> I M'' (SN.normalize sn'))
  Normalize.rec Thesis
    ;lam
    (\vt:VarType \MN1:Term \MN1':Term \n1:Normalize MN1 MN1' \Hyp1:Thesis n1
     \MN2:Term \MN2':Term \n2:Normalize MN2 MN2' \Hyp2:Thesis n2
     \M:Term \M':Term \nM: Normalize M M' ->
     \N:Term \N':Term \nN: Normalize N N'
     Let Th2 = (\M:Term -> \M':Term -> \_:Normalize M M' ->
     	n:Nat -> I (Term.substn M n N) (Term.lam vt MN1 MN2) ->
	Normalize (Term.substn M' n N') (Term.lam vt MN1' MN2')) ->
     Normalize.rec Th2
       ;lam
       (\vtM:VarType \M1:Term \M1':Term \nM1:Normalize M1 M1' \_:Th2 nM1
        \M2:Term \M2':Term \nM2:Normalize M2 M2' \_:Th2 nM2
	\n:Nat
	\eq: I (Term.substn (Term.lam vtM M1 M2) n N) (Term.lam vt MN1 MN2) ->
	I.subst (I.cong Term.vt eq)
	  (\x:VarType -> Normalize (Term.substn (Term.lam vtM M1' M2') n N)
				   (Term.lam x MN1 MN2))
	(Normalize.lam vtM
	  (Hyp1 nM1 nN n (I.cong Term.arg1 eq))
	  (Hyp2 nM2 nN (Nat.s n) (I.cong Term.arg2 eq)))))
    ;pi
    (\vt:VarType \M1:Term \M1':Term \nM1:Normalize M1 M1' \Hyp1:Thesis nM1
     \M2:Term \M2':Term \nM2:Normalize M2 M2' \Hyp2:Thesis nM2
     \n:Nat \M'':Term
     \nMN':Normalize (Term.substn (Term.pi vt M1' M2') n N') M'' ->
     Let snMN'' = SN.case (SN.sn nMN') ->
     Let nMN = (Normalize.pi vt (Hyp1 n (SN.destruct (SN.arg1 snMN'')))
     		   	     (Hyp2 (Nat.s n) (SN.destruct (SN.arg2 snMN'')))) ->
     I.subst (SN.case.eq (SN.sn nMN'))
        (\x:SN (Term.substn (Term.pi vt M1' M2') n N') ->
	  Normalize (Term.substn (Term.pi vt M1 M2) n N)
	  	    (SN.normalize x))
	nMN)
    ;applam
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \nM1:Normalize M1 (Term.lam vt M11' M12') \Hyp1:Thesis nM1
     \M2:Term \M2':Term \nM2:Normalize M2 M2' \Hyp2:Thesis nM2
     Let M3 = Term.subst M12' M2'
     \M':Term \nM3:Normalize M3 M' \Hyp3 Thesis nM3
     \n:Nat \M'':Term
     \nMN':Normalize (Term.substn M' n N') M'' ->
     Let snMN'' = SN.case (SN.sn nMN') ->
     Let nMN = (Normalize.applam vt
     	 (Hyp1 n (Normalize.lam (

Definition Normalize.subst.down = {\N:Term} ->
 Let Thesis = (\M:Term \M':Term -> \nM: Normalize M M' ->
      	        n:Nat -> {M'':Term} ->
   		Normalize (Term.substn M n N) M'' ->
   		Normalize (Term.substn M' n N) M'') ->
  Normalize.rec Thesis
    ;lam
    (\vt:VarType \M1:Term \M1':Term \nM1:Normalize M1 M1' \Hyp1:Thesis nM1
     \M2:Term \M2':Term \nM2:Normalize M2 M2' \Hyp2:Thesis nM2
     \n:Nat \M'':Term
     \nMN:Normalize (Term.substn (Term.lam vt M1 M2) n N) M'' ->
     Let snMN = SN.case (SN.sn nMN) ->
     Let nMN' = (Normalize.lam vt (Hyp1 n (SN.destruct (SN.arg1 snMN)))
     		   	      (Hyp2 (Nat.s n) (SN.destruct (SN.arg2 snMN)))) ->
     I.subst (SN.case.eq (SN.sn nMN))
        (\x:SN (Term.substn (Term.lam vt M1 M2) n N) ->
	  Normalize (Term.substn (Term.lam vt M1' M2') n N)
	  	    (SN.normalize x))
	nMN')
    ;pi
    (\vt:VarType \M1:Term \M1':Term \nM1:Normalize M1 M1' \Hyp1:Thesis nM1
     \M2:Term \M2':Term \nM2:Normalize M2 M2' \Hyp2:Thesis nM2
     \n:Nat \M'':Term
     \nMN:Normalize (Term.substn (Term.pi vt M1 M2) n N) M'' ->
     Let snMN = SN.case (SN.sn nMN) ->
     Let nMN' = (Normalize.pi vt (Hyp1 n (SN.destruct (SN.arg1 snMN)))
     		   	     (Hyp2 (Nat.s n) (SN.destruct (SN.arg2 snMN)))) ->
     I.subst (SN.case.eq (SN.sn nMN))
        (\x:SN (Term.substn (Term.pi vt M1 M2) n N) ->
	  Normalize (Term.substn (Term.pi vt M1' M2') n N)
	  	    (SN.normalize x))
	nMN')
    ;applam
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \nM1:Normalize M1 (Term.lam vt M11' M12') \Hyp1:Thesis nM1
     \M2:Term \M2':Term \nM2:Normalize M2 M2' \Hyp2:Thesis nM2
     Let M3 = Term.subst M12' M2'
     \M':Term \nM3:Normalize M3 M' \Hyp3:Thesis nM3
     \n:Nat \M'':Term
     \nMN:Normalize (Term.substn (Term.app M1 M2) n N) M'' ->
     Let MN1 = SN.normalize (Normalize.arg1 nMN)
     Let MN2 = SN.normalize (Normalize.arg2 nMN) ->
     Let M'N = Term.substn M' n N ->
     Bool.rec (\x:Bool -> 
     	       nl:Bool.ite x (Term.eqLam.type MN1) (NotLam MN1) ->
	       sn3:Bool.ite x (SN (Term.subst (Term.arg2 MN1) MN2)) T ->
	       I (Normalize.case.app (Normalize.arg1 nMN) (Normalize.arg2 nMN)
				     x nl sn3)
		 (SN.sn nMN) ->
     	       Normalize M'N M'')
       (\eq:Term.eqLam.type MN1 ->
        \sn3:SN (Term.subst (Term.arg2 MN1) (MN2))
	\eqsn:I (Normalize.case.app (Normalize.arg1 nMN) (Normalize.arg2 nMN)
				    Bool.tt eq sn3)
		(SN.sn nMN)
        Let nMN1 = I.rsubst eq (\x:Term -> Normalize (Term.substn M1 n N) x)
	    	   	       (SN.destruct (Normalize.arg1 nMN)) ->
;	I.subst eqsn (\x:SN (Term.substn (Term.app M1 M2) n N) ->
;		Normalize M'N (SN.normalize x))
	Hyp3 n (Normalize.applam (Hyp1 n nMN1)
	       			 (Hyp2 n (SN.destruct (Normalize.arg2 nMN)))
			  	 (SN.destruct sn3)))
       (\nl:NotLam MN1 \t:T
	\eqsn:I (Normalize.case.app (Normalize.arg1 nMN) (Normalize.arg2 nMN)
				    Bool.ff nl t)
		(SN.sn nMN) ->
	I.subst eqsn (\x:SN (Term.substn (Term.app M1 M2) n N) ->
		Normalize M'N (SN.normalize x))
        (Normalize.app (Hyp1 n (SN.destruct (Normalize.arg1 nMN))) nl
		       (Hyp2 n (SN.destruct (Normalize.arg2 nMN)))))
       (Term.isLam MN1)
       (Term.classifyLam MN1)
       (Normalize.arg3 nMN)
       (Normalize.case.eq nMN))
    ;app
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \nM1:Normalize M1 (Term.lam vt M11' M12') \Hyp1:Thesis nM1
     \M2:Term \M2':Term \nM2:Normalize M2 M2' \Hyp2:Thesis nM2
     Let M3 = Term.subst M12' M2'
     \M':Term \nM3:Normalize M3 M' \Hyp3:Thesis nM3
     \n:Nat \M'':Term
     \nMN:Normalize (Term.substn (Term.app M1 M2) n N) M'' ->
     Let MN1 = SN.normalize (Normalize.arg1 nMN)
     Let MN2 = SN.normalize (Normalize.arg2 nMN) ->
     Let M'N' = Term.substn (Term.app (Term.lam vt M11' M12') M2') n N' ->
     Bool.rec (\x:Bool -> 
     	       nl:Bool.ite x (Term.eqLam.type MN1) (NotLam MN1) ->
	       sn3:Bool.ite x (SN (Term.subst (Term.arg2 MN1) MN2)) T ->
	       I (Normalize.case.app (Normalize.arg1 nMN) (Normalize.arg2 nMN)
				     x nl sn3)
		 (SN.sn nMN) ->
     	       Normalize M'N' M'')
       (\eq:Term.eqLam.type MN1 ->
        \sn3:SN (Term.subst (Term.arg2 MN1) (MN2))
	\eqsn:I (Normalize.case.app (Normalize.arg1 nMN) (Normalize.arg2 nMN)
				    Bool.tt eq sn3)
		(SN.sn nMN)
        Let nMN1 = I.rsubst eq (\x:Term -> Normalize (Term.substn M1 n N) x)
	    	   	       (SN.destruct (Normalize.arg1 nMN)) ->
	I.subst eqsn (\x:SN (Term.substn (Term.app M1 M2) n N) ->
		Normalize M'N' (SN.normalize x))
	(Normalize.applam (Hyp1 n nMN1) (Hyp2 n (SN.destruct (Normalize.arg2 nMN)))
			  (SN.destruct sn3)))
       (\nl:NotLam MN1 \t:T
	\eqsn:I (Normalize.case.app (Normalize.arg1 nMN) (Normalize.arg2 nMN)
				    Bool.ff nl t)
		(SN.sn nMN) ->
	I.subst eqsn (\x:SN (Term.substn (Term.app M1 M2) n N) ->
		Normalize M'N' (SN.normalize x))
        (Normalize.app (Hyp1 n (SN.destruct (Normalize.arg1 nMN))) nl
		       (Hyp2 n (SN.destruct (Normalize.arg2 nMN)))))
       (Term.isLam MN1)
       (Term.classifyLam MN1)
       (Normalize.arg3 nMN)
       (Normalize.case.eq nMN))

Definition Normalize.redk.eq =
  Let Thesis = (\t:Term -> SN t -> a:Term -> SN a ->
                t':Term -> Normalize (SN.redk (Term.app t a)) t' ->
		Normalize (Term.app t a) t') ->
  Term.rec Thesis
     (\vt:VarType \m:Term \Hyp1:Thesis m \n:Term \Hyp2:Thesis n ->
      \snt:SN (Term.lam vt m n) \a:Term \sna:SN a ->
      \t':Term \norm:Normalize (Term.subst n a) t' ->
      ; SN.arg2 snt: n ---> n',   sna: a ---> a'
      ; snt: lam vt m n ---> lam vt m' n'
      ; Term.subst n a ---> t'  ->  Term.subst n' a' ---> t'
      ;Let result = Normalize.applam snt sna
      ;            (SN.subst (SN.arg2 snt) sna (SN.sn norm))
      Assume Normalize (Term.app (Term.lam vt m n) a) t')
     (\vt:VarType \m:Term \Hyp1:Thesis m \n:Term \Hyp2:Thesis n ->
      \_:SN (Term.pi vt m n) \a:Term \_:SN a ->
      \t':Term \n:Normalize (Term.app (Term.pi vt m n) a) t' -> n)
     (\m:Term \Hyp1:Thesis m \n:Term \Hyp2:Thesis n ->
      \snt:SN (Term.app m n) \a:Term \sna:SN a ->
      \t':Term \norm:Normalize (Term.app (SN.redk (Term.app m n)) a) t' ->
      Let H = Hyp1 (SN.arg1 snt) n (SN.arg2 snt)
		   (SN.destruct (Normalize.arg1 norm)) ->
      Let t1' = SN.normalize (Normalize.arg1 norm) ->
      ; H : Normalize (Term.app m n) t1'
      Let result = Normalize.case.app (SN.sn H) (Normalize.arg2 norm)
          (Term.isLam t1') (Term.classifyLam t1') (Normalize.arg3 norm) ->
      I.subst (Assume I (SN.normalize result) t')
         (\x:Term -> Normalize (Term.app (Term.app m n) a) x)
	 (SN.destruct result))
     (\vt:VarType \i:Nat ->
      \snt:SN (Term.var vt i) \a:Term \sna:SN a ->
      \t':Term \n:Normalize (Term.app (Term.var vt i) a) t' -> n)
     (\vt:VarType ->
      \snt:SN (Term.univ vt) \a:Term \sna:SN a ->
      \t':Term \n:Normalize (Term.app (Term.univ vt) a) t' -> n)
      
Definition SN.app.redk = \t:Term \snt:SN t \a:Term \sna:SN a
  \sn:SN (SN.redk (Term.app t a)) ->
  SN.sn (Normalize.redk.eq snt sna (SN.destruct sn))


Definition Function = \dom : pow Term -> \rng : pow Term
  \t:Term -> (a:Term -> dom a -> rng (Term.app t a))
Definition Intersect = \A : U -> \sets : (A -> pow Term)
  \t:Term -> (a:A -> sets a t)

Definition Function.closed =
  {\dom:pow Term} -> \sdom:SAT dom -> {\rng:pow Term} -> \srng:SAT rng ->
  SAT.def (Function dom rng)
    (\t:Term -> \xt:(a:Term -> dom a -> rng (Term.app t a)) ->
     SN.arg1 (SAT.sn srng (Term.app t Term.*)
			  (xt Term.* ((SAT.base sdom) (Base.univ VarType.*)))))
    (\t:Term \bt:Base t \a:Term \doma: dom a ->
     SAT.base srng (Base.app bt (SAT.sn sdom a doma)))
    (\t:Term \snt:SN t \xredk:(a:Term -> dom a -> rng (Term.app (SN.redk t) a))
     \a:Term \doma: dom a ->
     Let Thesis = (\t:Term -> SN t ->
        rngred:rng (Term.app (SN.redk t) a) -> rng (Term.app t a)) ->
     Term.rec (\t:Term -> Thesis t)
        (\vt:VarType \M:Term \_:Thesis M \N:Term \_:Thesis N ->
	 \_:SN (Term.lam vt M N)
	 \rngred:(rng (Term.app (Term.lam vt M N) a)) ->
	 rngred)
        (\vt:VarType \M:Term \_:Thesis M \N:Term \_:Thesis N ->
	 \_:SN (Term.pi vt M N)
	 \rngred:rng (Term.app (SN.redk (Term.pi vt M N)) a) ->
	 rngred)
        (\M:Term \Hyp:Thesis M \N:Term \_:Thesis N ->
	 \snt:SN (Term.app M N)
	 \rngred:rng (Term.app (SN.redk (Term.app M N)) a) ->
	 SAT.red srng
	 	 (SN.app.redk snt (SAT.sn sdom a doma)
		    (SAT.sn srng (Term.app (SN.redk (Term.app M N)) a) rngred))
		 rngred)
	(\vt:VarType \i:Nat ->
	 \_:SN (Term.var vt i) ->
	 \rngred:rng (Term.app (SN.redk (Term.var vt i)) a) ->
	 rngred)
        (\vt:VarType ->
	 \_:SN (Term.univ vt) ->
	 \rngred:rng (Term.app (SN.redk (Term.univ vt)) a) ->
	 rngred)
	t snt (xredk a doma))

TypeCheck Function.closed :
  {dom:pow Term} -> sdom:SAT dom -> {rng:pow Term} -> srng:SAT rng ->
  SAT (Function dom rng)



Inductive NotLam : Term -> U =
  pi    : vt:VarType -> M:Term -> N:Term -> NotLam (Term.pi vt M N),
  app   : M:Term -> N:Term -> NotLam (Term.app M N),
  var   : vt:VarType -> i:Nat -> NotLam (Term.var vt i),
  univ  : vt:VarType -> NotLam (Term.univ vt)

Definition NotLam.term =
  NotLam.rec ({\t:Term} \nl1:NotLam t -> Term)
    (\vt:VarType \M:Term \N:Term -> Term.pi vt M N)
    (\M:Term \N:Term -> Term.app M N)
    (\vt:VarType \i:Nat -> Term.var vt i)
    (\vt:VarType -> Term.univ vt)
Definition NotLam.eqterm =
  NotLam.rec ({\t:Term} \nl1:NotLam t -> I (NotLam.term nl1) t)
    (\vt:VarType \M:Term \N:Term -> I.r (Term.pi vt M N))
    (\M:Term \N:Term -> I.r (Term.app M N))
    (\vt:VarType \i:Nat -> I.r (Term.var vt i))
    (\vt:VarType -> I.r (Term.univ vt))

Definition NotLam.alleq = 
  NotLam.rec ({\t:Term} \nl1:NotLam t -> nl2:NotLam t -> I nl1 nl2)
    (\vt:VarType \M:Term \N:Term \nl:NotLam (Term.pi vt M N) ->
     NotLam.rec ({\t':Term} \nl2:NotLam t' ->
     		 eq:I (Term.pi vt M N) t' ->
     		 I (I.subst eq NotLam (NotLam.pi vt M N)) nl2)
       (\vt':VarType \M':Term \N':Term ->
        eq:I (Term.pi vt M N) (Term.pi vt' M' N') ->
        I.cong3 (\x:VarType \y:Term \z:Term -> NotLam.pi x y z)
		(I.cong Term.vt eq) (I.cong Term.arg1 eq) (I.cong Term.arg2 eq))
     NotLam.eqterm 
       (\vt':VarType \M':Term \N':Term
        \eq:I (Term.pi vt M N) (Term.pi vt' M' N') ->
        I.cong3 Var.pi
       (\vt:VarType \M
     		 I (Term.pi M N) t' -> I (Var.pi M N) nl2)
       
     (caseelse (NotLam.pi vt M N))
  I.trans (I.symm (NotLam.alleq.aux nl1)) (NotLam.alleq.aux nl2)

Definition Term.caseLam = \C:(Term -> U1)
  \caselam :(vt:VarType -> M:Term -> N:Term -> C (Term.lam vt M N))
  \caseelse:({t:Term} -> NotLam t -> C t) ->
  Term.rec (\t:Term -> C t)
    (\vt:VarType \M:Term \_:C M \N:Term \_:C N -> caselam vt M N)
    (\vt:VarType \M:Term \_:C M \N:Term \_:C N -> caseelse (NotLam.pi vt M N))
    (\M:Term \_:C M \N:Term \_:C N -> caseelse (NotLam.app M N))
    (\vt:VarType \n:Nat -> caseelse (NotLam.var vt n))
    (\vt:VarType -> caseelse (NotLam.univ vt))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Definition Normalize.redk =
  Let Thesis = (\t:Term ->
    SN (SN.redk t) -> SN (SN.redk.arg t) -> SN t)
  Term.rec Thesis
    ;lam
    (\vt:VarType \m:Term \_:Thesis m \n:Term \_:Thesis n
     \sn1:SN (Term.lam vt m n) \sn2:SN (Term.lam vt m n) -> sn1)
    ;pi
    (\vt:VarType \m:Term \_:Thesis m \n:Term \_:Thesis n
     \sn1:SN (Term.pi vt m n) \sn2:SN (Term.pi vt m n) -> sn1)
    ;app
    (\m:Term \_:Thesis m \n:Term \_:Thesis n
     \sn1:SN (SN.redk (Term.app m n)) \sn2:SN (SN.redk.arg (Term.app m n)) ->
     Let Th2 = (\m:Term -> SN(n:Term -> SN n -> SN (Term.app m n))
     Term.rec Th2
        ;lam
        (\vt:VarType \m1:Term \_:Th2 m1 \m2:Term \_:Th2 m2
	 \n:Term \sn:SN n ->
	 Assume SN (Term.app (Term.lam vt m1 m2) n))
        ;pi
        (\vt:VarType \m1:Term \Hyp1:Th2 m1 \m2:Term \Hyp2:Th2 m2
	 \n:Term \sn:SN n ->
	 Hyp1 
	 Assume SN (Term.app (Term.pi vt m1 m2) n))
        ;lam
        (\vt:VarType \m1:Term \_:Th2 m1 \m2:Term \_:Th2 m2
	 \n:Term \sn:SN n ->
	 Assume SN (Term.app (Term.lam vt m1 m2) n))
        ;lam
        (\vt:VarType \m1:Term \_:Th2 m1 \m2:Term \_:Th2 m2
	 \n:Term \sn:SN n ->
	 Assume SN (Term.app (Term.lam vt m1 m2) n))
	
	()
	
     	SN (SN
  case t=app mn
    Hyp: Normalize (redk m) m' -> SN redk.arg t -> Normalize m m'
    case NotLam t,  Normalize (redk t) t':
      applam: (redk t):
        (redk t) = app (redk m) n
        Normalize (redk m) lam m1 m2
	Normalize n n'
	Normalize (Term.subst m2 n') t'
	Hyp: Normalize m (lam m1 m2)
	--> Normalize.applam , finished
      app:
        Normalize (redk m) m', Normalize n n', NotLam m'
	Hyp: Normalize m m'
	--> Thesis with Normalize.app, finished
    case t=lam m1 m2, case Normalize (redk t) t'
      
        case m' = lam m1 m2 ->
	   Normalize (Term.subst m2 n') z  --> 
	   Normalize (redk t) z



(Term.substn (Term.lam vt M11' M12')))

(SN.destruct (SN.arg1 snMN'')))
	 (Hyp2 n (SN.destruct (SN.arg2 snMN'')))) ->
     I.subst (SN.case.eq (SN.sn nMN'))
        (\x:SN (Term.substn (Term.pi vt M1' M2') n N') ->
	  Normalize (Term.substn (Term.pi vt M1 M2) n N)
	  	    (SN.normalize x))
	nMN)
    ;app
    (\M1:Term \M1':Term \nM1:Normalize M1 M1' \Hyp1:Thesis nM1
     \M2:Term \M2':Term \nM2:Normalize M2 M2' \Hyp2:Thesis nM2
     \n:Nat \M'':Term
     \nMN':Normalize (Term.substn (Term.pi vt M1' M2') n N') M'' ->
     Let snMN'' = SN.case (SN.sn nMN') ->
     Let nMN = (Normalize.pi vt (Hyp1 n (SN.destruct (SN.arg1 snMN'')))
     		   	     (Hyp2 (Nat.s n) (SN.destruct (SN.arg2 snMN'')))) ->
     I.subst (SN.case.eq (SN.sn nMN'))
        (\x:SN (Term.substn (Term.pi vt M1' M2') n N') ->
	  Normalize (Term.substn (Term.pi vt M1 M2) n N)
	  	    (SN.normalize x))
	nMN)
   
	
Definition Normalize.subst				
