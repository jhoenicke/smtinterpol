;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Equality Type

; Now we create the Identity type to express equalities.
Inductive Id : A:U -> a:A -> b:A -> U =
  refl : Id A a a
Evaluate Id

; The standard rules for substitution, symmetry and reverse substitution
Definition subst =
  \A:U \r:A \s:A \eq: (Id A r s)
  \C : (A -> U)
  Id.J A r (\x:A \eq: (Id A r x) C r -> C x) (\x:(C r) x) s eq

TypeCheck subst : A:U -> r:A -> s:A -> Id A r s -> C:(A -> U) -> C r -> C s

Definition symm =
  \A:U \r:A \s:A \eq: (Id A r s)
  subst A r s eq (\x:A Id A x r) (Id.refl A r)

TypeCheck symm : A:U -> r:A -> s:A -> Id A r s -> Id A s r

Definition rsubst =
  \A:U \r:A \s:A \eq: (Id A s r)
  subst A r s (symm A s r eq)

TypeCheck rsubst : A:U -> r:A -> s:A -> Id A s r -> C:(A -> U) -> C r -> C s

Definition trans =
  \A:U \r:A \s:A \t:A \eq1: (Id A r s) \eq2: (Id A s t)
  subst A s t eq2 (\x:A Id A r x) eq1

TypeCheck trans : A:U -> r:A -> s:A -> t:A -> Id A r s -> Id A s t -> Id A r t

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Natural Numbers

Inductive Nat : U =
   0    : Nat,
   succ : Nat -> Nat
Evaluate Nat

Definition Nat.plus =
  \a:Nat \b:Nat Nat.J (\n:Nat Nat) a (\n:Nat \r:Nat Nat.succ r) b
Definition Nat.mul =
  \a:Nat \b:Nat Nat.J (\n:Nat Nat) Nat.0 (\n:Nat \r:Nat (Nat.plus r a)) b
Definition Nat.mul2 =
  \a:Nat Nat.J (\n:Nat Nat) Nat.0 (\n:Nat \r:Nat Nat.succ (Nat.succ r)) a

; prove n = 0 + n
Definition Nat.plus.symm0 =
  Nat.J (\n:Nat Id Nat n (Nat.plus Nat.0 n))
         (Id.refl Nat Nat.0)
         (\n:Nat \r:(Id Nat n (Nat.plus Nat.0 n))
            subst Nat n (Nat.plus Nat.0 n) r
                  (\x:Nat Id Nat (Nat.succ n) (Nat.succ x))
                  (Id.refl Nat (Nat.succ n)))
TypeCheck Nat.plus.symm0 : n:Nat -> Id Nat n (Nat.plus Nat.0 n)

; prove succ(m + n) = (succ m) + n
Definition Nat.plus.symmstep =
  \m:Nat Nat.J (\n:Nat Id Nat (Nat.succ (Nat.plus m n)) (Nat.plus (Nat.succ m) n))
         (Id.refl Nat (Nat.succ m))
         (\n:Nat \r:(Id Nat (Nat.succ (Nat.plus m n)) (Nat.plus (Nat.succ m) n))
            subst Nat (Nat.succ (Nat.plus m n)) (Nat.plus (Nat.succ m) n) r
                  (\x:Nat Id Nat (Nat.succ (Nat.succ (Nat.plus m n))) (Nat.succ x))
                  (Id.refl Nat (Nat.succ (Nat.succ (Nat.plus m n)))))

TypeCheck Nat.plus.symmstep : m:Nat -> n:Nat ->
                     Id Nat (Nat.succ (Nat.plus m n)) (Nat.plus (Nat.succ m) n)

; Now prove m + n = n + m
Definition Nat.plus.symm =
  Nat.J (\m:Nat n:Nat -> Id Nat (Nat.plus n m) (Nat.plus m n))
        Nat.plus.symm0
        (\m:Nat \r:(n:Nat -> Id Nat (Nat.plus n m) (Nat.plus m n))
          \n:Nat rsubst Nat (Nat.plus m n) (Nat.plus n m) (r n)
               (\x:Nat Id Nat (Nat.succ x) (Nat.plus (Nat.succ m) n))
               (Nat.plus.symmstep m n))

TypeCheck Nat.plus.symm : m:Nat -> n:Nat -> Id Nat (Nat.plus n m) (Nat.plus m n)

Definition Nat.plus.assoc = \a:Nat \b:Nat
  Nat.J (\c:Nat Id Nat (Nat.plus (Nat.plus a b) c) (Nat.plus a (Nat.plus b c)))
     (Id.refl Nat (Nat.plus a b))
     (\c:Nat
      \hyp:(Id Nat (Nat.plus (Nat.plus a b) c) (Nat.plus a (Nat.plus b c)))
      subst Nat (Nat.plus (Nat.plus a b) c) (Nat.plus a (Nat.plus b c))
            hyp
	    (\x:Nat Id Nat (Nat.succ (Nat.plus (Nat.plus a b) c)) (Nat.succ x))
            (Id.refl Nat (Nat.succ (Nat.plus (Nat.plus a b) c))))

TypeCheck Nat.plus.assoc : a:Nat -> b:Nat -> c:Nat ->
                      Id Nat (Nat.plus (Nat.plus a b) c)
                             (Nat.plus a (Nat.plus b c))
Definition Nat.plus.assoc4 = \a:Nat \b:Nat \c:Nat \d:Nat
  trans Nat (Nat.plus (Nat.plus a b) (Nat.plus c d))
                (Nat.plus a (Nat.plus b (Nat.plus c d)))
                (Nat.plus a (Nat.plus (Nat.plus b c) d))
            (Nat.plus.assoc a b (Nat.plus c d))
	    (rsubst Nat (Nat.plus b (Nat.plus c d))
                        (Nat.plus (Nat.plus b c) d)
	                (Nat.plus.assoc b c d)
                   (\x:Nat Id Nat (Nat.plus a (Nat.plus b (Nat.plus c d)))
                              (Nat.plus a x))
                   (Id.refl Nat (Nat.plus a (Nat.plus b (Nat.plus c d)))))

Definition Nat.plus.symmassoc = \a:Nat \b:Nat \c:Nat \d:Nat
  trans Nat (Nat.plus (Nat.plus a b) (Nat.plus c d))
            (Nat.plus a (Nat.plus (Nat.plus b c) d))
            (Nat.plus (Nat.plus a c) (Nat.plus b d))
    (Nat.plus.assoc4 a b c d)
    (subst Nat (Nat.plus c b) (Nat.plus b c) (Nat.plus.symm b c)
          (\x:Nat Id Nat (Nat.plus a (Nat.plus x d))
                      (Nat.plus (Nat.plus a c) (Nat.plus b d)))
      (symm Nat (Nat.plus (Nat.plus a c) (Nat.plus b d))
                (Nat.plus a (Nat.plus (Nat.plus c b) d))
          (Nat.plus.assoc4 a c b d)))

TypeCheck Nat.plus.symmassoc : a:Nat -> b:Nat -> c:Nat -> d:Nat ->
  Id Nat (Nat.plus (Nat.plus a b) (Nat.plus c d))
           (Nat.plus (Nat.plus a c) (Nat.plus b d))

Definition Nat.mul2.distr = \a:Nat
  Nat.J
    (\b:Nat Id Nat (Nat.plus (Nat.mul2 a) (Nat.mul2 b))
                   (Nat.mul2 (Nat.plus a b)))
    (Id.refl Nat (Nat.mul2 a))
    (\b:Nat \Hyp:(Id Nat (Nat.plus (Nat.mul2 a) (Nat.mul2 b))
                         (Nat.mul2 (Nat.plus a b)))
      (rsubst Nat
	      (Nat.mul2 (Nat.plus a b))
	      (Nat.plus (Nat.mul2 a) (Nat.mul2 b))
             Hyp
             (\x:Nat Id Nat (Nat.succ (Nat.succ x))
                      (Nat.succ (Nat.succ (Nat.mul2 (Nat.plus a b)))))
             (Id.refl Nat (Nat.succ (Nat.succ (Nat.mul2 (Nat.plus a b)))))))

TypeCheck Nat.mul2.distr : a:Nat -> b:Nat ->
  Id Nat (Nat.plus (Nat.mul2 a) (Nat.mul2 b)) (Nat.mul2 (Nat.plus a b))

Definition Nat.plus.assocsymm2 = \a:Nat \b:Nat \c:Nat
  rsubst Nat (Nat.plus a (Nat.plus c b)) (Nat.plus (Nat.plus a c) b)
     (Nat.plus.assoc a c b)
     (\x:Nat Id Nat (Nat.plus (Nat.plus a b) c) x)
     (subst Nat (Nat.plus b c) (Nat.plus c b) (Nat.plus.symm c b)
        (\x:Nat Id Nat (Nat.plus (Nat.plus a b) c)
                       (Nat.plus a x))
        (Nat.plus.assoc a b c))

Definition Nat.mul.symm0 =
  Nat.J (\a:Nat Id Nat (Nat.mul Nat.0 a) Nat.0)
    (Id.refl Nat Nat.0) 
    (\a:Nat \Hyp:(Id Nat (Nat.mul Nat.0 a) Nat.0) Hyp)

Definition Nat.mul.symmstep = \b:Nat
  Nat.J (\a:Nat Id Nat (Nat.mul (Nat.succ b) a) (Nat.plus (Nat.mul b a) a))
    (Id.refl Nat Nat.0) 
    (\a:Nat \Hyp:(Id Nat (Nat.mul (Nat.succ b) a) (Nat.plus (Nat.mul b a) a))
     subst Nat
       (Nat.plus (Nat.plus (Nat.mul b a) a) b)
       (Nat.plus (Nat.plus (Nat.mul b a) b) a)
       (Nat.plus.assocsymm2 (Nat.mul b a) a b)
       (\x:Nat 
         Id Nat (Nat.succ (Nat.plus (Nat.mul (Nat.succ b) a) b))
                (Nat.succ x))
       (subst Nat (Nat.mul (Nat.succ b) a) (Nat.plus (Nat.mul b a) a) Hyp
         (\x:Nat 
           Id Nat (Nat.succ (Nat.plus (Nat.mul (Nat.succ b) a) b))
                  (Nat.succ (Nat.plus x b)))
         (Id.refl Nat (Nat.succ (Nat.plus (Nat.mul (Nat.succ b) a) b)))))

Definition Nat.mul.symm = \a:Nat
  Nat.J (\b:Nat Id Nat (Nat.mul b a) (Nat.mul a b))
    (Nat.mul.symm0 a)
    (\b:Nat \Hyp:(Id Nat (Nat.mul b a) (Nat.mul a b))
     subst Nat (Nat.mul b a) (Nat.mul a b) Hyp
       (\x:Nat Id Nat (Nat.mul (Nat.succ b) a) (Nat.plus x a))
       (Nat.mul.symmstep b a)) 

Definition Nat.mul.distrib = \a:Nat \b:Nat
  Nat.J (\c:Nat Id Nat (Nat.mul (Nat.plus a b) c) 
                       (Nat.plus (Nat.mul a c) (Nat.mul b c)))
    (Id.refl Nat Nat.0)
    (\c:Nat \Hyp:(Id Nat (Nat.mul (Nat.plus a b) c) 
                         (Nat.plus (Nat.mul a c) (Nat.mul b c)))
     rsubst Nat 
       (Nat.plus (Nat.mul a c) (Nat.mul b c))
       (Nat.mul (Nat.plus a b) c) 
       Hyp
       (\x:Nat Id Nat (Nat.plus x (Nat.plus a b))
            (Nat.plus (Nat.plus (Nat.mul a c) a) (Nat.plus (Nat.mul b c) b)))
       (Nat.plus.symmassoc (Nat.mul a c) (Nat.mul b c) a b))

Definition Nat.mul.distrib2 = \a:Nat \b:Nat \c:Nat
  subst Nat
    (Nat.mul (Nat.plus b c) a)
    (Nat.mul a (Nat.plus b c))
    (Nat.mul.symm a (Nat.plus b c))
    (\x:Nat Id Nat x (Nat.plus (Nat.mul a b) (Nat.mul a c)))
    (subst Nat (Nat.mul b a) (Nat.mul a b) (Nat.mul.symm a b)
        (\x:Nat Id Nat (Nat.mul (Nat.plus b c) a)
	               (Nat.plus x (Nat.mul a c)))
        (subst Nat (Nat.mul c a) (Nat.mul a c) (Nat.mul.symm a c)
	   (\x:Nat Id Nat (Nat.mul (Nat.plus b c) a)
	               (Nat.plus (Nat.mul b a) x))
           (Nat.mul.distrib b c a)))
	   
Definition Nat.mul.assoc = \a:Nat \b:Nat
  Nat.J (\c:Nat Id Nat (Nat.mul (Nat.mul a b) c) (Nat.mul a (Nat.mul b c)))
    (Id.refl Nat Nat.0)
    (\c:Nat \Hyp:(Id Nat (Nat.mul (Nat.mul a b) c) (Nat.mul a (Nat.mul b c)))
     ;; Id (Nat.plus (Nat.mul a (....) (Nat.mul a b)))
     ;;    (Nat.mul a (Nat.plus (....) b))
     rsubst Nat 
       (Nat.mul a (Nat.mul b c))
       (Nat.mul (Nat.mul a b) c)
       Hyp
       (\x:Nat Id Nat (Nat.plus x (Nat.mul a b))
                      (Nat.mul a (Nat.plus (Nat.mul b c) b)))
       (symm Nat
          (Nat.mul a (Nat.plus (Nat.mul b c) b))
	  (Nat.plus (Nat.mul a (Nat.mul b c)) (Nat.mul a b))
          (Nat.mul.distrib2 a (Nat.mul b c) b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Binary Numbers

Inductive Bin : U =
   nil : Bin,
   0   : Bin -> Bin,
   1   : Bin -> Bin
Evaluate Bin

Inductive Carry: U =
   0 : Carry,
   1 : Carry

Definition Bin.addcarry =
   Bin.J (\x:Bin Carry -> Bin)
         (Carry.J (\x:Carry Bin) Bin.nil (Bin.1 Bin.nil))
         (\a:Bin \r:(Carry -> Bin)
	   (Carry.J (\x:Carry Bin) (Bin.0 a) (Bin.1 a)))
         (\a:Bin \r:(Carry -> Bin)
	   (Carry.J (\x:Carry Bin) (Bin.1 a) (Bin.0 (r Carry.1))))
TypeCheck Bin.addcarry : Bin -> Carry -> Bin

Definition Bin.strip0.aux = \b:Bin
   Bin.J (\x:Bin Bin) Bin.nil
      (\x:Bin \r:Bin Bin.0 b)
      (\x:Bin \r:Bin Bin.0 b)
      b
Definition Bin.strip0 =
   Bin.J (\x:Bin Bin) Bin.nil
      (\x:Bin \r:Bin (Bin.strip0.aux r))
      (\x:Bin \r:Bin Bin.1 r)

Definition bin2nat =
   Bin.J (\x:Bin Nat) Nat.0 (\b:Bin \r:Nat Nat.mul2 r)
                            (\b:Bin \r:Nat Nat.succ (Nat.mul2 r))

Inductive BinId : a:Bin -> b:Bin -> U =
   embed : Id Nat (bin2nat a) (bin2nat b) -> BinId a b

Definition BinId.refl = \a:Bin BinId.embed a a (Id.refl Nat (bin2nat a))
Definition BinId.id   = \a:Bin \b:Bin
   BinId.J a b (\id:(BinId a b) Id Nat (bin2nat a) (bin2nat b))
      (\id: (Id Nat (bin2nat a) (bin2nat b)) id)
Definition BinId.trans = \a:Bin \b:Bin \c:Bin
   \eq1:(BinId a b) \eq2:(BinId b c)
   BinId.embed a c
     (rsubst Nat (bin2nat b) (bin2nat a) (BinId.id a b eq1)
       (\x:Nat Id Nat x (bin2nat c))
       (BinId.id b c eq2))
Definition BinId.ext0 = \a:Bin \b:Bin \eq:(BinId a b)
   BinId.embed (Bin.0 a) (Bin.0 b)
     (subst Nat (bin2nat a) (bin2nat b) (BinId.id a b eq)
       (\x:Nat Id Nat (Nat.mul2 (bin2nat a)) (Nat.mul2 x))
       (Id.refl Nat (Nat.mul2 (bin2nat a))))
Definition BinId.ext1 = \a:Bin \b:Bin \eq:(BinId a b)
   BinId.embed (Bin.1 a) (Bin.1 b)
     (subst Nat (bin2nat a) (bin2nat b) (BinId.id a b eq)
       (\x:Nat Id Nat (Nat.succ (Nat.mul2 (bin2nat a))) (Nat.succ (Nat.mul2 x)))
       (Id.refl Nat (Nat.succ (Nat.mul2 (bin2nat a)))))
 
Definition Bin.strip0.aux.eq =
   Bin.J (\a:Bin BinId (Bin.strip0.aux a) (Bin.0 a))
     (BinId.embed Bin.nil (Bin.0 Bin.nil) (Id.refl Nat Nat.0))
     (\a:Bin \r:(BinId (Bin.strip0.aux a) (Bin.0 a))
      BinId.refl (Bin.0 (Bin.0 a)))
     (\a:Bin \r:(BinId (Bin.strip0.aux a) (Bin.0 a))
      BinId.refl (Bin.0 (Bin.1 a)))

Definition Bin.strip0.eq =
   Bin.J (\a:Bin BinId (Bin.strip0 a) a)
     (BinId.embed Bin.nil Bin.nil (Id.refl Nat Nat.0))
     (\a:Bin \Hyp:(BinId (Bin.strip0 a) a)
       BinId.trans (Bin.strip0.aux (Bin.strip0 a)) 
                   (Bin.0 (Bin.strip0 a))
		   (Bin.0 a)
		   (Bin.strip0.aux.eq (Bin.strip0 a))
		   (BinId.ext0 (Bin.strip0 a) a Hyp))
     (\a:Bin \Hyp:(BinId (Bin.strip0 a) a)
       BinId.ext1 (Bin.strip0 a) a Hyp)

TypeCheck Bin.strip0.eq : a:Bin -> BinId (Bin.strip0 a) a

Definition Nat.addcarry = \n:Nat
   Carry.J (\x:Carry Nat) n (Nat.succ n)

Definition Bin.addcarry.correct =
   Bin.J (\x:Bin c:Carry -> Id Nat (bin2nat (Bin.addcarry x c))
                                 (Nat.addcarry (bin2nat x) c))
         (Carry.J (\c:Carry Id Nat (bin2nat (Bin.addcarry Bin.nil c))
                                 (Nat.addcarry (bin2nat Bin.nil) c))
                  (Id.refl Nat Nat.0) (Id.refl Nat (Nat.succ Nat.0)))
         (\a:Bin \r:(c:Carry -> Id Nat (bin2nat (Bin.addcarry a c))
                                 (Nat.addcarry (bin2nat a) c))
          (Carry.J (\c:Carry Id Nat (bin2nat (Bin.addcarry (Bin.0 a) c))
                                 (Nat.addcarry (bin2nat (Bin.0 a)) c))
	     (Id.refl Nat (Nat.mul2 (bin2nat a)))
	     (Id.refl Nat (Nat.succ (Nat.mul2 (bin2nat a))))))
         (\a:Bin \r:(c:Carry -> Id Nat (bin2nat (Bin.addcarry a c))
                                 (Nat.addcarry (bin2nat a) c))
          (Carry.J (\c:Carry Id Nat (bin2nat (Bin.addcarry (Bin.1 a) c))
                                 (Nat.addcarry (bin2nat (Bin.1 a)) c))
	     (Id.refl Nat (Nat.succ (Nat.mul2 (bin2nat a))))
	     (rsubst Nat (Nat.addcarry (bin2nat a) Carry.1)
                         (bin2nat (Bin.addcarry a Carry.1))
			 (r Carry.1)
			 (\x:Nat Id Nat (Nat.mul2 x)
                                  (Nat.succ (Nat.succ (Nat.mul2 (bin2nat a)))))
		    (Id.refl Nat (Nat.succ (Nat.succ (Nat.mul2 (bin2nat a))))))))

TypeCheck Bin.addcarry.correct : a:Bin -> c:Carry ->
   Id Nat (bin2nat (Bin.addcarry a c)) (Nat.addcarry (bin2nat a) c)


Definition nat2bin = Nat.J (\n:Nat Bin) 
   Bin.nil 
   (\n:Nat \r:Bin (Bin.addcarry r Carry.1))

Definition nat2bin.correct = Bin.J (\b:Bin BinId (nat2bin (bin2nat b)) b)
   (BinId.refl Bin.nil)


Definition Bin.carry2bin = Carry.J (\x:Carry Bin -> Bin) Bin.0 Bin.1
Definition Bin.negcarry2bin = Carry.J (\x:Carry Bin -> Bin) Bin.1 Bin.0

Definition Bin.pluscarrycase0 = \a:Bin \add:(Bin -> Carry -> Bin)
                                \b:Bin \carry:Carry
    Bin.J (\x:Bin Bin)
         (Bin.addcarry (Bin.0 a) carry)
	 (\b:Bin \r2:Bin
	    (Bin.carry2bin carry) (add b Carry.0))   ; 0+0+carry
	 (\b:Bin \r2:Bin
	    (Bin.negcarry2bin carry) (add b carry))  ; 0+1+carry
         b

Definition Bin.pluscarrycase1 = \a:Bin \add:(Bin -> Carry -> Bin)
                                \b:Bin \carry:Carry
     Bin.J (\x:Bin Bin)
         (Bin.addcarry (Bin.1 a) carry)
	 (\b:Bin \r2:Bin
	    (Bin.negcarry2bin carry) (add b carry))  ; 1+0+carry
	 (\b:Bin \r2:Bin
	    (Bin.carry2bin carry) (add b Carry.1))   ; 1+1+carry
         b

Definition Bin.pluscarry =
   Bin.J (\x:Bin Bin -> Carry -> Bin)
         (\b:Bin \carry:Carry Bin.addcarry b carry)
	 Bin.pluscarrycase0
	 Bin.pluscarrycase1

Definition Bin.plus = \a:Bin \b:Bin Bin.pluscarry a b Carry.0

TypeCheck Bin.plus : a:Bin -> b:Bin -> Bin

; compute 23 + 17
Evaluate Bin.plus (Bin.1 (Bin.1 (Bin.1 (Bin.0 (Bin.1 (Bin.nil))))))
	          (Bin.1 (Bin.0 (Bin.0 (Bin.0 (Bin.1 (Bin.nil))))))

; compute 14 + 343
Evaluate Bin.plus (Bin.0 (Bin.1 (Bin.1 (Bin.1 Bin.nil))))
                  (Bin.1 (Bin.1 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.nil))))))))))

Definition Bin.carry2bin.correct = \a:Bin
  Carry.J (\c:Carry Id Nat (bin2nat ((Bin.carry2bin c) a))
	  (Nat.addcarry (Nat.mul2 (bin2nat a)) c))
          (Id.refl Nat (Nat.mul2 (bin2nat a)))
	  (Id.refl Nat (Nat.succ (Nat.mul2 (bin2nat a))))

TypeCheck Bin.carry2bin.correct : (a:Bin -> c:Carry ->
  Id Nat (bin2nat ((Bin.carry2bin c) a))
         (Nat.addcarry (Nat.mul2 (bin2nat a)) c))

Definition Bin.pluscarrycase0.correct =
  \a:Bin \add:(Bin -> Carry -> Bin)
  \Hyp: (b:Bin -> c:Carry ->
         Id Nat (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c))
  \b:Bin \c:Carry
  Bin.J (\b:Bin
         Id Nat (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                           (bin2nat b)) c))
         (Bin.addcarry.correct (Bin.0 a) c)
        (\b:Bin \_:(Id Nat (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                           (bin2nat b)) c))
	 (rsubst Nat (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))
                    (Nat.plus (Nat.mul2 (bin2nat a)) (bin2nat (Bin.0 b))))
           (Nat.mul2.distr (bin2nat a) (bin2nat b))
	   (\x:Nat Id Nat (bin2nat ((Bin.carry2bin c) (add b Carry.0)))
                       (Nat.addcarry x c))
	     (subst Nat (bin2nat (add b Carry.0))
                   (Nat.plus (bin2nat a) (bin2nat b))
	           (Hyp b Carry.0)
	      (\x:Nat Id Nat (bin2nat ((Bin.carry2bin c) (add b Carry.0)))
                          (Nat.addcarry (Nat.mul2 x) c))
              (Bin.carry2bin.correct (add b Carry.0) c)))
        (\b:Bin \_:(Id Nat (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                           (bin2nat b)) c))
         Carry.J (\c:Carry Id Nat (bin2nat ((Bin.negcarry2bin c) (add b c)))
                   (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
                                 (Nat.succ (Nat.mul2 (bin2nat b)))) c))
             (rsubst Nat
                   (Nat.plus (bin2nat a) (bin2nat b))
		   (bin2nat (add b Carry.0))
                   (Hyp b Carry.0)
               (\x:Nat Id Nat (Nat.succ (Nat.mul2 x))
                          (Nat.succ (Nat.plus (Nat.mul2 (bin2nat a))
			                      (Nat.mul2 (bin2nat b)))))
                  (rsubst Nat (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))
                             (Nat.plus (Nat.mul2 (bin2nat a)) (Nat.mul2 (bin2nat b)))
                  (Nat.mul2.distr (bin2nat a) (bin2nat b))
                  (\x:Nat Id Nat (Nat.succ (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))) (Nat.succ x))
		  (Id.refl Nat (Nat.succ (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))))
                  ))
             (rsubst Nat
                   (Nat.plus (bin2nat a) (Nat.succ (bin2nat b)))
		   (bin2nat (add b Carry.1))
                   (Hyp b Carry.1)
               (\x:Nat Id Nat (Nat.mul2 x)
                      (Nat.succ (Nat.succ (Nat.plus (Nat.mul2 (bin2nat a))
		                (Nat.mul2 (bin2nat b))))))
                  (rsubst Nat (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))
                     (Nat.plus (Nat.mul2 (bin2nat a)) (Nat.mul2 (bin2nat b)))
                     (Nat.mul2.distr (bin2nat a) (bin2nat b))
                  (\x:Nat Id Nat (Nat.mul2 (Nat.succ (Nat.plus (bin2nat a) (bin2nat b)))) (Nat.succ (Nat.succ x)))
		  (Id.refl Nat (Nat.succ (Nat.succ (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b))))))))
              c) b

TypeCheck Bin.pluscarrycase0.correct :
  a:Bin -> add:(Bin -> Carry -> Bin) ->
  Hyp: (b:Bin -> c:Carry ->
         Id Nat (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c)) ->
  b: Bin -> c:Carry ->
         Id Nat (bin2nat (Bin.pluscarrycase0 a add b c))
           (Nat.addcarry (Nat.plus (Nat.mul2 (bin2nat a))
	                           (bin2nat b)) c)

Definition Bin.pluscarrycase1.correct =
  \a:Bin \add:(Bin -> Carry -> Bin)
  \Hyp: (b:Bin -> c:Carry ->
         Id Nat (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c))
  \b:Bin \c:Carry
  Bin.J (\b:Bin
         Id Nat (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c))
         (Bin.addcarry.correct (Bin.1 a) c)
        (\b:Bin \_:(Id Nat (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c))
         Carry.J (\c:Carry Id Nat (bin2nat ((Bin.negcarry2bin c) (add b c)))
                   (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
                                 (Nat.mul2 (bin2nat b))) c))
             (rsubst Nat
                   (Nat.plus (bin2nat a) (bin2nat b))
		   (bin2nat (add b Carry.0))
                   (Hyp b Carry.0)
               (\x:Nat Id Nat (Nat.succ (Nat.mul2 x))
                          (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
			                      (Nat.mul2 (bin2nat b))))
                (subst Nat
                          (Nat.succ (Nat.plus (Nat.mul2 (bin2nat a))
			                      (Nat.mul2 (bin2nat b))))
                          (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
			                      (Nat.mul2 (bin2nat b)))
			  (Nat.plus.symmstep (Nat.mul2 (bin2nat a))
			            (Nat.mul2 (bin2nat b)))
                  (\x:Nat Id Nat (Nat.succ (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b))))
                          x)
                  (rsubst Nat (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))
                             (Nat.plus (Nat.mul2 (bin2nat a)) (Nat.mul2 (bin2nat b)))
			     (Nat.mul2.distr (bin2nat a) (bin2nat b))
                  (\x:Nat Id Nat (Nat.succ (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))) (Nat.succ x))
		  (Id.refl Nat (Nat.succ (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))))
                  )))
             (rsubst Nat
                   (Nat.succ (Nat.plus (bin2nat a) (bin2nat b)))
		   (bin2nat (add b Carry.1))
                   (Hyp b Carry.1)
               (\x:Nat Id Nat (Nat.mul2 x)
                      (Nat.succ (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
		                (Nat.mul2 (bin2nat b)))))
		  ; Id Nat (succ (mul2 (plus a b)))
                  ;        (succ (plus (succ (mul2 a)) (mul2 b)))
	         (subst Nat
		    (Nat.succ (Nat.plus (Nat.mul2 (bin2nat a))
					(Nat.mul2 (bin2nat b))))
		    (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
			      (Nat.mul2 (bin2nat b)))
		    (Nat.plus.symmstep (Nat.mul2 (bin2nat a))
			      (Nat.mul2 (bin2nat b)))
		    (\x:Nat (Id Nat
				(Nat.mul2 (Nat.succ (Nat.plus (bin2nat a)
							      (bin2nat b))))
				(Nat.succ x)))
		    (rsubst Nat
		       (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))
		       (Nat.plus (Nat.mul2 (bin2nat a))
				 (Nat.mul2 (bin2nat b)))
		       (Nat.mul2.distr (bin2nat a) (bin2nat b))
		       (\x:Nat (Id Nat (Nat.mul2 (Nat.succ (Nat.plus (bin2nat a) (bin2nat b)))) (Nat.succ (Nat.succ x))))
		       (Id.refl Nat (Nat.mul2 (Nat.succ (Nat.plus (bin2nat a) (bin2nat b))))))))
	     c)
        (\b:Bin \_:(Id Nat (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c))
	 (subst Nat
	   (Nat.succ (Nat.plus (Nat.mul2 (bin2nat a)) (bin2nat (Bin.1 b))))
	   (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a))) (bin2nat (Bin.1 b)))
	   (Nat.plus.symmstep (Nat.mul2 (bin2nat a)) (bin2nat (Bin.1 b)))
	   (\x:Nat Id Nat (bin2nat ((Bin.carry2bin c) (add b Carry.1)))
                       (Nat.addcarry x c))
	   (rsubst Nat
	     (Nat.mul2 (Nat.plus (bin2nat a) (bin2nat b)))
	     (Nat.plus (Nat.mul2 (bin2nat a)) (Nat.mul2 (bin2nat b)))
	     (Nat.mul2.distr (bin2nat a) (bin2nat b))
	     (\x:Nat Id Nat (bin2nat ((Bin.carry2bin c) (add b Carry.1)))
                       (Nat.addcarry (Nat.succ (Nat.succ x)) c))
	     (subst Nat (bin2nat (add b Carry.1))
                   (Nat.succ (Nat.plus (bin2nat a) (bin2nat b)))
	           (Hyp b Carry.1)
	      (\x:Nat Id Nat (bin2nat ((Bin.carry2bin c) (add b Carry.1)))
                          (Nat.addcarry (Nat.mul2 x) c))
	      (Bin.carry2bin.correct (add b Carry.1) c)))))
        b

TypeCheck Bin.pluscarrycase1.correct :
  a:Bin -> add:(Bin -> Carry -> Bin) ->
  Hyp: (b:Bin -> c:Carry ->
         Id Nat (bin2nat (add b c))
                (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c)) ->
  b: Bin -> c:Carry ->
         Id Nat (bin2nat (Bin.pluscarrycase1 a add b c))
           (Nat.addcarry (Nat.plus (Nat.succ (Nat.mul2 (bin2nat a)))
	                           (bin2nat b)) c)


Definition Bin.pluscarry.correct =
   Bin.J (\x:Bin y:Bin -> c:Carry -> Id Nat (bin2nat (Bin.pluscarry x y c))
                 (Nat.addcarry (Nat.plus (bin2nat x) (bin2nat y)) c))
	 (\y:Bin \c:Carry
            subst Nat (bin2nat y) (Nat.plus Nat.0 (bin2nat y))
               (Nat.plus.symm0 (bin2nat y))
               (\subst:Nat Id Nat (bin2nat (Bin.addcarry y c))
	                     (Nat.addcarry subst c))
	       (Bin.addcarry.correct y c))
	 (\x:Bin (Bin.pluscarrycase0.correct x (Bin.pluscarry x)))
	 (\x:Bin (Bin.pluscarrycase1.correct x (Bin.pluscarry x)))

TypeCheck Bin.pluscarry.correct : a:Bin -> b:Bin -> c:Carry ->
   Id Nat (bin2nat (Bin.pluscarry a b c))
          (Nat.addcarry (Nat.plus (bin2nat a) (bin2nat b)) c)


Definition Bin.mul10 = \a:Bin Bin.plus (Bin.0 a) (Bin.0 (Bin.0 (Bin.0 a)))
TypeCheck Bin.mul10 : Bin -> Bin

; compute 343 * 10
Evaluate Bin.mul10 (Bin.1 (Bin.1 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.0 (Bin.1 (Bin.nil))))))))))


Definition Bin.mul = \a:Bin
  Bin.J (\b:Bin Bin)
    Bin.nil
    (\b:Bin \mulab:Bin (Bin.0 mulab))
    (\b:Bin \mulab:Bin (Bin.plus (Bin.0 mulab) a))

Definition Bin.mul.correct.aux0 = \a:Nat
  Nat.J (\b:Nat Id Nat (Nat.plus (Nat.plus (Nat.mul2 a) b) b)
                       (Nat.mul2 (Nat.plus a b)))
    (Id.refl Nat (Nat.mul2 a))
    (\b:Nat \Hyp:(Id Nat (Nat.plus (Nat.plus (Nat.mul2 a) b) b)
                         (Nat.mul2 (Nat.plus a b)))
      (subst Nat
	 (Nat.succ (Nat.plus (Nat.plus (Nat.mul2 a) b) b))
         (Nat.plus (Nat.succ (Nat.plus (Nat.mul2 a) b)) b)
	 (Nat.plus.symmstep (Nat.plus (Nat.mul2 a) b) b)
	 (\x:Nat Id Nat (Nat.succ x)
                        (Nat.mul2 (Nat.plus a (Nat.succ b))))
      	 (rsubst Nat 
            (Nat.mul2 (Nat.plus a b))
	    (Nat.plus (Nat.plus (Nat.mul2 a) b) b)
	    Hyp
	    (\x:Nat Id Nat (Nat.succ (Nat.succ x))
	                   (Nat.mul2 (Nat.plus a (Nat.succ b))))
	    (Id.refl Nat (Nat.mul2 (Nat.plus a (Nat.succ b)))))))

TypeCheck Bin.mul.correct.aux0 : a:Nat -> b:Nat ->
   Id Nat (Nat.plus (Nat.plus (Nat.mul2 a) b) b) (Nat.mul2 (Nat.plus a b))

Definition Bin.mul.correct.aux1 = \a:Nat
  Nat.J (\b:Nat Id Nat (Nat.mul a (Nat.mul2 b)) (Nat.mul2 (Nat.mul a b)))
    (Id.refl Nat Nat.0)
    (\b:Nat \Hyp:(Id Nat (Nat.mul a (Nat.mul2 b)) (Nat.mul2 (Nat.mul a b)))
     rsubst Nat
       (Nat.mul2 (Nat.plus (Nat.mul a b) a))
       (Nat.plus (Nat.plus (Nat.mul a (Nat.mul2 b)) a) a)
       (rsubst Nat
       	 (Nat.mul2 (Nat.mul a b))
         (Nat.mul a (Nat.mul2 b))
	 Hyp
	 (\x:Nat Id Nat (Nat.plus (Nat.plus x a) a)
	                (Nat.mul2 (Nat.plus (Nat.mul a b) a)))
         (Bin.mul.correct.aux0 (Nat.mul a b) a))
       (\x:Nat Id Nat x (Nat.mul2 (Nat.plus (Nat.mul a b) a)))
       (Id.refl Nat (Nat.mul2 (Nat.plus (Nat.mul a b) a))))
TypeCheck Bin.mul.correct.aux1 : a:Nat -> b:Nat ->
   Id Nat (Nat.mul a (Nat.mul2 b)) (Nat.mul2 (Nat.mul a b))

Definition Bin.mul.correct = \a:Bin
  Bin.J
    (\b:Bin Id Nat (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b)))
    (Id.refl Nat Nat.0)
    (\b:Bin 
     \Hyp:(Id Nat (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b)))
     (rsubst Nat
        (Nat.mul (bin2nat a) (bin2nat b))
        (bin2nat (Bin.mul a b))
	Hyp
	(\x:Nat Id Nat (Nat.mul2 x)
	               (Nat.mul (bin2nat a) (Nat.mul2 (bin2nat b))))
        (symm Nat (Nat.mul (bin2nat a) (Nat.mul2 (bin2nat b)))
	          (Nat.mul2 (Nat.mul (bin2nat a) (bin2nat b)))
		  (Bin.mul.correct.aux1 (bin2nat a) (bin2nat b)))))
    (\b:Bin 
     \Hyp:(Id Nat (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b)))
     ;; Id Nat (bin2nat (Bin.plus (Bin.0 (Bin.mul a b)) a))
     ;;    (Nat.plus (Nat.mul (bin2nat a) (Nat.mul2 (bin2nat b))) (bin2nat a))
     (rsubst Nat
	(Nat.mul2 (Nat.mul (bin2nat a) (bin2nat b)))
        (Nat.mul (bin2nat a) (Nat.mul2 (bin2nat b)))
	(Bin.mul.correct.aux1 (bin2nat a) (bin2nat b))
	(\x:Nat Id Nat (bin2nat (Bin.plus (Bin.0 (Bin.mul a b)) a))
	               (Nat.plus x (bin2nat a)))
        (rsubst Nat
	   (Nat.plus (bin2nat (Bin.0 (Bin.mul a b))) (bin2nat a))
           (bin2nat (Bin.plus (Bin.0 (Bin.mul a b)) a))
	   (Bin.pluscarry.correct (Bin.0 (Bin.mul a b)) a Carry.0)
	   (\x:Nat Id Nat x 
              (Nat.plus (Nat.mul2 (Nat.mul (bin2nat a) (bin2nat b))) 
                        (bin2nat a)))
	   (subst Nat
              (bin2nat (Bin.mul a b))
	      (Nat.mul (bin2nat a) (bin2nat b))
	      Hyp
	      (\x:Nat Id Nat 
	         (Nat.plus (Nat.mul2 (bin2nat (Bin.mul a b))) (bin2nat a))
		 (Nat.plus (Nat.mul2 x) (bin2nat a)))
              (Id.refl Nat (Nat.plus (Nat.mul2 (bin2nat (Bin.mul a b))) (bin2nat a)))))))

TypeCheck Bin.mul.correct : a:Bin -> b:Bin ->
   Id Nat (bin2nat (Bin.mul a b)) (Nat.mul (bin2nat a) (bin2nat b))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Decimal Numbers

Inductive Dec : U =
   nil : Dec,
   0   : Dec -> Dec,
   1   : Dec -> Dec,
   2   : Dec -> Dec,
   3   : Dec -> Dec,
   4   : Dec -> Dec,
   5   : Dec -> Dec,
   6   : Dec -> Dec,
   7   : Dec -> Dec,
   8   : Dec -> Dec,
   9   : Dec -> Dec

Evaluate Dec

Definition Dec.mul2 =
   Dec.J (\x:Dec Carry -> Dec) 
      (Carry.J (\c:Carry Dec) Dec.nil (Dec.1 Dec.nil))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.0 Dec.1 c) (r Carry.0))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.2 Dec.3 c) (r Carry.0))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.4 Dec.5 c) (r Carry.0))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.6 Dec.7 c) (r Carry.0))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.8 Dec.9 c) (r Carry.0))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.0 Dec.1 c) (r Carry.1))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.2 Dec.3 c) (r Carry.1))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.4 Dec.5 c) (r Carry.1))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.6 Dec.7 c) (r Carry.1))
      (\x:Dec \r:(Carry -> Dec) \c:Carry
         (Carry.J (\c:Carry Dec -> Dec) Dec.8 Dec.9 c) (r Carry.1))

Definition dec2bin =
   Dec.J (\x:Dec Bin) Bin.nil
      (\x:Dec \r:Bin Bin.mul10 r)
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.1 (Bin.nil)))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.0 (Bin.1 (Bin.nil))))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.1 (Bin.1 (Bin.nil))))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.0 (Bin.0 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.1 (Bin.0 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.0 (Bin.1 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.1 (Bin.1 (Bin.1 (Bin.nil)))))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.0 (Bin.0 (Bin.0 (Bin.1 (Bin.nil))))))
      (\x:Dec \r:Bin Bin.plus (Bin.mul10 r) (Bin.1 (Bin.0 (Bin.0 (Bin.1 (Bin.nil))))))

Definition bin2dec =
   Bin.J (\x:Bin Dec) Dec.nil
     (\x:Bin \r:Dec (Dec.mul2 r Carry.0))
     (\x:Bin \r:Dec (Dec.mul2 r Carry.1))

; strip leading zero from a decimal number
; this function converts nil to nil and everything else to (Dec.0 r).
Definition Dec.strip0.aux = \r:Dec 
  (\z:(Dec -> Dec -> Dec) Dec.J (\x:Dec Dec) Dec.nil z z z z z z z z z z r)
  (\_:Dec \_:Dec Dec.0 r)

Evaluate Dec.0
Inductive DecId : a:Dec -> b:Dec -> U =
  embed : BinId (dec2bin a) (dec2bin b) -> DecId a b
Evaluate Dec.1
TypeCheck (\a:Dec \b:Dec \id:(DecId a b)
  DecId.J a b (\x:(DecId a b) BinId (dec2bin a) (dec2bin b))
    (\eq:(BinId (dec2bin a) (dec2bin b)) eq) id) :
  a:Dec -> b:Dec -> id:DecId a b -> BinId (dec2bin a) (dec2bin b)
Definition DecId.refl = \a:Dec DecId.embed a a (BinId.refl (dec2bin a))

Definition Dec.strip0.aux.correct =
  Dec.J (\r:Dec DecId (Dec.strip0.aux r) (Dec.0 r))
     (DecId.embed Dec.nil (Dec.0 Dec.nil) 
        (BinId.embed Bin.nil (dec2bin (Dec.0 Dec.nil)) 
	   (Id.refl Nat Nat.0)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.0 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.1 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.2 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.3 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.4 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.5 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.6 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.7 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.8 r)))
     (\r:Dec \_:(DecId (Dec.strip0.aux r) (Dec.0 r))
      DecId.refl (Dec.0 (Dec.9 r)))

TypeCheck Dec.strip0.aux.correct : r:Dec ->
  DecId (Dec.strip0.aux r) (Dec.0 r)

Definition Dec.strip0 =
   Dec.J (\x:Dec Dec) Dec.nil
      (\x:Dec \r:Dec (Dec.strip0.aux r))
      (\x:Dec \r:Dec Dec.1 r)
      (\x:Dec \r:Dec Dec.2 r)
      (\x:Dec \r:Dec Dec.3 r)
      (\x:Dec \r:Dec Dec.4 r)
      (\x:Dec \r:Dec Dec.5 r)
      (\x:Dec \r:Dec Dec.6 r)
      (\x:Dec \r:Dec Dec.7 r)
      (\x:Dec \r:Dec Dec.8 r)
      (\x:Dec \r:Dec Dec.9 r)

Evaluate dec2bin (Dec.3 (Dec.4 (Dec.3 Dec.nil)))
Evaluate bin2dec (dec2bin (Dec.3 (Dec.4 (Dec.3 Dec.nil))))
Evaluate dec2bin (Dec.0 (Dec.3 (Dec.4 (Dec.3 Dec.nil))))
Evaluate dec2bin (Dec.1 (Dec.0 (Dec.3 (Dec.4 (Dec.3 Dec.nil)))))
Evaluate dec2bin (Dec.9 (Dec.1 (Dec.0 (Dec.3 (Dec.4 (Dec.3 Dec.nil))))))
Evaluate dec2bin (Dec.3 (Dec.9 (Dec.1 (Dec.0 (Dec.3 (Dec.4 (Dec.3 Dec.nil)))))))
Evaluate bin2dec (dec2bin (Dec.3 (Dec.9 (Dec.1 (Dec.0 (Dec.3 (Dec.4 (Dec.3 Dec.nil))))))))


Evaluate dec2bin (Dec.3 (Dec.9 (Dec.1 (Dec.0 (Dec.3 (Dec.4 (Dec.3 Dec.nil)))))))
;Evaluate dec2bin (Dec.1 (Dec.2 (Dec.3 (Dec.4 (Dec.5 (Dec.3 (Dec.9 (Dec.1 (Dec.0 (Dec.3 (Dec.4 (Dec.3 Dec.nil))))))))))))

Evaluate bin2dec (Bin.mul (dec2bin (Dec.5 Dec.nil)) (dec2bin (Dec.7 Dec.nil)))
Evaluate bin2dec (Bin.mul (dec2bin (Dec.5 (Dec.3 Dec.nil))) (dec2bin (Dec.7 (Dec.2 Dec.nil))))

