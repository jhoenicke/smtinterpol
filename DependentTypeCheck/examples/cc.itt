Definition Prop = U
Inductive T : Prop = tt:T
Inductive F : Prop =

Inductive * : A:U -> B:U -> U =
  p:A->B-> * A B
Definition *.1 = \A:U \B:U -> *.rec A B (\_:* A B -> A) (\a:A \_:B -> a)
Definition *.2 = \A:U \B:U -> *.rec A B (\_:* A B -> B) (\_:A \b:B -> b)

Inductive + : A:U -> B:U -> U =
  1: A -> + A B,
  2: B -> + A B
Definition +.case = \A:U\B:U\C:U \1:(A -> C) \2:(B -> C) ->
  +.rec A B (\_:+ A B -> C) 1 2

Inductive Sigma : A:U -> B:(A->U) -> U =
  p:a:A->b:(B a)-> Sigma A B
Definition Sigma.1 = \A:U \B:(A->U) ->
  Sigma.rec A B (\_:Sigma A B -> A) (\a:A \_:B a -> a)
Definition Sigma.2 = \A:U \B:(A->U) ->
  Sigma.rec A B (\p:Sigma A B -> B (Sigma.1 A B p)) (\a:A \b:B a -> b)

Inductive I : A:U -> a:A -> b:A -> U =
  r : I A a a

Definition I.symm = \A:U \a:A \b:A ->
  I.rec A a (\x:A \_: I A a x -> I A x a) (I.r A a) b
Definition I.subst = \A:U \a:A \b:A \eq:I A a b \C:(A -> U) ->
    I.rec A a (\x:A \_:I A a x -> C a -> C x)
      (\z:C a -> z) b eq
TypeCheck I.subst :
  A:U -> a:A -> b:A -> I A a b -> C:(A -> U) -> C a -> C b
Definition I.subst2 = \A:U \a1:A \a2:A \eq1:I A a1 a2
	              \B:U \b1:B \b2:B \eq2:I B b1 b2
		      \C:(A -> B -> U) ->
  I.subst B b1 b2 eq2 (\b:B -> C a1 b1 -> C a2 b)
    (I.subst A a1 a2 eq1 (\a:A -> C a b1))
TypeCheck I.subst2 :
  A:U -> a1:A -> a2:A -> I A a1 a2 ->
  B:U -> b1:B -> b2:B -> I B b1 b2 -> C:(A -> B -> U) -> C a1 b1 -> C a2 b2
Definition I.rsubst = \A:U \b:A \a:A \eq:I A a b \C:(A -> U) ->
    I.subst A b a (I.symm A a b eq) C
Definition I.cong = \A:U \B:U
  \c:(A -> B) \a:A \b:A \eq: I A a b ->
    I.subst A a b eq (\x:A -> I B (c a) (c x)) (I.r B (c a))
TypeCheck I.cong :
  A:U -> B:U -> c:(A -> B) -> a:A -> b:A -> I A a b -> I B (c a) (c b)
Definition I.cong2 = \A:U \B:U \C:U \f:(A->B->C)
  \a1:A \a2:A \eq1: I A a1 a2 \b1:B\b2:B \eq2: I B b1 b2 ->
  I.subst A a1 a2 eq1 (\x:A -> I C (f a1 b1) (f x b2))
    (I.cong B C (f a1) b1 b2 eq2)
TypeCheck I.cong2 :
  A:U -> B:U -> C:U -> f:(A -> B -> C) -> a1:A -> a2:A -> I A a1 a2 ->
  b1:B -> b2:B -> I B b1 b2 -> I C (f a1 b1) (f a2 b2)

Inductive Bool : U = tt:Bool, ff:Bool
Inductive Nat : U =
  0 : Nat,
  s : Nat -> Nat
Definition Nat.1 = Nat.s Nat.0

Definition Nat.plus = Nat.rec (\_:Nat -> Nat -> Nat)
    (\b:Nat -> b) (\a:Nat \rec:(Nat->Nat) \b:Nat -> Nat.s (rec b))

Definition Nat.plus.zero =
    Nat.rec (\a:Nat -> I Nat (Nat.plus a Nat.0) a)
       (I.r Nat Nat.0)
       (\a:Nat -> I.cong Nat Nat Nat.s (Nat.plus a Nat.0) a)
Definition Nat.s.plus.commutes = \a:Nat \b:Nat ->
    Nat.rec (\a:Nat -> I Nat (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)))
       (I.r Nat (Nat.s b))
       (\a:Nat \Hyp: I Nat (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)) ->
        I.subst Nat (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)) Hyp
	   (\x:Nat -> I Nat (Nat.s (Nat.s (Nat.plus a b))) (Nat.s x))
	   (I.r Nat (Nat.s (Nat.s (Nat.plus a b)))))
       a

Definition Nat.plus.commutes = \a:Nat ->
    Nat.rec (\b:Nat -> I Nat (Nat.plus a b) (Nat.plus b a))
       (Nat.plus.zero a)
       (\b:Nat \Hyp:I Nat (Nat.plus a b) (Nat.plus b a) ->
        I.subst Nat (Nat.plus a b) (Nat.plus b a) Hyp
	        (\x:Nat -> I Nat (Nat.plus a (Nat.s b)) (Nat.s x))
		(I.symm Nat (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b))
		        (Nat.s.plus.commutes a b)))

Definition Nat.iter = \A:U \f:(A->A) ->
  Nat.rec (\n:Nat -> A -> A) (\a:A -> a) (\_:Nat \rec:(A->A) \a:A -> f (rec a))
Definition Nat.iter.associative = \A:U \f:(A->A) \n:Nat \a:A ->
  Nat.rec (\n:Nat -> I A (Nat.iter A f (Nat.s n) a) (Nat.iter A f n (f a)))
    (I.r A (f a))
    (\n:Nat \Hyp:I A (Nat.iter A f (Nat.s n) a) (Nat.iter A f n (f a)) ->
     I.cong A A f (Nat.iter A f (Nat.s n) a) (Nat.iter A f n (f a)) Hyp)
    n
Definition Nat.iter.plus = \A:U \f:(A->A) \m:Nat \n:Nat \a:A ->
  Nat.rec (\m:Nat -> I A (Nat.iter A f m (Nat.iter A f n a))
                         (Nat.iter A f (Nat.plus m n) a))
    (I.r A (Nat.iter A f n a))
    (\m:Nat -> I.cong A A f (Nat.iter A f m (Nat.iter A f n a))
                            (Nat.iter A f (Nat.plus m n) a))
    m

Definition Nat.iter.g.commutes = \A:U \f:(A->A) \g:(A->A)
  \fgcommutes:(a:A -> I A (f (g a)) (g (f a))) \a:A ->
  Nat.rec (\n:Nat -> I A (Nat.iter A f n (g a)) (g (Nat.iter A f n a)))
    (I.r A (g a))
    (\n:Nat\Hyp:I A (Nat.iter A f n (g a)) (g (Nat.iter A f n a)) ->
     I.subst A (f (g (Nat.iter A f n a))) (g (Nat.iter A f (Nat.s n) a))
        (fgcommutes (Nat.iter A f n a))
        (\x:A -> I A (Nat.iter A f (Nat.s n) (g a)) x)
        (I.cong A A f (Nat.iter A f n (g a)) (g (Nat.iter A f n a)) Hyp))

Inductive Test : b:Bool -> U =
  tt : Test Bool.tt
Definition Test.false = \test:Test Bool.ff \C:U ->
  Test.rec (\b:Bool \_:Test b -> Bool.rec (\_:Bool->U) T C b) (T.tt) Bool.ff test
TypeCheck Test.false : (Test Bool.ff -> C:U -> C)

Inductive VarType : U = []:VarType, *:VarType

Inductive Term : U =
  lam   : VarType -> Term -> Term -> Term,
  pi    : VarType -> Term -> Term -> Term,
  app   : Term -> Term -> Term,
  var   : VarType -> Nat -> Term,
  univ  : VarType -> Term

Definition Term.[] = Term.univ VarType.[]
Definition Term.*  = Term.univ VarType.*

; increment m by one, if m greater equal n.
Definition Nat.shiftn =
  Nat.rec (\n:Nat -> m:Nat -> Nat)
     Nat.s
     (\_:Nat \shiftn1:(Nat -> Nat) ->
       Nat.rec (\m:Nat -> Nat) Nat.0
	  (\m1:Nat \_:Nat -> Nat.s (shiftn1 m1)))

Definition Nat.shiftn.commutes.Thesis = \i:Nat -> \n:Nat -> \m:Nat ->
    I Nat (Nat.shiftn n (Nat.shiftn (Nat.plus m n) i))
          (Nat.shiftn (Nat.s (Nat.plus m n)) (Nat.shiftn n i))
 
Definition Nat.shiftn.commutes =
   Nat.rec (\n:Nat -> m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i n m)
     (Nat.rec (\m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 m)
        (\i:Nat -> I.r Nat (Nat.s (Nat.s i)))
	(\m:Nat \HypM: (i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 m) ->
	 Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 (Nat.s m))
	   (I.r Nat (Nat.s Nat.0))
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i Nat.0 (Nat.s m) ->
	    I.r Nat (Nat.s (Nat.s (Nat.shiftn (Nat.plus m Nat.0) i))))))
     (\n:Nat \HypN: (m:Nat ->i:Nat -> Nat.shiftn.commutes.Thesis i n m) ->
      Nat.rec (\m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) m)
        (Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) Nat.0)
	   (I.r Nat Nat.0)
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i (Nat.s n) Nat.0 ->
	    I.cong Nat Nat Nat.s (Nat.shiftn n (Nat.shiftn n i))
	           (Nat.shiftn (Nat.s n) (Nat.shiftn n i)) (HypN Nat.0 i)))
        (\m:Nat \HypM: (i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) m) ->
	 Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) (Nat.s m))
	   (I.r Nat Nat.0)
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i (Nat.s n) (Nat.s m) ->
	    I.subst Nat (Nat.s (Nat.plus m n)) (Nat.plus m (Nat.s n))
	            (Nat.s.plus.commutes m n)
		    (\x:Nat -> I Nat (Nat.s (Nat.shiftn n (Nat.shiftn x i)))
		               (Nat.s (Nat.shiftn (Nat.s x) (Nat.shiftn n i))))
	    (I.cong Nat Nat Nat.s
	    	   (Nat.shiftn n (Nat.shiftn (Nat.plus (Nat.s m) n) i))
		   (Nat.shiftn (Nat.s (Nat.plus (Nat.s m) n)) (Nat.shiftn n i))
		   (HypN (Nat.s m) i)))))

Definition Nat.plus.shiftn.lemma = \i:Nat \n:Nat ->
  I.subst Nat (Nat.plus n i) (Nat.plus i n) (Nat.plus.commutes n i)
          (\x:Nat -> I Nat (Nat.shiftn n x) (Nat.plus (Nat.shiftn Nat.0 i) n))
  (I.subst Nat (Nat.plus n (Nat.shiftn Nat.0 i))
               (Nat.plus (Nat.shiftn Nat.0 i) n)
	       (Nat.plus.commutes n (Nat.shiftn Nat.0 i))
          (\x:Nat -> I Nat (Nat.shiftn n (Nat.plus n i)) x)
    (Nat.rec (\n:Nat -> I Nat (Nat.shiftn n (Nat.plus n i))
                              (Nat.plus n (Nat.shiftn Nat.0 i)))
	  (I.r Nat (Nat.s i))
	  (\n:Nat -> I.cong Nat Nat Nat.s
	                    (Nat.shiftn n (Nat.plus n i))
			    (Nat.plus n (Nat.shiftn Nat.0 i)))
	  n))

; Increment all variables >= n by one.
Definition Term.shiftn =
  Term.rec (\_:Term -> n:Nat -> Term)
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.lam vt (rt1 n) (rt2 (Nat.s n)))
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.pi vt (rt1 n) (rt2 (Nat.s n)))
    (\_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.app (rt1 n) (rt2 n))
    (\vt:VarType \i: Nat \n:Nat -> Term.var vt (Nat.shiftn n i))
    (\vt:VarType \n: Nat -> Term.univ vt)
Definition Term.shiftvar = \term:Term ->
    Term.shiftn term Nat.0

Definition Term.shiftn.commutes.Thesis = \T:Term -> n:Nat -> m:Nat ->
    I Term (Term.shiftn (Term.shiftn T (Nat.plus m n)) n)
           (Term.shiftn (Term.shiftn T n) (Nat.s (Nat.plus m n)))

Definition Term.shiftn.commutes =
   Term.rec (\T:Term -> Term.shiftn.commutes.Thesis T)
      (\vt:VarType
       \S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 Term Term Term (\x:Term \y:Term -> Term.lam vt x y)
           (Term.shiftn (Term.shiftn S (Nat.plus m n)) n)
	   (Term.shiftn (Term.shiftn S n) (Nat.s (Nat.plus m n)))
	   (HypS n m)
           (Term.shiftn (Term.shiftn M (Nat.s (Nat.plus m n))) (Nat.s n))
	   (Term.shiftn (Term.shiftn M (Nat.s n))
	                                   (Nat.s (Nat.s (Nat.plus m n))))
	   (I.rsubst Nat (Nat.plus m (Nat.s n)) (Nat.s (Nat.plus m n))
	                (Nat.s.plus.commutes m n)
		(\x:Nat -> I Term
                 (Term.shiftn (Term.shiftn M x) (Nat.s n))
	         (Term.shiftn (Term.shiftn M (Nat.s n)) (Nat.s x)))
	        (HypM (Nat.s n) m)))
      (\vt:VarType
       \S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 Term Term Term (\x:Term \y:Term -> Term.pi vt x y)
           (Term.shiftn (Term.shiftn S (Nat.plus m n)) n)
	   (Term.shiftn (Term.shiftn S n) (Nat.s (Nat.plus m n)))
	   (HypS n m)
           (Term.shiftn (Term.shiftn M (Nat.s (Nat.plus m n))) (Nat.s n))
	   (Term.shiftn (Term.shiftn M (Nat.s n))
	                                   (Nat.s (Nat.s (Nat.plus m n))))
	   (I.rsubst Nat (Nat.plus m (Nat.s n)) (Nat.s (Nat.plus m n))
	                (Nat.s.plus.commutes m n)
		(\x:Nat -> I Term
                 (Term.shiftn (Term.shiftn M x) (Nat.s n))
	         (Term.shiftn (Term.shiftn M (Nat.s n)) (Nat.s x)))
	        (HypM (Nat.s n) m)))
      (\S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 Term Term Term (\x:Term \y:Term -> Term.app x y)
           (Term.shiftn (Term.shiftn S (Nat.plus m n)) n)
	   (Term.shiftn (Term.shiftn S n) (Nat.s (Nat.plus m n)))
	   (HypS n m)
           (Term.shiftn (Term.shiftn M (Nat.plus m n)) n)
	   (Term.shiftn (Term.shiftn M n) (Nat.s (Nat.plus m n)))
	   (HypM n m))
     (\vt:VarType \i:Nat \n:Nat \m:Nat ->
      I.cong Nat Term (\i:Nat -> Term.var vt i)
             (Nat.shiftn n (Nat.shiftn (Nat.plus m n) i))
	     (Nat.shiftn (Nat.s (Nat.plus m n)) (Nat.shiftn n i))
             (Nat.shiftn.commutes n m i))
     (\vt:VarType \n:Nat \m:Nat -> I.r Term (Term.univ vt))
TypeCheck Term.shiftn.commutes : T:Term -> Term.shiftn.commutes.Thesis T
Definition Term.shiftvarn.commutes  = \T:Term \n:Nat ->
     I.subst Nat (Nat.plus n Nat.0) n (Nat.plus.zero n)
	      (\x:Nat -> I Term (Term.shiftvar (Term.shiftn T x))
	                        (Term.shiftn (Term.shiftvar T) (Nat.s x)))
	      (Term.shiftn.commutes T Nat.0 n)
TypeCheck Term.shiftvarn.commutes : T:Term -> n:Nat ->
     I Term (Term.shiftvar (Term.shiftn T n))
            (Term.shiftn (Term.shiftvar T) (Nat.s n))

Inductive Subst : U =
   offset : Nat -> Subst,
   cons   : Term -> Subst -> Subst

Definition Subst.shift =
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset (Nat.s i))
    (\t:Term \_:Subst \sigmashift:Subst ->
     Subst.cons (Term.shiftvar t) sigmashift)
Definition Subst.consshift = \vt:VarType \sigma:Subst ->
  Subst.cons (Term.var vt Nat.0) (Subst.shift sigma)
Definition Subst.len =
  Subst.rec (\_:Subst -> Nat)
    (\i:Nat -> Nat.0) (\_:Term \_:Subst \r:Nat -> Nat.s r)
Definition Subst.drop1 =
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset (Nat.s i))
    (\t:Term \sigma:Subst \_:Subst -> sigma)
Definition Subst.drop = Nat.iter Subst Subst.drop1
Definition Subst.evalhead = \vt:VarType ->
  Subst.rec (\tau:Subst -> Term)
    (\i:Nat -> Term.var vt i)
    (\t:Term \_:Subst \_:Term -> t)
Definition Subst.eval = \sigma:Subst \vt:VarType \n:Nat ->
  Subst.evalhead vt (Subst.drop n sigma)

Definition Term.substapp =
  Term.rec (\_:Term -> Subst -> Term)
    (\vt:VarType \_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst -> Term)
     \subst:Subst ->
     Term.lam vt (r1 subst) (r2 (Subst.consshift vt subst)))
    (\vt:VarType \_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst->Term)
     \subst:Subst ->
     Term.pi vt (r1 subst) (r2 (Subst.consshift vt subst)))
    (\_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst->Term)
     \subst:Subst -> Term.app (r1 subst) (r2 subst))
    (\vt:VarType \n:Nat \subst:Subst -> Subst.eval subst vt n)
    (\vt:VarType \subst:Subst -> Term.univ vt)

Definition Subst.unit = \t:Term -> Subst.cons t (Subst.offset Nat.0)
Definition Term.subst = \term:Term \subst:Term ->
    Term.substapp term (Subst.unit subst)

Definition Subst.isEmpty =
  Subst.rec (\_:Subst -> U) (\_:Nat -> T) (\_:Term\_:Subst\_:U -> F)

Definition Subst.substshiftn = \n:Nat ->
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset i)
    (\t:Term \sigma:Subst \recurse:Subst ->
     Subst.cons (Term.shiftn t n) recurse)

Definition Subst.shift.substshiftn.commutes = \n:Nat ->
  Subst.rec (\sigma:Subst ->
     I Subst (Subst.shift (Subst.substshiftn n sigma))
             (Subst.substshiftn (Nat.s n) (Subst.shift sigma)))
    (\i:Nat -> I.r Subst (Subst.offset (Nat.s i)))
    (\t:Term \sigma:Subst
     \Hyp: I Subst (Subst.shift (Subst.substshiftn n sigma))
             (Subst.substshiftn (Nat.s n) (Subst.shift sigma)) ->
     I.cong2 Term Subst Subst (\t:Term \sigma:Subst -> Subst.cons t sigma)
        (Term.shiftvar (Term.shiftn t n))
	(Term.shiftn (Term.shiftvar t) (Nat.s n))
	(Term.shiftvarn.commutes t n)
	(Subst.shift (Subst.substshiftn n sigma))
	(Subst.substshiftn (Nat.s n) (Subst.shift sigma))
	Hyp)
	
Definition Subst.drop1.substshiftn.commutes = \n:Nat ->
  Subst.rec (\sigma:Subst ->
             I Subst (Subst.drop1 (Subst.substshiftn n sigma))
	             (Subst.substshiftn n (Subst.drop1 sigma)))
    (\i:Nat -> I.r Subst (Subst.offset (Nat.s i)))
    (\t:Term \sigma:Subst
     \_:     I Subst (Subst.drop1 (Subst.substshiftn n sigma))
	             (Subst.substshiftn n (Subst.drop1 sigma)) ->
     I.r Subst (Subst.substshiftn n sigma))
		     
Definition Subst.substshift.consshift.Claim = 
  \subst:Subst -> n:Nat -> vt:VarType ->
     I Subst (Subst.consshift vt (Subst.substshiftn n subst))
             (Subst.substshiftn (Nat.s n) (Subst.consshift vt subst))
Definition Subst.substshift.consshift.Lemma = \subst:Subst ->
  \n:Nat \vt:VarType ->
  I.cong Subst Subst (\sigma:Subst -> Subst.cons (Term.var vt Nat.0) sigma)
     (Subst.shift (Subst.substshiftn n subst))
     (Subst.substshiftn (Nat.s n) (Subst.shift subst))
     (Subst.shift.substshiftn.commutes n subst)

TypeCheck Subst.substshift.consshift.Lemma :
  sigma:Subst -> Subst.substshift.consshift.Claim sigma

Definition Subst.drop.offset = \n:Nat ->
  Nat.rec (\i:Nat -> I Subst (Subst.drop i (Subst.offset n))
                             (Subst.offset (Nat.plus i n)))
    (I.r Subst (Subst.offset n))
    (\i:Nat ->
     I.cong Subst Subst Subst.drop1
            (Subst.drop i (Subst.offset n))
	    (Subst.offset (Nat.plus i n)))

Definition Subst.evalshift.offsetcomp = \m:Nat \offset:Nat \n:Nat ->
   I.rsubst Subst
           (Subst.offset (Nat.plus m offset))
           (Subst.drop m (Subst.offset offset))
	   (Subst.drop.offset offset m)
	   (\x: Subst -> I Subst x (Subst.offset n) ->
	                 I Nat (Nat.plus m offset) n)
    (I.cong Subst Nat
            (Subst.rec (\_:Subst -> Nat) (\x:Nat -> x)
	               (\_:Term \_:Subst\_:Nat -> Nat.0))
	    (Subst.offset (Nat.plus m offset))
            (Subst.offset n))

Definition Subst.evalshift.help = \m:Nat \n:Nat ->
   I.subst Nat (Nat.plus m (Nat.s n)) (Nat.plus (Nat.s n) m)
           (Nat.plus.commutes m (Nat.s n))
	   (\x:Nat -> I Nat (Nat.shiftn x m) m)
	   (Nat.rec (\m:Nat -> I Nat (Nat.shiftn (Nat.plus m (Nat.s n)) m) m)
	      (I.r Nat Nat.0)
	      (\m:Nat ->
	       I.cong Nat Nat Nat.s (Nat.shiftn (Nat.plus m (Nat.s n)) m) m)
	      m)



Definition Subst.evalshift.claim = \n:Nat \vt:VarType ->
  \i:Nat -> \m:Nat -> sigma:Subst ->
  I Subst (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
  I Term (Term.shiftn (Subst.eval sigma vt i) n)
         (Subst.eval (Subst.substshiftn n sigma) vt (Nat.shiftn (Nat.s m) i))

Definition Subst.evalshift.lemma = \vt:VarType ->
   Nat.rec (\i:Nat -> (m:Nat -> n:Nat -> Subst.evalshift.claim n vt i m))
    (\m:Nat \n:Nat ->
     (Subst.rec (\sigma:Subst ->
                 eq:I Subst (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
     		 I Term (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     		   (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
        (\offset:Nat
	 \eq : I Subst (Subst.drop (Nat.s m) (Subst.offset offset))
	               (Subst.offset n) ->
	 ; argue with eq that m+1+offset = n
         I.cong Nat Term (\x:Nat -> Term.var vt x)
	    (Nat.shiftn n offset) offset
  	    (I.subst Nat (Nat.plus (Nat.s m) offset) n
	       (Subst.evalshift.offsetcomp (Nat.s m) offset n eq)
	       (\x:Nat -> I Nat (Nat.shiftn x offset) offset)
	       (Subst.evalshift.help offset m)))
	(\t:Term \sigma:Subst
	 \_:(I Subst (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
	     I Term (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     		    (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
	 \_:I Subst (Subst.drop (Nat.s m) (Subst.cons t sigma))
	            (Subst.offset n) ->
	 I.r Term (Term.shiftn t n))))
    (\i:Nat \Hyp:(m:Nat -> n:Nat -> Subst.evalshift.claim n vt i m)
     \m:Nat \n:Nat \sigma:Subst
     \eq:I Subst (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
     I.rsubst Subst
              (Subst.drop (Nat.shiftn m i) (Subst.substshiftn n (Subst.drop1 sigma)))
              (Subst.drop (Nat.s (Nat.shiftn m i)) (Subst.substshiftn n sigma))
	      (I.subst Subst
		       (Subst.drop1 (Subst.substshiftn n sigma))
	               (Subst.substshiftn n (Subst.drop1 sigma))
		       (Subst.drop1.substshiftn.commutes n sigma)
		       (\x: Subst -> I Subst
              (Subst.drop (Nat.s (Nat.shiftn m i)) (Subst.substshiftn n sigma))
              (Subst.drop (Nat.shiftn m i) x))
		       (Nat.iter.associative Subst Subst.drop1
		       			     (Nat.shiftn m i)
					     (Subst.substshiftn n sigma)))
	      (\x:Subst ->
	       I Term (Term.shiftn (Subst.eval sigma vt (Nat.s i)) n)
                      (Subst.evalhead vt x))
     (I.rsubst Subst
              (Subst.drop i (Subst.drop1 sigma))
              (Subst.drop (Nat.s i) sigma)
              (Nat.iter.associative Subst Subst.drop1 i sigma)
	      (\x:Subst -> I Term (Term.shiftn (Subst.evalhead vt x) n)
      (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt (Nat.shiftn m i)))
     (Nat.rec (\m:Nat ->
               eq:I Subst (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
               I Term (Term.shiftn (Subst.eval (Subst.drop1 sigma) vt i) n)
                      (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt
		      		  (Nat.shiftn m i)))
       (\eq:I Subst (Subst.drop1 sigma) (Subst.offset n) ->
	I.rsubst Subst (Subst.offset n) (Subst.drop1 sigma) eq
	   (\x:Subst -> I Term (Term.shiftn (Subst.eval x vt i) n)
               (Subst.eval (Subst.substshiftn n x) vt (Nat.shiftn Nat.0 i)))
	(I.rsubst Subst (Subst.offset (Nat.plus i n))
		 (Subst.drop i (Subst.offset n))
		 (Subst.drop.offset n i)
		 (\x:Subst -> I Term (Term.shiftn (Subst.evalhead vt x) n)
               (Subst.eval (Subst.offset n) vt (Nat.shiftn (Nat.0) i)))
	(I.rsubst Subst (Subst.offset (Nat.plus (Nat.shiftn (Nat.0) i) n))
		 (Subst.drop (Nat.shiftn (Nat.0) i) (Subst.offset n))
		 (Subst.drop.offset n (Nat.shiftn (Nat.0) i))
		 (\x:Subst -> I Term (Term.shiftn (Term.var vt (Nat.plus i n)) n)
                                     (Subst.evalhead vt x))

		 (I.cong Nat Term (\x:Nat -> Term.var vt x)
     	                (Nat.shiftn n (Nat.plus i n))
                        (Nat.plus (Nat.shiftn Nat.0 i) n)
	                (Nat.plus.shiftn.lemma i n)))))
       (\m:Nat \_:(I Subst (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
               I Term (Term.shiftn (Subst.eval (Subst.drop1 sigma) vt i) n)
                      (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt
		      		  (Nat.shiftn m i)))
        \eq:I Subst (Subst.drop (Nat.s (Nat.s m)) sigma) (Subst.offset n) ->
        (Hyp m n (Subst.drop1 sigma)
	  (I.subst Subst
	           (Subst.drop (Nat.s (Nat.s m)) sigma)
		   (Subst.drop (Nat.s m) (Subst.drop1 sigma))
                   (Nat.iter.associative Subst Subst.drop1 (Nat.s m) sigma)
		   (\x:Subst -> I Subst x (Subst.offset n))
		   eq)))
       m eq)))

Definition Term.substshift.shiftn.Thesis =
  \t:Term -> n:Nat -> sigma:Subst ->
     I Subst (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
     I Term (Term.shiftn (Term.substapp t sigma) n)
  	    (Term.substapp (Term.shiftn t (Nat.s n))
	    		   (Subst.substshiftn n sigma))

Definition Subst.drop1.shift.commutes =
  Subst.rec (\sigma:Subst ->
             I Subst (Subst.drop1 (Subst.shift sigma))
	             (Subst.shift (Subst.drop1 sigma)))
    (\i:Nat -> I.r Subst (Subst.offset (Nat.s (Nat.s i))))
    (\t:Term \sigma:Subst
     \_:     I Subst (Subst.drop1 (Subst.shift sigma))
	             (Subst.shift (Subst.drop1 sigma)) ->
     I.r Subst (Subst.shift sigma))

Definition Subst.drop.shift.commutes =
  Nat.iter.g.commutes Subst Subst.drop1 Subst.shift Subst.drop1.shift.commutes

Definition Term.substshift.shiftn.shifteq = \n:Nat \vt:VarType \sigma:Subst ->
  (I.rsubst Subst (Subst.drop (Nat.s n) (Subst.shift sigma))
	    (Subst.drop (Nat.s (Nat.s n)) (Subst.consshift vt sigma))
	    (Nat.iter.associative Subst Subst.drop1 (Nat.s n)
	                          (Subst.consshift vt sigma))
   (\x:Subst ->
      I Subst (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
      I Subst x (Subst.offset (Nat.s n)))
   (\eq:I Subst (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
    I.rsubst Subst (Subst.shift (Subst.drop (Nat.s n) sigma))
             (Subst.drop (Nat.s n) (Subst.shift sigma))
	     (Subst.drop.shift.commutes sigma (Nat.s n))
	     (\x:Subst -> I Subst x (Subst.offset (Nat.s n)))
    (I.cong Subst Subst Subst.shift
        (Subst.drop (Nat.s n) sigma) (Subst.offset n) eq)))

Definition Term.substshift.shiftn =
  Term.rec (\t:Term -> Term.substshift.shiftn.Thesis t)
    (\vt:VarType
     \M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat
     \subst:Subst
     \eq : I Subst (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 Term Term Term (\x:Term \y:Term -> Term.lam vt x y)
           (Term.shiftn (Term.substapp M subst) n)
           (Term.substapp (Term.shiftn M (Nat.s n)) (Subst.substshiftn n subst))
	   (HypM n subst eq)
           (Term.shiftn (Term.substapp N (Subst.consshift vt subst)) (Nat.s n))
           (Term.substapp (Term.shiftn N (Nat.s (Nat.s n)))
	   		  (Subst.consshift vt (Subst.substshiftn n subst)))
	   (I.rsubst Subst
                    (Subst.substshiftn (Nat.s n) (Subst.consshift vt subst))
                    (Subst.consshift vt (Subst.substshiftn n subst))
		    (Subst.substshift.consshift.Lemma subst n vt)
		    (\x: Subst ->
                      I Term (Term.shiftn (Term.substapp N (Subst.consshift vt subst)) (Nat.s n))
		      	     (Term.substapp (Term.shiftn N (Nat.s (Nat.s n))) x))
	      (HypN (Nat.s n) (Subst.consshift vt subst)
	            (Term.substshift.shiftn.shifteq n vt subst eq))))
    (\vt:VarType
     \M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat \subst:Subst
     \eq : I Subst (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 Term Term Term (\x:Term \y:Term -> Term.pi vt x y)
           (Term.shiftn (Term.substapp M subst) n)
           (Term.substapp (Term.shiftn M (Nat.s n)) (Subst.substshiftn n subst))
	   (HypM n subst eq)
           (Term.shiftn (Term.substapp N (Subst.consshift vt subst)) (Nat.s n))
           (Term.substapp (Term.shiftn N (Nat.s (Nat.s n)))
	   		  (Subst.consshift vt (Subst.substshiftn n subst)))
	   (I.rsubst Subst
                    (Subst.substshiftn (Nat.s n) (Subst.consshift vt subst))
                    (Subst.consshift vt (Subst.substshiftn n subst))
		    (Subst.substshift.consshift.Lemma subst n vt)
		    (\x: Subst ->
                      I Term (Term.shiftn (Term.substapp N (Subst.consshift vt subst)) (Nat.s n))
		      	     (Term.substapp (Term.shiftn N (Nat.s (Nat.s n))) x))
	      (HypN (Nat.s n) (Subst.consshift vt subst)
	            (Term.substshift.shiftn.shifteq n vt subst eq))))
    (\M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat \subst:Subst
     \eq : I Subst (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 Term Term Term (\x:Term \y:Term -> Term.app x y)
           (Term.shiftn (Term.substapp M subst) n)
           (Term.substapp (Term.shiftn M (Nat.s n)) (Subst.substshiftn n subst))
	   (HypM n subst eq)
           (Term.shiftn (Term.substapp N subst) n)
           (Term.substapp (Term.shiftn N (Nat.s n)) (Subst.substshiftn n subst))
	   (HypN n subst eq))
    (\vt: VarType \i:Nat
     \n:Nat \sigma:Subst ->
     Subst.evalshift.lemma vt i n n sigma)
    (\vt: VarType \n:Nat \sigma:Subst
     \eq : I Subst (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
     I.r Term (Term.univ vt))

Definition Term.subst.shift = \t:Term \subst:Term \n:Nat ->
  Term.substshift.shiftn t n (Subst.unit subst)
     (Nat.rec (\n:Nat -> I Subst (Subst.drop (Nat.s n) (Subst.unit subst))
      	      	      	   	 (Subst.offset n))
        (I.r Subst (Subst.offset Nat.0))
	(\n:Nat -> I.cong Subst Subst Subst.drop1
	        (Subst.drop (Nat.s n) (Subst.unit subst)) (Subst.offset n))
	n)
    
TypeCheck Term.subst.shift : t:Term -> subst:Term -> n:Nat ->
    I Term (Term.shiftn (Term.subst t subst) n)
           (Term.subst (Term.shiftn t (Nat.s n)) (Term.shiftn subst n))

Inductive ConvStep : Term -> Term -> U =
  beta : vt:VarType -> T:Term -> M:Term -> N:Term ->
         ConvStep (Term.app (Term.lam vt T M) N) (Term.subst M N),
  lam1 : vt:VarType -> T1:Term -> T2:Term -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.lam vt T1 M) (Term.lam vt T2 M),
  lam2 : vt:VarType -> M1:Term -> M2:Term -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.lam vt T M1) (Term.lam vt T M2),
  pi1  : vt:VarType -> T1:Term -> T2:Term -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.pi vt T1 M) (Term.pi vt T2 M),
  pi2  : vt:VarType -> M1:Term -> M2:Term -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.pi vt T M1) (Term.pi vt T M2),
  app1 : M1:Term -> M2:Term -> ConvStep M1 M2 -> N:Term ->
         ConvStep (Term.app M1 N) (Term.app M2 N),
  app2 : N1:Term -> N2:Term -> ConvStep N1 N2 -> M:Term ->
         ConvStep (Term.app M N1) (Term.app M N2)

Definition ConvStep.shiftn = 
  ConvStep.rec (\T:Term \S: Term \step : ConvStep T S -> n:Nat ->
                ConvStep (Term.shiftn T n) (Term.shiftn S n))
    (\vt:VarType \T:Term \M:Term \N:Term \n:Nat ->
     I.rsubst Term (Term.subst (Term.shiftn M (Nat.s n)) (Term.shiftn N n))
                   (Term.shiftn (Term.subst M N) n)
	      (Term.subst.shift M N n)
	      (\x: Term -> ConvStep (Term.shiftn (Term.app (Term.lam vt T M) N) n) x)
     (ConvStep.beta vt (Term.shiftn T n) (Term.shiftn M (Nat.s n)) (Term.shiftn N n)))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.lam1 vt (Term.shiftn T1 n) (Term.shiftn T2 n) (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \T:Term \n:Nat ->
     ConvStep.lam2 vt (Term.shiftn M1 (Nat.s n)) (Term.shiftn M2 (Nat.s n)) (hyp (Nat.s n))
     		   (Term.shiftn T n))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.pi1 vt (Term.shiftn T1 n) (Term.shiftn T2 n) (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \T:Term \n:Nat ->
     ConvStep.pi2 vt (Term.shiftn M1 (Nat.s n)) (Term.shiftn M2 (Nat.s n)) (hyp (Nat.s n))
     		   (Term.shiftn T n))
    (\T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.app1 (Term.shiftn T1 n) (Term.shiftn T2 n) (hyp n) (Term.shiftn M n))
    (\M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \T:Term \n:Nat ->
     ConvStep.app2 (Term.shiftn M1 n) (Term.shiftn M2 n) (hyp n) (Term.shiftn T n))

Inductive ConvSymmStep : M:Term -> N:Term -> U =
  forw : ConvStep M N -> ConvSymmStep M N,
  back : ConvStep N M -> ConvSymmStep M N

Definition ConvSymmStep.shiftn = \T:Term \S: Term ->
   ConvSymmStep.rec T S (\step : ConvSymmStep T S -> n:Nat -> 
                         ConvSymmStep (Term.shiftn T n) (Term.shiftn S n))
	(\fstep:ConvStep T S \n:Nat -> ConvSymmStep.forw (Term.shiftn T n) (Term.shiftn S n)
			     	       			 (ConvStep.shiftn T S fstep n))
	(\bstep:ConvStep S T \n:Nat -> ConvSymmStep.back (Term.shiftn T n) (Term.shiftn S n)
			     	       			 (ConvStep.shiftn S T bstep n))

Inductive List : A:U -> U =
  nil  : List A,
  cons : A -> List A -> List A

Inductive VarList : U =
  nil  : VarList,
  cons : vt:VarType -> T:Term -> Gamma:VarList -> VarList

Inductive CCTypeCheck : VarList -> Term -> Term -> Prop =
  ax   : CCTypeCheck VarList.nil Term.* Term.[],
  var  : Gamma:VarList -> vt:VarType -> T : Term ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.var vt Nat.0) (Term.shiftvar T),
  weak : Gamma:VarList -> vt:VarType -> T : Term ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         M : Term -> S:Term -> CCTypeCheck Gamma M S ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.shiftvar M) (Term.shiftvar S),
  pi   : Gamma:VarList -> vt:VarType -> T : Term ->
         CCTypeCheck Gamma T (Term.univ vt) ->
	 vt2 : VarType -> S : Term ->
	 CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2),
  lam  : Gamma:VarList -> vt:VarType -> T : Term -> M:Term -> S:Term ->
         CCTypeCheck (VarList.cons vt T Gamma) M S ->
	 vt2: VarType -> CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.lam vt T M) (Term.pi vt T S),
  app  : Gamma:VarList -> M:Term -> vt: VarType -> T : Term -> S:Term ->
         CCTypeCheck Gamma M (Term.pi vt T S) ->
	 N : Term -> CCTypeCheck Gamma N T ->
	 CCTypeCheck Gamma (Term.app M N) (Term.subst S N),
  conv : Gamma:VarList -> M:Term -> T:Term -> CCTypeCheck Gamma M T ->
	 S : Term -> ConvSymmStep T S ->
	 CCTypeCheck Gamma M S

Inductive VarListTypeCheck : VarList -> U =
  nil  : VarListTypeCheck VarList.nil,
  cons : vt:VarType -> T:Term -> Gamma:VarList ->
 	 VarListTypeCheck Gamma -> CCTypeCheck Gamma T (Term.univ vt) ->
         VarListTypeCheck (VarList.cons vt T Gamma)

Definition CCTypeCheck.case =
  \C:(Gamma:VarList -> M:Term -> S:Term -> U1)
  \caseax: (C VarList.nil Term.* Term.[])
  \casevar:(Gamma:VarList -> vt:VarType -> T : Term ->
            CCTypeCheck Gamma T (Term.univ vt) ->
	    C (VarList.cons vt T Gamma) (Term.var vt Nat.0) (Term.shiftvar T))
  \caseweak:(Gamma:VarList -> vt:VarType -> T : Term ->
             CCTypeCheck Gamma T (Term.univ vt) ->
             M : Term -> S:Term -> CCTypeCheck Gamma M S ->
             C (VarList.cons vt T Gamma) (Term.shiftvar M) (Term.shiftvar S))
  \casepi:  (Gamma:VarList -> vt:VarType -> T : Term ->
             CCTypeCheck Gamma T (Term.univ vt) ->
	     vt2 : VarType -> S : Term ->
	     CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	     C Gamma (Term.pi vt T S) (Term.univ vt2))
  \caselam: (Gamma:VarList -> vt:VarType -> T : Term -> M:Term -> S:Term ->
             CCTypeCheck (VarList.cons vt T Gamma) M S ->
	     vt2: VarType ->
	     CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	     C Gamma (Term.lam vt T M) (Term.pi vt T S))
  \caseapp: (Gamma:VarList -> M:Term -> vt: VarType -> T : Term -> S:Term ->
             CCTypeCheck Gamma M (Term.pi vt T S) ->
	     N : Term -> CCTypeCheck Gamma N T ->
	     C Gamma (Term.app M N) (Term.subst S N))
  \caseconv:(Gamma:VarList -> M:Term -> T:Term -> CCTypeCheck Gamma M T ->
	     S : Term -> ConvSymmStep T S ->
	     C Gamma M S) ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
  		   C Gamma M S)
    caseax
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt) ->
     casevar Gamma vt T prf)
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt)
     \M : Term \S:Term \prf2: CCTypeCheck Gamma M S \_: C Gamma M S ->
     caseweak Gamma vt T prf M S prf2)
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt)
     \vt2 : VarType \S:Term
     \prf2: CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_: C (VarList.cons vt T Gamma) S (Term.univ vt2) ->
     casepi Gamma vt T prf vt2 S prf2)
    (\Gamma:VarList \vt:VarType \T : Term \M:Term \S:Term
     \prf: CCTypeCheck (VarList.cons vt T Gamma) M S
     \_: C (VarList.cons vt T Gamma) M S
     \vt2 : VarType 
     \prf2: CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \_: C Gamma (Term.pi vt T S) (Term.univ vt2) ->
     caselam Gamma vt T M S prf vt2 prf2)
    (\Gamma:VarList \M:Term \vt:VarType \T : Term \S:Term
     \prf: CCTypeCheck Gamma M (Term.pi vt T S) \_: C Gamma M (Term.pi vt T S)
     \N:Term \prf2: CCTypeCheck Gamma N T \_: C Gamma N T ->
     caseapp Gamma M vt T S prf N prf2)
    (\Gamma:VarList \M:Term \T : Term
     \prf: CCTypeCheck Gamma M T \_: C Gamma M T
     \S:Term \step:ConvSymmStep T S ->
     caseconv Gamma M T prf S step)

Definition CCTypeCheck.ax2 = 
  VarListTypeCheck.rec (\Gamma:VarList \_:VarListTypeCheck Gamma ->
                         CCTypeCheck Gamma Term.* Term.[])
     CCTypeCheck.ax
     (\vt:VarType \T:Term \Gamma:VarList \_:VarListTypeCheck Gamma
      \r:CCTypeCheck Gamma Term.* Term.[]
      \tc:CCTypeCheck Gamma T (Term.univ vt) ->
        CCTypeCheck.weak Gamma vt T tc Term.* Term.[] r)

Definition CCTypeCheck.gammatc =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
                   VarListTypeCheck Gamma)
    VarListTypeCheck.nil
    ;var
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma ->
     VarListTypeCheck.cons vt T Gamma rec prf)
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma
     \M : Term \S:Term \_: CCTypeCheck Gamma M S \_:VarListTypeCheck Gamma ->
     VarListTypeCheck.cons vt T Gamma rec prf)
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Definition VarList.deleten =
  Nat.rec (\n:Nat -> VarList -> VarList)
    (\Gamma:VarList -> Gamma)
    (\_:Nat \delrec:(VarList -> VarList) ->
     VarList.rec (\Gamma:VarList -> VarList) VarList.nil
        (\vt1:VarType \T1:Term \Gamma:VarList \_:VarList -> delrec Gamma))
    
Definition VarList.insertn =
  Nat.rec (\n:Nat -> VarType -> Term -> VarList -> VarList)
    VarList.cons
    (\n:Nat \insertrec:(VarType -> Term -> VarList -> VarList)
     \vt:VarType \T0:Term ->
     VarList.rec (\Gamma:VarList -> VarList)
        (insertrec vt T0 VarList.nil)
	(\vt1:VarType \T1:Term \Gamma:VarList \_:VarList ->
	 VarList.cons vt1 (Term.shiftn T1 n) (insertrec vt T0 Gamma)))
	 
Definition deletenil =
  Nat.rec (\n:Nat -> I VarList (VarList.deleten n VarList.nil) VarList.nil)
     (I.r VarList VarList.nil)
     (\n:Nat \_:I VarList (VarList.deleten n VarList.nil) VarList.nil ->
      I.r VarList VarList.nil)

Definition CCTypeCheck.weakn =
  \vt:VarType \T0:Term ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \N:Term \_:CCTypeCheck Gamma M N ->
                   n:Nat ->
		   CCTypeCheck (VarList.deleten n Gamma)
		       		T0 (Term.univ vt) ->
                   CCTypeCheck (VarList.insertn n vt T0 Gamma)
		                (Term.shiftn M n)
				(Term.shiftn N n))
    ;ax
    (Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
	      CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                    (Term.shiftn Term.* n)
				    (Term.shiftn Term.[] n))
       (\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
        CCTypeCheck.weak VarList.nil vt T0 prfT0
	                 Term.* Term.[] CCTypeCheck.ax)
       (\n:Nat
        \rec:(CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
              CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                 (Term.shiftn Term.* n)
				 (Term.shiftn Term.[] n))
	\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
	rec (I.rsubst VarList VarList.nil (VarList.deleten n VarList.nil)
	              (deletenil n)
		      (\x:VarList -> CCTypeCheck x T0 (Term.univ vt))
		      prfT0)))
    ;var
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.var vt1 Nat.0) n)
			  (Term.shiftn (Term.shiftvar T1) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak (VarList.cons vt1 T1 Gamma) vt T0 prfT0
	                 (Term.var vt1 Nat.0) (Term.shiftvar T1)
                         (CCTypeCheck.var Gamma vt1 T1 prf1))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.var vt1 Nat.0) n)
			 (Term.shiftn (Term.shiftvar T1) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst Term (Term.shiftvar (Term.shiftn T1 n))
	        (Term.shiftn (Term.shiftvar T1) (Nat.s n))
		(Term.shiftvarn.commutes T1 n)
	        (\x:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       (Term.var vt1 Nat.0)  x)
	 (CCTypeCheck.var (VarList.insertn n vt T0 Gamma)
	                  vt1 (Term.shiftn T1 n)
	                  (Hyp n prfT0))))
    ;weak
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \M : Term \S:Term
     \prf2: CCTypeCheck Gamma M S
     \Hyp2: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma) 
	              (Term.shiftn M n) (Term.shiftn S n)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.shiftvar M) n)
			  (Term.shiftn (Term.shiftvar S) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak (VarList.cons vt1 T1 Gamma) vt T0 prfT0
	                 (Term.shiftvar M) (Term.shiftvar S)
			 (CCTypeCheck.weak Gamma vt1 T1 prf1 M S prf2))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.shiftvar M) n)
			 (Term.shiftn (Term.shiftvar S) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst2 Term (Term.shiftvar (Term.shiftn M n))
	         (Term.shiftn (Term.shiftvar M) (Nat.s n))
		 (Term.shiftvarn.commutes M n)
		 Term (Term.shiftvar (Term.shiftn S n))
	         (Term.shiftn (Term.shiftvar S) (Nat.s n))
		 (Term.shiftvarn.commutes S n)
	         (\x:Term \y:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       x y)
	 (CCTypeCheck.weak
	      (VarList.insertn n vt T0 Gamma) vt1 (Term.shiftn T1 n)
	      (Hyp1 n prfT0)
	      (Term.shiftn M n) (Term.shiftn S n)
	      (Hyp2 n prfT0))))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \vt2:VarType \S:Term
     \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n
     	    	          (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                 (Term.shiftn S n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.pi (VarList.insertn n vt T0 Gamma) vt1 (Term.shiftn T1 n)
        (Hyp1 n prfT0)
	vt2 (Term.shiftn S (Nat.s n))
	(Hyp2 (Nat.s n) prfT0))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	    		T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                (Term.shiftn M n) (Term.shiftn S n)) ->
     \vt2:VarType
     \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn (Term.pi vt1 T1 S) n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.lam (VarList.insertn n vt T0 Gamma) vt1
        (Term.shiftn T1 n) (Term.shiftn M (Nat.s n)) (Term.shiftn S (Nat.s n))
        (Hyp1 (Nat.s n) prfT0)
	vt2 (Hyp2 n prfT0))
    ;app
    (\Gamma:VarList \M:Term \vt1:VarType \T1:Term \S:Term
     \prf1: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn (Term.pi vt1 T1 S) n)) ->
     \N:Term
     \prf2:CCTypeCheck Gamma N T1
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn N n) (Term.shiftn T1 n))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     I.rsubst Term (Term.subst (Term.shiftn S (Nat.s n)) (Term.shiftn N n))
                   (Term.shiftn (Term.subst S N) n)
	      (Term.subst.shift S N n)
	      (\x: Term -> CCTypeCheck (VarList.insertn n vt T0 Gamma)
	      	                       (Term.shiftn (Term.app M N) n) x)
     (CCTypeCheck.app (VarList.insertn n vt T0 Gamma) 
        (Term.shiftn M n) vt1 (Term.shiftn T1 n) (Term.shiftn S (Nat.s n))
        (Hyp1 n prfT0)
	(Term.shiftn N n) (Hyp2 n prfT0)))
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \prf1: CCTypeCheck Gamma M T
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn T n))
     \S:Term \step:ConvSymmStep T S
     \n:Nat 
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     (CCTypeCheck.conv (VarList.insertn n vt T0 Gamma)
         (Term.shiftn M n) (Term.shiftn T n) (Hyp1 n prfT0)
	 (Term.shiftn S n) (ConvSymmStep.shiftn T S step n)))

Inductive CCSubstCheck : Subst -> VarList -> VarList -> U =
  start  : Gamma:VarList ->
           CCSubstCheck (Subst.offset Nat.0) Gamma Gamma,
  offset : Gamma:VarList ->
	   vt:VarType -> S:Term -> CCTypeCheck Gamma S (Term.univ vt) ->
           i:Nat -> Gamma':VarList ->
	   CCSubstCheck (Subst.offset i) Gamma Gamma' ->
           CCSubstCheck (Subst.offset (Nat.s i))
	   		(VarList.cons vt S Gamma) Gamma',
  cons   : Gamma:VarList -> vt:VarType -> t:Term -> sigma:Subst ->
  	   Gamma':VarList -> S:Term ->
	   CCTypeCheck Gamma t S ->
	   CCSubstCheck sigma Gamma Gamma' ->
           CCSubstCheck (Subst.cons t sigma) Gamma (VarList.cons vt S Gamma')

Definition CCTypeCheck.substapp =
  CCTypeCheck.rec (\Gamma':VarList \M:Term \S:Term \t:CCTypeCheck Gamma' M S ->
	           sigma:Subst -> Gamma:VarList -> 
	           CCSubstCheck sigma Gamma Gamma' ->
	    CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma))
     ; ax
     (\sigma:Subst \Gamma:VarList \check:CCSubstCheck sigma Gamma Gamma' ->
      CCSubstCheck.rec (\sigma:Subst \Gamma:VarList \Gamma':VarList
     		        \_:CCSubstCheck sigma Gamma Gamma' ->
			I VarList Gamma' VarList.nil ->
	    		CCTypeCheck Gamma Term.* Term.[])
       (\Gamma:VarList \eq:I VarList Gamma VarList.nil
        I.rsubst VarList VarList.nil Gamma eq
	   (\x:VarList -> CCTypeCheck x Term.* Term.[])
           CCTypeCheck.ax)
       (\Gamma:VarList 
	\vt:VarType \S:Term  \prf:CCTypeCheck Gamma S (Term.univ vt)
        \i:Nat \chk:CCSubstCheck (Subst.offset i) Gamma Gamma'
	\Hyp:(I VarList Gamma' VarList.nil -> CCTypeCheck Gamma Term.* Term.[])
	\eq:I VarList Gamma' VarList.nil ->
	CCTypeCheck.weak Gamma vt S prf Term.* Term.[] (Hyp eq))
	)
     ; weak


  Term.rec (\M:Term -> S:Term -> 
  	    Gamma':VarList ->
	    CCTypeCheck Gamma' M S
	    Gamma:VarList -> sigma:Subst ->
	    CCSubstCheck sigma Gamma Gamma' ->
	    CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma))
   ; lam
   (\vt:VarType \M:Term \HypM:(CCTypeCheck.substapp.Thesis M)
    \N:Term \HypM:(CCTypeCheck.substapp.Thesis M)
    \S:Term \Gamma':VarList \tc:CCTypeCheck Gamma' M S
    \Gamma:VarList \sigma:Subst
    \check:CCSubstCheck sigma Gamma Gamma' ->
    CCTypeCheck.lam Gamma vt (Term.substapp M sigma)
                    (Term.substapp N (Subst.consshift vt sigma))
		    
)

Assume CCTypeCheck.substapp :
  CCTypeCheck Gamma' M S ->
  CCSubstCheck sigma Gamma Gamma' ->
  CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma)
;Proof Idea: Induction over M

Inductive Class : U =
  []     : Class,
  kind   : Class,
  prop   : Class,
  constr : Class,
  obj    : Class

Definition Class.constr2prop =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.prop Class.prop Class.obj
Definition Class.prop2constr =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.constr Class.constr Class.obj
Definition Class.constrobj =
  VarType.rec (\_:VarType -> Class) Class.constr Class.obj
Definition Class.kindprop =
  VarType.rec (\_:VarType -> Class) Class.kind Class.prop
Definition Class.boxkind =
  VarType.rec (\_:VarType -> Class) Class.[] Class.kind


Definition Term.classify =
  Term.rec (\t:Term -> Class)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; lam
        Class.prop2constr Nc)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; pi
        Class.constr2prop Nc)
    (\M:Term \Mc:Class \N:Term \_:Class -> Mc)          ; app
    (\vt:VarType \n:Nat -> Class.constrobj vt)          ; var
    Class.boxkind                                       ; univ

Definition Term.shiftn.classify =
  Term.rec (\M:Term -> n:Nat ->
            I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I Class (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class Class Class.prop2constr
               (Term.classify (Term.shiftn N (Nat.s n)))
               (Term.classify N)
	       (Hyp (Nat.s n)))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I Class (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class Class Class.constr2prop
               (Term.classify (Term.shiftn N (Nat.s n)))
               (Term.classify N)
	       (Hyp (Nat.s n)))
    (\M:Term
     \Hyp:(n:Nat -> I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \_:(n:Nat -> I Class (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> Hyp n)
    (\vt:VarType \i:Nat \n:Nat -> I.r Class (Class.constrobj vt))
    (\vt:VarType \n:Nat -> I.r Class (Class.boxkind vt))

Inductive TypedClass : Gamma:VarList -> S:Term -> Class -> U =
  kind  : CCTypeCheck Gamma S Term.[] -> TypedClass Gamma S Class.kind,
  prop  : CCTypeCheck Gamma S Term.*  -> TypedClass Gamma S Class.prop,
  constr: A:Term -> CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.[] -> TypedClass Gamma S Class.constr,
  obj   : A:Term -> CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.* -> TypedClass Gamma S Class.obj

Assume XXX : Gamma:VarList -> S:Term -> vt:VarType ->
     CCTypeCheck Gamma S (Term.univ vt) ->
     TypedClass Gamma S (Term.classify S) ->
     I Class (Class.constr2prop (Term.classify S)) (Class.kindprop vt)

Definition Term.classify.type.correct =
   CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \t:CCTypeCheck Gamma M S ->
                    TypedClass Gamma M (Term.classify M))
    ;ax
    (TypedClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf:CCTypeCheck Gamma T0 (Term.univ vt)
     \_:TypedClass Gamma T0 (Term.classify T0) ->
     VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term -> A:Term ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt (VarList.cons vt T0 Gamma) (Term.var vt Nat.0) (Term.shiftvar T0)
	(CCTypeCheck.var Gamma vt T0 prf)
	(CCTypeCheck.weak Gamma vt T0 prf T0 (Term.univ vt) prf))
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: TypedClass Gamma T0 (Term.classify T0) ->
     \M: Term -> \S:Term -> \prf2:CCTypeCheck Gamma M S ->
     I.rsubst Class (Term.classify M) (Term.classify (Term.shiftvar M))
         (Term.shiftn.classify M Nat.0)
     	 (\x:Class -> TypedClass Gamma M (Term.classify M) ->
	 	   TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) x)
     (TypedClass.rec Gamma M
         (\class: Class \_:TypedClass Gamma M class ->
          TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  TypedClass.kind (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.[] prf3))
	 ; prop
	 (\prf3: CCTypeCheck Gamma M Term.* ->
	  TypedClass.prop (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.* prf3))
	 ; constr
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.[] ->
	  TypedClass.constr (VarList.cons vt T0 Gamma)
	  		    (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.[] prf4))
	 ; obj
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.* prf4))
	 (Term.classify M)))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \_: TypedClass Gamma T1 (Term.classify T1) ->
     \vt2: VarType -> \S:Term ->
     \prf2: CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp: TypedClass (VarList.cons vt1 T1 Gamma) S (Term.classify S) ->
     I.rsubst Class (Class.kindprop vt2) (Class.constr2prop (Term.classify S))
               (XXX (VarList.cons vt1 T1 Gamma) S vt2 prf2 Hyp)
	       (\x:Class -> TypedClass Gamma (Term.pi vt1 T1 S) x)
     (VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term ->
		  CCTypeCheck Gamma M (Term.univ vt) ->
                  TypedClass Gamma M (Class.kindprop vt))
        TypedClass.kind
	TypedClass.prop
	vt2 Gamma (Term.pi vt1 T1 S)
	    (CCTypeCheck.pi Gamma vt1 T1 prf1 vt2 S prf2)))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \_: TypedClass (VarList.cons vt1 T1 Gamma) M (Term.classify M) ->
     \vt2: VarType ->
     \prf2: CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp: TypedClass Gamma (Term.pi vt1 T1 S)
     	   	      (Class.constr2prop (Term.classify S)) ->
     I.rsubst Class (Class.constrobj vt2) (Class.prop2constr (Term.classify M))
               (XXX2 Gamma S vt2 prf2 Hyp)
	       (\x:Class -> TypedClass Gamma (Term.lam vt1 T1 M) x)
     (VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term -> A:Term 
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.kindprop vt))
        TypedClass.constr
	TypedClass.obj
	vt2 Gamma (Term.lam vt1 T1 M)
	    (CCTypeCheck.lam Gamma vt1 T1 M S prf1 vt2 prf2)))

     I.rsubst Class (Term.classify M) (Term.classify (Term.shiftvar M))
         (Term.shiftn.classify M Nat.0)
     	 (\x:Class -> TypedClass Gamma M (Term.classify M) ->
	 	   TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) x)
     \
     (TypedClass.rec Gamma M
         (\class: Class \_:TypedClass Gamma M class ->
          TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  TypedClass.kind (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.[] prf3))
	 ; prop
	 (\prf3: CCTypeCheck Gamma M Term.* ->
	  TypedClass.prop (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.* prf3))
	 ; constr
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.[] ->
	  TypedClass.constr (VarList.cons vt T0 Gamma)
	  		    (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.[] prf4))
	 ; obj
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.* prf4))
	 (Term.classify M)))

Definition Term.ispi = 
   Term.rec (\t:Term -> U)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> F)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> T)
      (\M:Term \_:U \N:Term \_:U -> F)
      (\vt:VarType \n:Nat -> F)
      (\vt:VarType -> F)
Definition Term.casepi = \C:(t:Term -> U1)
   \case:(vt:VarType -> T:Term -> S:Term -> C (Term.pi vt T S)) ->
   Term.rec (\t:Term -> Term.ispi t -> C t)
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.lam vt M N)))
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         \_:T -> case vt M N)
      (\M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.app M N)))
      (\vt:VarType \n:Nat -> F.rec (\_:F -> C (Term.var vt n)))
      (\vt:VarType -> F.rec (\_:F -> C (Term.univ vt)))

Inductive KindOrProp : Gamma:VarList -> S:Term -> U =
  kind: CCTypeCheck Gamma S Term.[] -> KindOrProp Gamma S,
  prop: CCTypeCheck Gamma S Term.*  -> KindOrProp Gamma S



Definition PiRangeCorrectType = \Gamma:VarList ->
  Term.casepi (\_:Term -> U)
              (\vt0:VarType \T0:Term \S0:Term ->
	         KindOrProp (VarList.cons vt0 T0 Gamma) S0)

Definition PiRangeCorrect = 
  CCTypeCheck.rec
     (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
      PiRangeCorrectType Gamma M)
    ;ax
    T.tt
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     T.tt)
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     Term.casepi (\M: Term -> S:Term -> CCTypeCheck Gamma M S ->
        PiRangeCorrectType Gamma M ->
        PiRangeCorrectType (VarList.cons vt T0 Gamma) (Term.shiftvar M))
        (\vt1:VarType \T1:Term \S1:Term
	 \S:Term \_:CCTypeCheck Gamma (Term.pi vt1 T1 S1) S ->
	 KindOrProp.rec (VarList.cons vt1 T1 Gamma) S1
	    (\_:KindOrProp (VarList.cons vt1 T1 Gamma) S1 ->
	     KindOrProp (VarList.cons vt1 (Term.shiftvar T1) (VarList.cons vt T0 Gamma)) (Term.shiftn S1 Nat.1))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.[] ->
	     KindOrProp.kind (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0
		 	         (VarList.cons vt1 T1 Gamma) S1 Term.[] prf2
		                 Nat.1 prf))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.* ->
	     KindOrProp.prop (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0
		 	         (VarList.cons vt1 T1 Gamma) S1 Term.* prf2
		                 Nat.1 prf)))
	(\M:Term \S:Term \_:CCTypeCheck Gamma M S
	 \_:PiRangeCorrectType Gamma M ->
	 T.tt))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Inductive TermClass : Gamma:VarList -> M:Term -> U =
  kind   : CCTypeCheck Gamma M Term.[] -> TermClass Gamma M,
  constr : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.[]
           -> TermClass Gamma M,
  obj    : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.*
           -> TermClass Gamma M
  
Definition Term.classify =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
  		   TermClass Gamma M)
    (TermClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList -> VarType.rec
        (\vt:VarType -> T:Term -> CCTypeCheck Gamma T (Term.univ vt) ->
	 TermClass Gamma T ->
	 TermClass (VarList.cons vt T Gamma) (Term.var vt Nat.0))
        (\T:Term \prf:CCTypeCheck Gamma T Term.[] \rec:TermClass Gamma T ->
	 TermClass.constr (VarList.cons VarType.[] T Gamma)
	 		  (Term.var VarType.[] Nat.0)
			  (Term.shiftvar T)
	                  (CCTypeCheck.var Gamma VarType.[] T prf)
	             (CCTypeCheck.weak Gamma VarType.[] T prf T Term.[] prf))
        (\T:Term \prf:CCTypeCheck Gamma T Term.* \rec:TermClass Gamma T ->
	 TermClass.obj (VarList.cons VarType.* T Gamma)
	 	       (Term.var VarType.* Nat.0)
		       (Term.shiftvar T)
	               (CCTypeCheck.var Gamma VarType.* T prf)
		       (CCTypeCheck.weak Gamma VarType.* T prf T Term.* prf)))
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prfvar: CCTypeCheck Gamma T (Term.univ vt) \_: TermClass Gamma T
     \M : Term \S:Term
     \_: CCTypeCheck Gamma M S ->
     TermClass.rec Gamma M (\_:TermClass Gamma M ->
                   TermClass (VarList.cons vt T Gamma) (Term.shiftvar M))
     	;kind
        (\prf1:CCTypeCheck Gamma M Term.[] ->
	 TermClass.kind (VarList.cons vt T Gamma) (Term.shiftvar M)
	                (CCTypeCheck.weak Gamma vt T prfvar
					  M Term.[] prf1))
     	;constr
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.[] ->
	 TermClass.constr (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.[] prf2))
     	;obj
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.* ->
	 TermClass.obj (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.* prf2)))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \prf1:CCTypeCheck Gamma T (Term.univ vt) \rec:TermClass Gamma T ->
     VarType.rec (\vt2:VarType -> S:Term ->
     		  CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
		  TermClass (VarList.cons vt T Gamma) S ->
		  TermClass Gamma (Term.pi vt T S))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.[]
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.kind Gamma (Term.pi vt T S)
	 		(CCTypeCheck.pi Gamma vt T prf1 VarType.[] S prf2))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.*
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.constr Gamma (Term.pi vt T S) Term.*
	 		  (CCTypeCheck.pi Gamma vt T prf1 VarType.* S prf2)
			  (CCTypeCheck.ax2 Gamma (CCTypeCheck.gammatc Gamma T
			  		                 (Term.univ vt) prf1))))
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \prf1:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:TermClass (VarList.cons vt T Gamma) M ->
     VarType.rec (\vt2:VarType -> 
     		  CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
		  TermClass Gamma (Term.pi vt T S) ->
		  TermClass Gamma (Term.lam vt T M))
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.[]
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.constr Gamma (Term.lam vt T M) (Term.pi vt T S)
	 		  (CCTypeCheck.lam Gamma vt T M S prf1 VarType.[] prf2)
			  prf2)
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.*
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.obj Gamma (Term.lam vt T M) (Term.pi vt T S)
	 	       (CCTypeCheck.lam Gamma vt T M S prf1 VarType.* prf2)
		       prf2))
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \prf1:CCTypeCheck Gamma M (Term.pi vt T S) \_:TermClass Gamma M
     \N:Term \prf2:CCTypeCheck Gamma N T \_:TermClass Gamma N ->
     Ter
     TermClass
     TermClass Gamma (Term.app M N)
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:TermClass Gamma M
     \S:Term \_:ConvSymmStep T S -> rec)
    

