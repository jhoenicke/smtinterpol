Inductive Prop : prop:U -> U =
  mk: Prop prop

Inductive T : U = tt:T
Inductive F : U =

Inductive * : A:U -> B:U -> U =
  mk : A->B-> * A B
Definition *.mk = {\A:U} \a:A {\B:U} \b:B -> *.mk A B a b
Definition *.1 = {\A:U} {\B:U} -> *.rec (\_:* A B -> A) (\a:A \_:B -> a)
Definition *.2 = {\A:U} {\B:U} -> *.rec (\_:* A B -> B) (\_:A \b:B -> b)

Inductive + : A:U -> B:U -> U =
  1: A -> + A B,
  2: B -> + A B
Definition +.case = \C:U {\A:U} \1:(A -> C) {\B:U} \2:(B -> C) ->
  +.rec (\_:+ A B -> C) 1 2

Inductive Sigma : {A:U} -> B:(A->U) -> U =
  mk : a:A->b:(B a)-> Sigma B
Definition Sigma.1 = {\A:U} {\B:(A->U)} ->
  Sigma.rec (\_:Sigma B -> A) (\a:A \_:B a -> a)
Definition Sigma.2 = {\A:U} {\B:(A->U)} ->
  Sigma.rec (\p:Sigma B -> B (Sigma.1 p)) (\a:A \b:B a -> b)

Inductive I : {A:U} -> a:A -> b:A -> U =
  r : I a a
Definition T.eq = T.rec (\t1:T -> t2:T -> I t1 t2) (T.rec (I T.tt) (I.r T.tt))

Definition I.subst = {\A:U} {\a:A} {\b:A} \eq:I a b \C:(A -> U) ->
    I.rec (\x:A \_:I a x -> C a -> C x)
      (\z:C a -> z) eq
TypeCheck I.subst :
  {A:U} -> {a:A} -> {b:A} -> I a b -> C:(A -> U) -> C a -> C b
Definition I.symm = {\A:U} {\a:A} {\b:A} \eq:I a b ->
  I.subst eq (\x:A -> I x a) (I.r a)
Definition I.trans = {\A:U} {\a:A} {\b:A} \eq1:I a b {\c:A} \eq2:I b c ->
  I.subst eq2 (\x:A -> I a x) eq1
Definition I.subst2 = {\A:U} {\a1:A} {\a2:A} \eq1:I a1 a2
	              {\B:U} {\b1:B} {\b2:B} \eq2:I b1 b2
		      \C:(A -> B -> U) ->
  I.subst eq2 (\b:B -> C a1 b1 -> C a2 b)
    (I.subst eq1 (\a:A -> C a b1))
TypeCheck I.subst2 :
  {A:U} -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {B:U} -> {b1:B} -> {b2:B} -> I b1 b2 -> C:(A -> B -> U) -> C a1 b1 -> C a2 b2
Definition I.rsubst = {\A:U} {\b:A} {\a:A} \eq:I a b \C:(A -> U) ->
    I.subst (I.symm eq) C
Definition I.cong = {\A:U} {\B:U}
  \c:(A -> B) {\a:A} {\b:A} \eq: I a b ->
    I.subst eq (\x:A -> I (c a) (c x)) (I.r (c a))
TypeCheck I.cong :
  A:U -> B:U -> c:(A -> B) -> {a:A} -> {b:A} -> I a b -> I (c a) (c b)
Definition I.cong2 = {\A:U} {\B:U} {\C:U} \f:(A->B->C)
  {\a1:A} {\a2:A} \eq1: I a1 a2 {\b1:B}{\b2:B} \eq2: I b1 b2 ->
  I.subst eq1 (\x:A -> I (f a1 b1) (f x b2)) (I.cong (f a1) eq2)
TypeCheck I.cong2 :
  {A:U} -> {B:U} -> {C:U} -> f:(A -> B -> C) -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {b1:B} -> {b2:B} -> I b1 b2 -> I (f a1 b1) (f a2 b2)
Definition I.cong3 = {\A:U} {\B:U} {\C:U} {\D:U} \f:(A->B->C->D)
  {\a1:A} {\a2:A} \eq1: I a1 a2 {\b1:B}{\b2:B} \eq2: I b1 b2
  {\c1:C} {\c2:C} \eq3: I c1 c2 ->
  I.subst eq1 (\x:A -> I (f a1 b1 c1) (f x b2 c2)) (I.cong2 (f a1) eq2 eq3)

Inductive Bool : U = tt:Bool, ff:Bool
Definition Bool.ite = \b:Bool {\C:U} \t:C \e:C ->
  Bool.rec (\_:Bool -> C) t e b

;===========================================
;  Natural Numbers
;===========================================

Inductive Nat : U =
  0 : Nat,
  s : Nat -> Nat
Definition Nat.1 = Nat.s Nat.0

Definition Nat.plus = Nat.rec (\_:Nat -> Nat -> Nat)
    (\b:Nat -> b) (\a:Nat \rec:(Nat->Nat) \b:Nat -> Nat.s (rec b))

Definition Nat.plus.zero =
    Nat.rec (\a:Nat -> I (Nat.plus a Nat.0) a)
       (I.r Nat.0)
       (\a:Nat \Hyp:I (Nat.plus a Nat.0) a -> I.cong Nat.s Hyp)
Definition Nat.s.plus.commutes = \a:Nat \b:Nat ->
    Nat.rec (\a:Nat -> I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)))
       (I.r (Nat.s b))
       (\a:Nat \Hyp: I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)) ->
        I.subst Hyp
	   (\x:Nat -> I (Nat.s (Nat.s (Nat.plus a b))) (Nat.s x))
	   (I.r (Nat.s (Nat.s (Nat.plus a b)))))
       a

Definition Nat.plus.commutes = \a:Nat ->
    Nat.rec (\b:Nat -> I (Nat.plus a b) (Nat.plus b a))
       (Nat.plus.zero a)
       (\b:Nat \Hyp:I (Nat.plus a b) (Nat.plus b a) ->
        I.subst Hyp
	        (\x:Nat -> I (Nat.plus a (Nat.s b)) (Nat.s x))
		(I.symm (Nat.s.plus.commutes a b)))

Definition Nat.iter = {\A:U} \f:(A->A) ->
  Nat.rec (\n:Nat -> A -> A) (\a:A -> a) (\_:Nat \rec:(A->A) \a:A -> f (rec a))
Definition Nat.iter.associative = {\A:U} \f:(A->A) \n:Nat \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)))
    (I.r (f a))
    (\n:Nat \Hyp:I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)) ->
     I.cong f Hyp)
    n
Definition Nat.iter.plus = {\A:U} \f:(A->A) \m:Nat \n:Nat \a:A ->
  Nat.rec (\m:Nat -> I (Nat.iter f m (Nat.iter f n a))
                       (Nat.iter f (Nat.plus m n) a))
    (I.r (Nat.iter f n a))
    (\m:Nat
     \eq:I (Nat.iter f m (Nat.iter f n a)) (Nat.iter f (Nat.plus m n) a) ->
     I.cong f eq)
    m

Definition Nat.iter.g.commutes = \A:U \f:(A->A) \g:(A->A)
  \fgcommutes:(a:A -> I (f (g a)) (g (f a))) \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f n (g a)) (g (Nat.iter f n a)))
    (I.r (g a))
    (\n:Nat\Hyp:I (Nat.iter f n (g a)) (g (Nat.iter f n a)) ->
     I.subst (fgcommutes (Nat.iter f n a))
        (\x:A -> I (Nat.iter f (Nat.s n) (g a)) x)
        (I.cong f Hyp))

;===========================================
;  Terms
;===========================================

Inductive VarType : U = []:VarType, *:VarType

Inductive Term : U =
  lam   : VarType -> Term -> Term -> Term,
  pi    : VarType -> Term -> Term -> Term,
  app   : Term -> Term -> Term,
  var   : VarType -> Nat -> Term,
  univ  : VarType -> Term

Definition Term.[] = Term.univ VarType.[]
Definition Term.*  = Term.univ VarType.*

;===========================================
;  variable shifting
;===========================================

; increment m by one, if m greater equal n.
Definition Nat.shiftn =
  Nat.rec (\n:Nat -> m:Nat -> Nat)
     Nat.s
     (\_:Nat \shiftn1:(Nat -> Nat) ->
       Nat.rec (\m:Nat -> Nat) Nat.0
	  (\m1:Nat \_:Nat -> Nat.s (shiftn1 m1)))

; Increment all variables >= n by one.
Definition Term.shiftn =
  Term.rec (\_:Term -> n:Nat -> Term)
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.lam vt (rt1 n) (rt2 (Nat.s n)))
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.pi vt (rt1 n) (rt2 (Nat.s n)))
    (\_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.app (rt1 n) (rt2 n))
    (\vt:VarType \i: Nat \n:Nat -> Term.var vt (Nat.shiftn n i))
    (\vt:VarType \n: Nat -> Term.univ vt)
Definition Term.shiftvar = \term:Term ->
    Term.shiftn term Nat.0

;  swap shiftn
Definition Nat.shiftn.commutes = \m:Nat ->
   Let Thesis = (\n:Nat -> \i:Nat ->
        I (Nat.shiftn n (Nat.shiftn (Nat.plus n m) i))
          (Nat.shiftn (Nat.s (Nat.plus n m)) (Nat.shiftn n i))) ->
   Nat.rec (\n:Nat -> i:Nat -> Thesis n i)
     (\i:Nat -> I.r (Nat.s (Nat.shiftn m i)))
     (\n:Nat \HypN: (i:Nat -> Thesis n i) ->
      Nat.rec (\i:Nat -> Thesis (Nat.s n) i)
        (I.r Nat.0)
	(\i:Nat \_:Thesis (Nat.s n) i ->
	 I.cong Nat.s (HypN i)))

Definition Term.shiftn.commutes = \m:Nat ->
   Let Thesis = (\T:Term -> n:Nat -> 
       I (Term.shiftn (Term.shiftn T (Nat.plus n m)) n)
       	 (Term.shiftn (Term.shiftn T n) (Nat.s (Nat.plus n m)))) ->
   Term.rec (\T:Term -> Thesis T)
     (\vt:VarType \S:Term \HypS:Thesis S \M:Term \HypM:Thesis M
      \n:Nat -> I.cong2 (Term.lam vt) (HypS n) (HypM (Nat.s n)))
     (\vt:VarType \S:Term \HypS:Thesis S \M:Term \HypM:Thesis M
      \n:Nat -> I.cong2 (Term.pi vt) (HypS n) (HypM (Nat.s n)))
     (\S:Term \HypS:Thesis S \M:Term \HypM:Thesis M
      \n:Nat -> I.cong2 Term.app (HypS n) (HypM n))
     (\vt:VarType \i:Nat \n:Nat ->
      I.cong (Term.var vt) (Nat.shiftn.commutes m n i))
     (\vt:VarType \n:Nat -> I.r (Term.univ vt))
TypeCheck Term.shiftn.commutes : m:Nat -> T:Term -> n:Nat -> 
    I (Term.shiftn (Term.shiftn T (Nat.plus n m)) n)
      (Term.shiftn (Term.shiftn T n) (Nat.s (Nat.plus n m)))

Definition Term.shiftvarn.commutes  = \T:Term \n:Nat ->
     Term.shiftn.commutes n T Nat.0
TypeCheck Term.shiftvarn.commutes : T:Term -> n:Nat ->
     I (Term.shiftvar (Term.shiftn T n))
       (Term.shiftn (Term.shiftvar T) (Nat.s n))

;===========================================
;  Substitutions
;===========================================

; Apply substitute on variable x_i.
; x_n by subst, decrementing all bigger variables
; i<n : return x_i
; i=n : return subst
; i>n : return x_{i-1}
Definition Term.var.substn = \vt:VarType \subst:Term ->
  Nat.rec (\n:Nat -> i:Nat -> Term)
     (Nat.rec (\i:Nat -> Term)
     	 subst
	 (\i1:Nat\_:Term -> Term.var vt i1))
     (\_:Nat \shiftn1:(i:Nat -> Term) ->
      Nat.rec (\i:Nat -> Term)
         (Term.var vt Nat.0)
	 (\i1:Nat \_:Term -> Term.shiftvar (shiftn1 i1)))


Definition Term.substn =
  Term.rec (\_:Term -> n:Nat -> Term -> Term)
    (\vt:VarType \_: Term \r1:(Nat->Term->Term)
     \_:Term \r2:(Nat->Term -> Term)
     \n:Nat \subst:Term ->
     Term.lam vt (r1 n subst) (r2 (Nat.s n) subst))
    (\vt:VarType \_: Term \r1:(Nat->Term->Term)
     \_:Term \r2:(Nat->Term -> Term)
     \n:Nat \subst:Term ->
     Term.pi vt (r1 n subst) (r2 (Nat.s n) subst))
    (\_: Term \r1:(Nat->Term->Term)
     \_:Term \r2:(Nat->Term -> Term)
     \n:Nat \subst:Term ->
     Term.app (r1 n subst) (r2 n subst))
    (\vt:VarType \i:Nat \n:Nat \subst:Term -> Term.var.substn vt subst n i)
    (\vt:VarType \n:Nat \subst:Term -> Term.univ vt)

Definition Term.subst = \term:Term \subst:Term ->
    Term.substn term Nat.0 subst

;; Lemma 1: Substitution on M.shift
;; I (Term.subst (Term.shiftvar M) N) M
Definition Term.substn.shiftn.id =
  Let Thesis = (\M:Term -> n:Nat ->
     N:Term -> I (Term.substn (Term.shiftn M n) n N) M) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 (Term.lam vt) (HypM1 n N) (HypM2 (Nat.s n) N))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 (Term.pi vt) (HypM1 n N) (HypM2 (Nat.s n) N))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 Term.app (HypM1 n N) (HypM2 n N))
    (\vt:VarType \i:Nat \n:Nat \N:Term ->
     Let Aux = (\n:Nat \i:Nat -> 
           I (Term.var.substn vt N n (Nat.shiftn n i))
    	     (Term.var vt i)) ->
     Nat.rec (\n:Nat -> i:Nat -> Aux n i)
        (\i:Nat ->
           I.r (Term.var vt i))
        (\n:Nat \Hyp:(i:Nat -> Aux n i) ->
          Nat.rec (\i:Nat -> Aux (Nat.s n) i)
             (I.r (Term.var vt Nat.0))
             (\i:Nat \_:(Aux (Nat.s n) i) ->
	      I.cong Term.shiftvar (Hyp i)))
     n i)
    (\vt:VarType \n:Nat \N:Term -> I.r (Term.univ vt))
Definition Term.shiftvar.subst.id = \M:Term \N:Term ->
  Term.substn.shiftn.id M Nat.0 N
	     
;; Lemma 2: Arbitrary Substitution on M.shift
;; I (Term.substn (Term.shiftvar M) (Nat.s i) N)
;;   (Term.shiftvar (Term.substn M i N))
Definition Term.substn.shiftvar.commutes = \i:Nat \N:Term ->
  Let Thesis = (\M:Term -> n:Nat ->
      I (Term.substn (Term.shiftn M n) (Nat.s (Nat.plus n i)) N)
      	(Term.shiftn (Term.substn M (Nat.plus n i) N) n)) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \j:Nat \n:Nat ->
     Let Aux = (\n:Nat \j:Nat -> 
           I (Term.var.substn vt N (Nat.s (Nat.plus n i)) (Nat.shiftn n j))
    	     (Term.shiftn (Term.var.substn vt N (Nat.plus n i) j) n)) ->
     Nat.rec (\n:Nat -> j:Nat -> Aux n j)
        (\j:Nat ->
           I.r (Term.var.substn vt N (Nat.s i) (Nat.s j)))
        (\n:Nat \Hyp:(j:Nat -> Aux n j) ->
          Nat.rec (\j:Nat -> Aux (Nat.s n) j)
             (I.r (Term.var vt Nat.0))
             (\j:Nat \_:(Aux (Nat.s n) j) ->
	      I.trans (I.cong Term.shiftvar (Hyp j))
	      	      (Term.shiftvarn.commutes
		         (Term.var.substn vt N (Nat.plus n i) j) n)))
     n j)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))
  
Definition Term.subst.shiftvar.commutes = \M:Term \i:Nat \N:Term ->
  Term.substn.shiftvar.commutes i N M Nat.0

;; Lemma 3: Nested Substitutions
;; I (Term.subst (Term.substn M n2+1 N2) (Term.substn N n2 N2))
;;   (Term.substn (Term.subst M N) n2 N2)
Definition Term.substn.commutes = \N:Term \n2:Nat \N2:Term ->
  Let Thesis = (\M:Term -> n:Nat ->
    I (Term.substn (Term.substn M (Nat.s (Nat.plus n n2)) N2)
                   n (Term.substn N n2 N2))
      (Term.substn (Term.substn M n N) (Nat.plus n n2) N2)) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \i:Nat \n:Nat ->
     Let Aux = (\n:Nat \i:Nat -> 
           I (Term.substn (Term.var.substn vt N2 (Nat.s (Nat.plus n n2)) i)
	     		  n (Term.substn N n2 N2))
    	     (Term.substn (Term.var.substn vt N n i) (Nat.plus n n2) N2)) ->
     Nat.rec (\n:Nat -> i:Nat -> Aux n i)
        (Nat.rec (\i:Nat -> Aux Nat.0 i)
	   (I.r (Term.substn N n2 N2))
	   (\i:Nat \_:Aux Nat.0 i ->
	    Term.substn.shiftn.id (Term.var.substn vt N2 n2 i)
	   	      Nat.0 (Term.substn N n2 N2)))
        (\n:Nat \Hyp:(i:Nat -> Aux n i) ->
          Nat.rec (\i:Nat -> Aux (Nat.s n) i)
             (I.r (Term.var vt Nat.0))
             (\i:Nat \_:(Aux (Nat.s n) i) ->
	      I.trans (Term.subst.shiftvar.commutes
	      	         (Term.var.substn vt N2 (Nat.s (Nat.plus n n2)) i)
			 n (Term.substn N n2 N2))
	      (I.trans (I.cong Term.shiftvar (Hyp i))
	      (I.symm  (Term.subst.shiftvar.commutes
	      	         (Term.var.substn vt N n i) (Nat.plus n n2) N2)))))
     n i)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))

Definition Term.subst.substn.commutes = \M:Term \N:Term \n2:Nat \N2:Term ->
   Term.substn.commutes N n2 N2 M Nat.0

TypeCheck Term.subst.substn.commutes : M:Term -> N:Term -> n2:Nat -> N2:Term ->
   I (Term.subst (Term.substn M (Nat.s n2) N2) (Term.substn N n2 N2))
     (Term.substn (Term.subst M N) n2 N2)

;; Lemma 4: Shift and Substitution
;; I (Term.shiftn (Term.subst M N) n2)
;;   (Term.subst (Term.shiftn M (Nat.s n2)) (Term.shiftn N n))
Definition Term.subst.shiftn = \N:Term \n2:Nat ->
  Let Thesis = (\M:Term -> n:Nat ->
    I (Term.substn (Term.shiftn M (Nat.s (Nat.plus n n2)))
                   n (Term.shiftn N n2))
      (Term.shiftn (Term.substn M n N) (Nat.plus n n2))) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \i:Nat \n:Nat ->
     Let Aux = (\n:Nat \i:Nat -> 
           I (Term.var.substn vt (Term.shiftn N n2) n
	     		      (Nat.shiftn (Nat.s (Nat.plus n n2)) i))
    	     (Term.shiftn (Term.var.substn vt N n i) (Nat.plus n n2))) ->
     Nat.rec (\n:Nat -> i:Nat -> Aux n i)
        (Nat.rec (\i:Nat -> Aux Nat.0 i)
	   (I.r (Term.shiftn N n2))
	   (\i:Nat \_:Aux Nat.0 i ->
	    Term.substn.shiftn.id (Term.var vt (Nat.shiftn n2 i))
	   	      Nat.0 (Term.shiftn N n2)))
        (\n:Nat \Hyp:(i:Nat -> Aux n i) ->
          Nat.rec (\i:Nat -> Aux (Nat.s n) i)
             (I.r (Term.var vt Nat.0))
             (\i:Nat \_:(Aux (Nat.s n) i) ->
	      I.trans (Term.subst.shiftvar.commutes
	      	         (Term.var vt (Nat.shiftn (Nat.s (Nat.plus n n2)) i))
			 n (Term.shiftn N n2))
	      (I.trans (I.cong Term.shiftvar (Hyp i))
	               (Term.shiftvarn.commutes
	      	         (Term.var.substn vt N n i) (Nat.plus n n2)))))
     n i)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))
Definition Term.subst.shift = \t:Term \subst:Term \n:Nat ->
    I.symm (Term.subst.shiftn subst n t Nat.0)

TypeCheck Term.subst.shift : t:Term -> subst:Term -> n:Nat ->
    I (Term.shiftn (Term.subst t subst) n)
      (Term.subst (Term.shiftn t (Nat.s n)) (Term.shiftn subst n))


Inductive ConvStep : Term -> Term -> U =
  beta : vt:VarType -> T:Term -> M:Term -> N:Term ->
         ConvStep (Term.app (Term.lam vt T M) N) (Term.subst M N),
  lam1 : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.lam vt T1 M) (Term.lam vt T2 M),
  lam2 : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.lam vt T M1) (Term.lam vt T M2),
  pi1  : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.pi vt T1 M) (Term.pi vt T2 M),
  pi2  : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.pi vt T M1) (Term.pi vt T M2),
  app1 : {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> N:Term ->
         ConvStep (Term.app M1 N) (Term.app M2 N),
  app2 : M:Term -> {N1:Term} -> {N2:Term} -> ConvStep N1 N2 ->
         ConvStep (Term.app M N1) (Term.app M N2)

Definition ConvStep.shiftn = 
  Let Thesis = (\T:Term \S:Term -> n:Nat ->
      ConvStep (Term.shiftn T n) (Term.shiftn S n)) ->
  ConvStep.rec (\T:Term \S: Term \step : ConvStep T S -> Thesis T S)
    (\vt:VarType \T:Term \M:Term \N:Term \n:Nat ->
     I.rsubst (Term.subst.shift M N n)
	      (\x: Term ->
	       ConvStep (Term.shiftn (Term.app (Term.lam vt T M) N) n) x)
     (ConvStep.beta vt (Term.shiftn T n) (Term.shiftn M (Nat.s n))
		    (Term.shiftn N n)))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n:Nat ->
     ConvStep.lam1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n:Nat ->
     ConvStep.lam2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n:Nat ->
     ConvStep.pi1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n:Nat ->
     ConvStep.pi2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n:Nat ->
     ConvStep.app1 (hyp n) (Term.shiftn M n))
    (\T:Term \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \n:Nat ->
     ConvStep.app2 (Term.shiftn T n) (hyp n))

Definition ConvStep.substn =
  Let Thesis = (\T:Term \S:Term -> n2:Nat -> N2:Term ->
      ConvStep (Term.substn T n2 N2) (Term.substn S n2 N2)) ->
  ConvStep.rec ({\T:Term} {\S: Term} \step : ConvStep T S -> Thesis T S)
    (\vt:VarType \T:Term \M:Term \N:Term \n2:Nat \N2:Term ->
     I.subst (Term.subst.substn.commutes M N n2 N2)
	     (\x: Term ->
	      ConvStep (Term.substn (Term.app (Term.lam vt T M) N) n2 N2) x)
     (ConvStep.beta vt (Term.substn T n2 N2)
     		    (Term.substn M (Nat.s n2) N2) (Term.substn N n2 N2)))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n2:Nat \N2:Term ->
     ConvStep.lam1 vt (hyp n2 N2) (Term.substn M (Nat.s n2) N2))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n2:Nat \N2:Term ->
     ConvStep.lam2 vt (hyp (Nat.s n2) N2) (Term.substn T n2 N2))
    (\vt:VarType \T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n2:Nat \N2:Term ->
     ConvStep.pi1 vt (hyp n2 N2) (Term.substn M (Nat.s n2) N2))
    (\vt:VarType \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \T:Term \n2:Nat \N2:Term ->
     ConvStep.pi2 vt (hyp (Nat.s n2) N2) (Term.substn T n2 N2))
    (\T1:Term \T2:Term \step:ConvStep T1 T2 \hyp:Thesis T1 T2
     \M:Term \n2:Nat \N2:Term ->
     ConvStep.app1 (hyp n2 N2) (Term.substn M n2 N2))
    (\T:Term \M1:Term \M2:Term \step:ConvStep M1 M2 \hyp:Thesis M1 M2
     \n2:Nat \N2:Term ->
     ConvStep.app2 (Term.substn T n2 N2) (hyp n2 N2))

Inductive ConvSymmStep : M:Term -> N:Term -> U =
  forw : ConvStep M N -> ConvSymmStep M N,
  back : ConvStep N M -> ConvSymmStep M N

Definition ConvSymmStep.shiftn = {\T:Term} {\S: Term} ->
   ConvSymmStep.rec (\step : ConvSymmStep T S -> n:Nat -> 
                         ConvSymmStep (Term.shiftn T n) (Term.shiftn S n))
	(\fstep:ConvStep T S \n:Nat ->
	 ConvSymmStep.forw (Term.shiftn T n) (Term.shiftn S n)
	 		   (ConvStep.shiftn fstep n))
	(\bstep:ConvStep S T \n:Nat ->
	 ConvSymmStep.back (Term.shiftn T n) (Term.shiftn S n)
	 		   (ConvStep.shiftn bstep n))

Definition ConvSymmStep.substn = {\T:Term} {\S: Term} ->
   ConvSymmStep.rec (\step : ConvSymmStep T S -> n2:Nat -> N2:Term -> 
                         ConvSymmStep (Term.substn T n2 N2) (Term.substn S n2 N2))
	(\fstep:ConvStep T S \n2:Nat \N2:Term ->
	 ConvSymmStep.forw (Term.substn T n2 N2) (Term.substn S n2 N2)
	 		   (ConvStep.substn fstep n2 N2))
	(\bstep:ConvStep S T \n2:Nat \N2:Term ->
	 ConvSymmStep.back (Term.substn T n2 N2) (Term.substn S n2 N2)
	 		   (ConvStep.substn bstep n2 N2))

Inductive List : A:U -> U =
  nil  : List A,
  cons : A -> List A -> List A

Inductive VarList : U =
  nil  : VarList,
  cons : vt:VarType -> T:Term -> Gamma:VarList -> VarList

Definition VarList.append = \Gamma:VarList ->
  VarList.rec (\_:VarList -> VarList) Gamma
     (\vt0:VarType \T0:Term \_:VarList \rec:VarList ->
      VarList.cons vt0 T0 rec)
Definition VarList.len =
  VarList.rec (\_:VarList -> Nat) Nat.0
     (\vt0:VarType \T0:Term \_:VarList \rec:Nat -> Nat.s rec)

Inductive CCTypeCheck : VarList -> Term -> Term -> U =
  ax   : CCTypeCheck VarList.nil Term.* Term.[],
  var  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.var vt Nat.0) (Term.shiftvar T),
  weak : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         {M : Term} -> {S:Term} -> CCTypeCheck Gamma M S ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.shiftvar M) (Term.shiftvar S),
  pi   : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
	 {vt2 : VarType} -> {S : Term} ->
	 CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2),
  lam  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         {M:Term} -> {S:Term} ->
         CCTypeCheck (VarList.cons vt T Gamma) M S ->
	 {vt2: VarType} -> CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.lam vt T M) (Term.pi vt T S),
  app  : {Gamma:VarList} -> {M:Term} -> {vt: VarType} -> {T : Term} -> {S:Term} ->
         CCTypeCheck Gamma M (Term.pi vt T S) ->
	 {N : Term} -> CCTypeCheck Gamma N T ->
	 CCTypeCheck Gamma (Term.app M N) (Term.subst S N),
  conv : {Gamma:VarList} -> {M:Term} -> {T:Term} -> CCTypeCheck Gamma M T ->
	 {S : Term} -> ConvSymmStep T S ->
	 CCTypeCheck Gamma M S

Inductive VarListTypeCheck : VarList -> U =
  nil  : VarListTypeCheck VarList.nil,
  cons : {vt:VarType} -> {T:Term} -> {Gamma:VarList} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
 	 VarListTypeCheck Gamma -> 
         VarListTypeCheck (VarList.cons vt T Gamma)

Definition CCTypeCheck.ax2 = 
  VarListTypeCheck.rec ({\Gamma:VarList} \_:VarListTypeCheck Gamma ->
                        CCTypeCheck Gamma Term.* Term.[])
     CCTypeCheck.ax
     (\vt:VarType \T:Term \Gamma:VarList
      \tc:CCTypeCheck Gamma T (Term.univ vt)
      \_:VarListTypeCheck Gamma
      \r:CCTypeCheck Gamma Term.* Term.[] ->
        CCTypeCheck.weak tc r)

Definition CCTypeCheck.gammatc =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
                   VarListTypeCheck Gamma)
    VarListTypeCheck.nil
    ;var
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma
     \M : Term \S:Term \_: CCTypeCheck Gamma M S \_:VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Definition VarList.deleten =
  Nat.rec (\n:Nat -> VarList -> VarList)
    (\Gamma:VarList -> Gamma)
    (\_:Nat \delrec:(VarList -> VarList) ->
     VarList.rec (\Gamma:VarList -> VarList) VarList.nil
        (\vt1:VarType \T1:Term \Gamma:VarList \_:VarList -> delrec Gamma))
    
Definition VarList.insertn =
  Nat.rec (\n:Nat -> VarType -> Term -> VarList -> VarList)
    VarList.cons
    (\n:Nat \insertrec:(VarType -> Term -> VarList -> VarList)
     \vt:VarType \T0:Term ->
     VarList.rec (\Gamma:VarList -> VarList)
        (insertrec vt T0 VarList.nil)
	(\vt1:VarType \T1:Term \Gamma:VarList \_:VarList ->
	 VarList.cons vt1 (Term.shiftn T1 n) (insertrec vt T0 Gamma)))
	 
Definition deletenil =
  Nat.rec (\n:Nat -> I (VarList.deleten n VarList.nil) VarList.nil)
     (I.r VarList.nil)
     (\n:Nat \_:I (VarList.deleten n VarList.nil) VarList.nil ->
      I.r VarList.nil)

Definition CCTypeCheck.weakn =
  \vt:VarType \T0:Term ->
  CCTypeCheck.rec ({\Gamma:VarList} {\M:Term} {\N:Term}
  		   \_:CCTypeCheck Gamma M N ->
                   n:Nat ->
		   CCTypeCheck (VarList.deleten n Gamma)
		       		T0 (Term.univ vt) ->
                   CCTypeCheck (VarList.insertn n vt T0 Gamma)
		                (Term.shiftn M n)
				(Term.shiftn N n))
    ;ax
    (Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
	      CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                    (Term.shiftn Term.* n)
				    (Term.shiftn Term.[] n))
       (\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 CCTypeCheck.ax)
       (\n:Nat
        \rec:(CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
              CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                 (Term.shiftn Term.* n)
				 (Term.shiftn Term.[] n))
	\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
	rec (I.rsubst (deletenil n)
		      (\x:VarList -> CCTypeCheck x T0 (Term.univ vt))
		      prfT0)))
    ;var
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.var vt1 Nat.0) n)
			  (Term.shiftn (Term.shiftvar T1) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.var prf1))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.var vt1 Nat.0) n)
			 (Term.shiftn (Term.shiftvar T1) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst (Term.shiftvarn.commutes T1 n)
	        (\x:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       (Term.var vt1 Nat.0)  x)
	 (CCTypeCheck.var (Hyp n prfT0))))
    ;weak
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \M : Term \S:Term
     \prf2: CCTypeCheck Gamma M S
     \Hyp2: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma) 
	              (Term.shiftn M n) (Term.shiftn S n)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.shiftvar M) n)
			  (Term.shiftn (Term.shiftvar S) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.weak prf1 prf2))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.shiftvar M) n)
			 (Term.shiftn (Term.shiftvar S) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst2 (Term.shiftvarn.commutes M n)
		 (Term.shiftvarn.commutes S n)
	         (\x:Term \y:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       x y)
	 (CCTypeCheck.weak (Hyp1 n prfT0) (Hyp2 n prfT0))))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \vt2:VarType \S:Term
     \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n
     	    	          (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                 (Term.shiftn S n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.pi (Hyp1 n prfT0) (Hyp2 (Nat.s n) prfT0))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	    		T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                (Term.shiftn M n) (Term.shiftn S n)) ->
     \vt2:VarType
     \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn (Term.pi vt1 T1 S) n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.lam (Hyp1 (Nat.s n) prfT0) (Hyp2 n prfT0))
    ;app
    (\Gamma:VarList \M:Term \vt1:VarType \T1:Term \S:Term
     \prf1: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn (Term.pi vt1 T1 S) n)) ->
     \N:Term
     \prf2:CCTypeCheck Gamma N T1
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn N n) (Term.shiftn T1 n))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     I.rsubst (Term.subst.shift S N n)
	      (\x: Term -> CCTypeCheck (VarList.insertn n vt T0 Gamma)
	      	                       (Term.shiftn (Term.app M N) n) x)
     (CCTypeCheck.app (Hyp1 n prfT0) (Hyp2 n prfT0)))
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \prf1: CCTypeCheck Gamma M T
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn T n))
     \S:Term \step:ConvSymmStep T S
     \n:Nat 
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     (CCTypeCheck.conv (Hyp1 n prfT0) (ConvSymmStep.shiftn step n)))

Definition VarList.subst.nth = \N:Term ->
  VarList.rec (\_:VarList -> Nat -> VarList)
    (\n:Nat -> VarList.nil)
    (\vt1:VarType \T1:Term \Gamma:VarList \Hyp:(Nat -> VarList) ->
    Nat.rec (\i:Nat -> VarList)
      Gamma
      (\i:Nat \_:VarList -> VarList.cons vt1 (Term.substn T1 i N) (Hyp i)))

Definition VarList.TypeCheck.nth = \N:Term ->
  VarList.rec (\_:VarList -> Nat -> U)
    (\n:Nat -> F)
    (\vt1:VarType \T1:Term \Gamma:VarList \Hyp:(Nat -> U) ->
    Nat.rec (\i:Nat -> U)
      (CCTypeCheck Gamma N T1)
      (\i:Nat \_:U -> Hyp i))

Definition CCTypeCheck.substn = \vt:VarType \T0:Term \N:Term ->
  Let Thesis = (\Gamma:VarList \M:Term \S:Term \n:Nat ->
     VarList.TypeCheck.nth N Gamma n ->
     CCTypeCheck (VarList.subst.nth N Gamma n)
     		 (Term.substn M n N) (Term.substn S n N)) ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term
                   \_:CCTypeCheck Gamma M S -> n:Nat -> Thesis Gamma M S n)
     ;ax
     (\n:Nat -> F.rec (\_:F -> CCTypeCheck VarList.nil Term.* Term.[]))
     ; var
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n) ->
      Nat.rec (\n:Nat -> Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	 	(Term.var vt1 Nat.0) (Term.shiftvar T1) n)
	  (I.rsubst (Term.shiftvar.subst.id T1 N)
	   	    (\x:Term -> CCTypeCheck Gamma N x))
	  (\n:Nat\_:(Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	    (Term.var vt1 Nat.0) (Term.shiftvar T1) n) ->
	   \prfN: VarList.TypeCheck.nth N Gamma n ->
	   I.rsubst (Term.subst.shiftvar.commutes T1 n N)
		    (\x:Term -> CCTypeCheck
		    	 (VarList.subst.nth N (VarList.cons vt1 T1 Gamma)
			 		    (Nat.s n))
			 (Term.var vt1 Nat.0) x)
		    (CCTypeCheck.var (Hyp n prfN))))
     ; weak
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n)
      \M1:Term \S1:Term
      \prf2:CCTypeCheck Gamma M1 S1
      \Hyp2:(n:Nat -> Thesis Gamma M1 S1 n) ->
      Nat.rec (\n:Nat -> Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	 	(Term.shiftvar M1) (Term.shiftvar S1) n)
	  (\_:CCTypeCheck Gamma N T1 ->
	   I.subst2 (I.symm (Term.shiftvar.subst.id M1 N))
	  	    (I.symm (Term.shiftvar.subst.id S1 N))
	   	    (\x:Term \y:Term -> CCTypeCheck Gamma x y)
		    prf2)
	  (\n:Nat\_:(Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	    (Term.shiftvar M1) (Term.shiftvar S1) n) ->
	   \prfN: VarList.TypeCheck.nth N Gamma n ->
	   I.subst2 (I.symm (Term.subst.shiftvar.commutes M1 n N))
	   	    (I.symm (Term.subst.shiftvar.commutes S1 n N))
		    (\x:Term \y:Term ->
		     CCTypeCheck (VarList.subst.nth N
		    		  (VarList.cons vt1 T1 Gamma) (Nat.s n)) x y)
		    (CCTypeCheck.weak (Hyp1 n prfN) (Hyp2 n prfN))))
     ; pi
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n)
      \vt2:VarType \S:Term
      \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
      \Hyp2:(n:Nat -> Thesis (VarList.cons vt1 T1 Gamma) S (Term.univ vt2) n)
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      CCTypeCheck.pi (Hyp1 n prfN) (Hyp2 (Nat.s n) prfN))
     ; lam
     (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
      \prf1:CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
      \Hyp1:(n:Nat -> Thesis (VarList.cons vt1 T1 Gamma) M S n)
      \vt2:VarType
      \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
      \Hyp2:(n:Nat -> Thesis Gamma (Term.pi vt1 T1 S) (Term.univ vt2) n)
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      CCTypeCheck.lam (Hyp1 (Nat.s n) prfN) (Hyp2 n prfN))
     ; app
     (\Gamma:VarList \M1:Term \vt1:VarType \T1:Term \S:Term
      \prf1:CCTypeCheck Gamma M1 (Term.pi vt1 T1 S)
      \Hyp1:(n:Nat -> Thesis Gamma M1 (Term.pi vt1 T1 S) n)
      \M2:Term
      \prf2:CCTypeCheck Gamma M2 T1
      \Hyp2:(n:Nat -> Thesis Gamma M2 T1 n)
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      I.subst (Term.subst.substn.commutes S M2 n N)
	     (\x:Term ->
	      CCTypeCheck (VarList.subst.nth N Gamma n)
	      		  (Term.substn (Term.app M1 M2) n N) x)
             (CCTypeCheck.app (Hyp1 n prfN) (Hyp2 n prfN)))
     ; conv
     (\Gamma:VarList \M:Term \S1:Term
      \prf1:CCTypeCheck Gamma M S1
      \Hyp1:(n:Nat -> Thesis Gamma M S1 n)
      \S2:Term
      \prf2:ConvSymmStep S1 S2
      \n:Nat
      \prfN: VarList.TypeCheck.nth N Gamma n ->
      CCTypeCheck.conv (Hyp1 n prfN) (ConvSymmStep.substn prf2 n N))

Definition CCTypeCheck.subst =
  {\vt0:VarType} {\T0:Term} {\Gamma:VarList} {\M:Term} {\S:Term}
  \prf:CCTypeCheck (VarList.cons vt0 T0 Gamma) M S {\N:Term} ->
  CCTypeCheck.substn vt0 T0 N prf Nat.0

TypeCheck CCTypeCheck.subst :
  (vt0:VarType -> T0:Term -> Gamma:VarList -> M:Term -> S:Term ->
  CCTypeCheck (VarList.cons vt0 T0 Gamma) M S -> N:Term -> 
  CCTypeCheck Gamma N T0 ->
  CCTypeCheck Gamma (Term.subst M N) (Term.subst S N))

;=================================
; Term accessors
;=================================

Definition Term.vt = Term.rec (\_:Term -> VarType)
  (\vt:VarType \_:Term \_:VarType \_:Term \_:VarType -> vt)
  (\vt:VarType \_:Term \_:VarType \_:Term \_:VarType -> vt)
  (\_:Term \_:VarType \_:Term \_:VarType -> VarType.*)
  (\vt:VarType \_:Nat -> vt)
  (\vt:VarType -> vt)
Definition Term.arg1 = Term.rec (\_:Term -> Term)
  (\_:VarType \t1:Term \_:Term \_:Term \_:Term -> t1)
  (\_:VarType \t1:Term \_:Term \_:Term \_:Term -> t1)
  (\t1:Term \_:Term \_:Term \_:Term -> t1)
  (\_:VarType \_:Nat -> Term.*)
  (\_:VarType -> Term.*)
Definition Term.arg2 = Term.rec (\_:Term -> Term)
  (\_:VarType \t1:Term \_:Term \t2:Term \_:Term -> t2)
  (\_:VarType \t1:Term \_:Term \t2:Term \_:Term -> t2)
  (\t1:Term \_:Term \t2:Term \_:Term -> t2)
  (\_:VarType \_:Nat -> Term.*)
  (\_:VarType -> Term.*)
Definition Term.n = Term.rec (\_:Term -> Nat)
  (\_:VarType \t1:Term \_:Nat \t2:Term \_:Nat -> Nat.0)
  (\_:VarType \t1:Term \_:Nat \t2:Term \_:Nat -> Nat.0)
  (\t1:Term \_:Nat \t2:Term \_:Nat -> Nat.0)
  (\_:VarType \n:Nat -> n)
  (\_:VarType -> Nat.0)
Definition Term.isLam = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.tt)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.ff)
Definition Term.isPi = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.tt)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.ff)
Definition Term.isApp = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.tt)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.ff)
Definition Term.isVar = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.tt)
  (\_:VarType -> Bool.ff)
Definition Term.isBoolniv = Term.rec (\_:Term -> Bool)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:Term \_:Bool \_:Term \_:Bool -> Bool.ff)
  (\_:VarType \_:Nat -> Bool.ff)
  (\_:VarType -> Bool.tt)


;=================================
; Strong Normalizer
;=================================

Definition NotLam = \t:Term -> Bool.ite (Term.isLam t) F T

Definition Term.eqLam.type = \t:Term ->
  (I (Term.lam (Term.vt t) (Term.arg1 t) (Term.arg2 t)) t)
Definition Term.classifyLam =
  Let Type = (\t:Term ->
      Bool.ite (Term.isLam t) (Term.eqLam.type t) (NotLam t)) ->
  Term.rec Type
	   (\vt:VarType \t1:Term \_:Type t1 \t2:Term \_:Type t2 ->
	    I.r (Term.lam vt t1 t2))
	   (\vt:VarType \t1:Term \_:Type t1 \t2:Term \_:Type t2 -> T.tt)
	   (\t1:Term \_:Type t1 \t2:Term \_:Type t2 -> T.tt)
	   (\vt:VarType \i:Nat -> T.tt)
	   (\vt:VarType -> T.tt)

Inductive Normalize : Term -> Term -> U =
  lam   : vt:VarType -> {M:Term} -> {M':Term} -> Normalize M M' ->
  	  {N:Term} -> {N':Term} -> Normalize N N' ->
	  Normalize (Term.lam vt M N) (Term.lam vt M' N'),
  pi    : vt:VarType -> {M:Term} -> {M':Term} -> Normalize M M' ->
  	  {N:Term} -> {N':Term} -> Normalize N N' ->
	  Normalize (Term.pi vt M N) (Term.pi vt M' N'),
  applam: {M:Term} -> {vt:VarType} -> {M1:Term} -> {M2:Term} ->
  	  Normalize M (Term.lam vt M1 M2) ->
	  {N:Term} -> {N':Term} -> Normalize N N' ->
	  {MN':Term} -> Normalize (Term.subst M2 N') MN' ->
	  Normalize (Term.app M N) MN',
  app   : {M:Term} -> {M':Term} -> Normalize M M' -> NotLam M' ->
  	  {N:Term} -> {N':Term} -> Normalize N N' ->
	  Normalize (Term.app M N) (Term.app M' N'),
  var   : vt:VarType -> n:Nat -> Normalize (Term.var vt n) (Term.var vt n),
  univ  : vt:VarType -> Normalize (Term.univ vt) (Term.univ vt)

;Inductive SN : Term -> U =
;  sn : {t:Term} -> {t':Term} -> Normalize t t' -> SN t
;Definition SN.normalized =
;  SN.rec ({\t:Term}\sn:SN t -> Term)
;    (\t:Term \t':Term \n:Normalize t t' -> t')
;Definition SN.destruct =
;  SN.rec ({\t:Term}\sn:SN t -> Normalize t (SN.normalized sn))
;    (\t:Term \t':Term \n:Normalize t t' -> n)
;Definition SN.sn.destruct.eq =
;  SN.rec ({\t:Term}\sn:SN t -> I (SN.sn (SN.destruct sn)) sn)
;    (\t:Term \t':Term \n:Normalize t t' -> I.r (SN.sn n))
Definition SN = \t:Term -> Sigma (Normalize t)
Definition SN.sn = {\t:Term} {\t':Term} -> Sigma.mk (Normalize t) t'
Definition SN.rec = \C:({t:Term} -> sn:SN t -> U1)
  \case:(t:Term -> t':Term -> n:Normalize t t' -> C (SN.sn n))
  {\t:Term} \sn:SN t ->
  Sigma.rec (\sig:Sigma (Normalize t) -> C sig)
    (\t':Term \n:Normalize t t' -> case t t' n) sn
Definition SN.normalized = Sigma.1
Definition SN.destruct = Sigma.2
Definition SN.sn.destruct.eq =
  SN.rec ({\t:Term}\sn:SN t -> I (SN.sn (SN.destruct sn)) sn)
    (\t:Term \t':Term \n:Normalize t t' -> I.r (SN.sn n))

; Reduce key reduct, if applicable.
Definition SN.redk =
  Term.rec (\T:Term -> Term)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.lam vt M N)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.pi vt M N)
    (\func:Term \Hyp:Term \arg:Term \_:Term ->
     Bool.ite (Term.isLam func)
        (Term.subst (Term.arg2 func) arg)
	(Term.app Hyp arg))
    (\vt:VarType \n:Nat -> Term.var vt n)
    (\vt:VarType -> Term.univ vt)

Definition SN.redk.arg =
  Term.rec (\T:Term -> Term)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.lam vt M N)
    (\vt:VarType \M:Term \_:Term \N:Term \_:Term -> Term.pi vt M N)
    (\func:Term \Hyp:Term \arg:Term \_:Term ->
     Bool.ite (Term.isLam func) arg Hyp)
    (\vt:VarType \n:Nat -> Term.var vt n)
    (\vt:VarType -> Term.univ vt)

Definition Normalize.arg1 =
  Let Type = (\t:Term -> SN t) ->
  Normalize.rec (\t:Term \t':Term \_:Normalize t t' -> Type (Term.arg1 t))
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type (Term.arg1 M1)
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg1 M2) ->
     SN.sn n1)
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type (Term.arg1 M1)
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg1 M2) ->
     SN.sn n1)
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12') \_:Type (Term.arg1 M1)
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg1 M2)
     \M':Term \n3:Normalize (Term.subst M12' M2') M'
     \_:Type (Term.arg1 (Term.subst M12' M2')) ->
     SN.sn n1)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type (Term.arg1 M1)
     \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg1 M2) ->
     SN.sn n1)
    (\vt:VarType\n:Nat -> SN.sn (Normalize.univ VarType.*))
    (\vt:VarType -> SN.sn (Normalize.univ VarType.*))

Definition Normalize.arg2 =
  Let Type = SN ->
  Normalize.rec (\t:Term \t':Term \_:Normalize t t' -> Type (Term.arg2 t))
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type (Term.arg2 M1)
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg2 M2) ->
     SN.sn n2)
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type (Term.arg2 M1)
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg2 M2) ->
     SN.sn n2)
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12') \_:Type (Term.arg2 M1)
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg2 M2)
     \M':Term \n3:Normalize (Term.subst M12' M2') M'
     \_:Type (Term.arg2 (Term.subst M12' M2')) ->
     SN.sn n2)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type (Term.arg2 M1)
     \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type (Term.arg2 M2) ->
     SN.sn n2)
    (\vt:VarType\n:Nat -> SN.sn (Normalize.univ VarType.*))
    (\vt:VarType -> SN.sn (Normalize.univ VarType.*))

Definition Bool.cases = {\A1:U} {\B1:U} \f1:(A1 -> B1)
	                {\A2:U} {\B2:U} \f2:(A2 -> B2) ->
  Bool.rec (\b:Bool -> Bool.ite b A1 A2 -> Bool.ite b B1 B2) f1 f2
Definition Bool.case = \b:Bool \A:U -> Bool.ite b A T
Definition Bool.case.cong = {\A:U} {\B:U} \f:(A -> B) ->
  Bool.cases f (\x:T -> x)
Definition Bool.case.in = {\A1:U} {\B:U} \f1:(A1 -> B) {\A2:U} \f2:(A2 -> B) ->
  Bool.rec (\b:Bool -> Bool.ite b A1 A2 -> B) f1 f2

Definition Normalize.arg3 =
  Let Result = ({\t:Term} {\t':Term} \n:Normalize t t' ->
    Let targ1 = SN.normalized (Normalize.arg1 n) ->
    Let targ2 = SN.normalized (Normalize.arg2 n) ->
    Bool.case (Term.isLam targ1) (SN (Term.subst (Term.arg2 targ1) targ2)))
  Let Type = ({\t:Term} {\t':Term} \n:Normalize t t' ->
    Bool.case (Term.isApp t) (Result n)) ->
  Normalize.rec Type
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type n2 -> T.tt)
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type n2 -> T.tt)
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12') \_:Type n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type n2
     \M':Term \n3:Normalize (Term.subst M12' M2') M' \_:Type n3 -> SN.sn n3)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \_:Type n1 \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \_:Type n2 ->
     Bool.case.cong (F.rec (\_:F -> SN (Term.subst (Term.arg2 M1') M2')))
       (Term.isLam M1') nl)
    (\vt:VarType\n:Nat -> T.tt)
    (\vt:VarType -> T.tt)

Definition SN.arg1 = {\t:Term} \sn:SN t -> Normalize.arg1 (SN.destruct sn)
Definition SN.arg2 = {\t:Term} \sn:SN t -> Normalize.arg2 (SN.destruct sn)
Definition SN.arg3 = {\t:Term} \sn:SN t -> Normalize.arg3 (SN.destruct sn)

Definition Normalize.case.app =
  {\M1:Term} \n1:SN M1 {\M2:Term} \n2:SN M2
  Let M1' = SN.normalized n1
  Let Type3 = Term.subst (Term.arg2 M1') (SN.normalized n2) ->
  Bool.rec (\isLam:Bool ->
  	    eq:I (Term.isLam M1') isLam ->
	    n3:Bool.ite isLam (SN Type3) T ->
	    SN (Term.app M1 M2))
    (\isTrue:I (Term.isLam M1') Bool.tt
     \n3:SN Type3 ->
     Let vt = (Term.vt M1') Let M11 = Term.arg1 M1' Let M12 = Term.arg2 M1'
     Let eq = I.subst isTrue
     	      	      (\x:Bool -> Bool.ite x (Term.eqLam.type M1') (NotLam M1'))
     	              (Term.classifyLam M1') ->
     Let n1' = I.rsubst eq (Normalize M1) (SN.destruct n1) ->
     SN.sn (Normalize.applam n1' (SN.destruct n2) (SN.destruct n3)))
    (\isF:I (Term.isLam M1') Bool.ff
     \n3:T ->
     Let nl = I.subst isF
     	      	      (\x:Bool -> Bool.ite x (Term.eqLam.type M1') (NotLam M1'))
     	              (Term.classifyLam M1') ->
     SN.sn (Normalize.app (SN.destruct n1) nl (SN.destruct n2)))
  

Definition Normalize.casex = \t':Term ->
  Let Thesis = (\t:Term -> n:Normalize t t' -> SN t) ->
  Term.rec Thesis
    (\vt:VarType \M1:Term \_:Thesis M1 \M2:Term \_:Thesis M2
     \n:Normalize (Term.lam vt M1 M2) t' ->
     SN.sn (Normalize.lam vt (SN.destruct (Normalize.arg1 n))
			     (SN.destruct (Normalize.arg2 n))))
    (\vt:VarType \M1:Term \_:Thesis M1 \M2:Term \_:Thesis M2
     \n:Normalize (Term.pi vt M1 M2) t' ->
     SN.sn (Normalize.pi vt (SN.destruct (Normalize.arg1 n))
			    (SN.destruct (Normalize.arg2 n))))
    (\M1:Term \_:Thesis M1 \M2:Term \_:Thesis M2
     \n:Normalize (Term.app M1 M2) t' ->
     Let M1' = Sigma.1 (Normalize.arg1 n) ->
     Normalize.case.app (Normalize.arg1 n) (Normalize.arg2 n)
     	(Term.isLam M1') (I.r (Term.isLam M1')) (Normalize.arg3 n))
    (\vt:VarType \i:Nat \n:Normalize (Term.var vt i) t' ->
     SN.sn (Normalize.var vt i))
    (\vt:VarType \n:Normalize (Term.univ vt) t' ->
     SN.sn (Normalize.univ vt))
Definition Normalize.case = {\t:Term} {\t':Term} -> Normalize.casex t' t

Definition SN.case = {\t:Term} \sn:SN t -> Normalize.case (SN.destruct sn)

Definition NotLam.eq = \t:Term ->
  Bool.rec (\b:Bool -> nl1:Bool.ite b F T -> nl2:Bool.ite b F T -> I nl1 nl2)
    (\nl1:F -> F.rec (\nl2:F -> I nl1 nl2))
    (T.rec (\nl1:T -> nl2:T -> I nl1 nl2) (T.rec (I T.tt) (I.r T.tt)))
    (Term.isLam t)

Definition Normalize.case.eq =
  Let Thesis = ({\t:Term} {\t':Term} \n:Normalize t t' ->
      	        I (SN.case (SN.sn n)) (SN.sn n)) ->
  Normalize.rec Thesis
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2 ->
     I.r (SN.sn (Normalize.lam vt n1 n2)))
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2 ->
     I.r (SN.sn (Normalize.pi vt n1 n2)))
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12') \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2
     \M':Term \n3:Normalize (Term.subst M12' M2') M' \HypM3: Thesis n3 ->
     I.r (SN.sn (Normalize.applam n1 n2 n3)))
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2
     Let n = (Normalize.app n1 nl n2) ->
     Let eq = (Assume I (Term.isLam M1) Bool.ff) ->
     I.rsubst eq (\x:Bool ->
	 I (Normalize.case.app (SN.sn n1) (SN.sn n2)
	   x (I.r x) (Normalized.arg3 n))


Bool.rec (\b:Bool -> I (Term.isLam M1') b -> Thesis n)
     	(\eq:I (Term.isLam M1') Bool.tt ->
	 F.rec (\_:F -> Thesis n)
	   (I.subst eq (\x:Bool -> (Bool.ite x F T)) nl))
	(\eq:I (Term.isLam M1') Bool.ff ->
	       (SN.sn n))
	     I.r (SN.n n))
	 	 
     	 Let nl' = I.subst eq
     	      	      (\x:Bool -> Bool.ite x (Term.eqLam.type M1') (NotLam M1'))
     	              (Term.classifyLam M1') ->
	 Let nleq = NotLam.eq M1' nl nl' ->
	 I.cong (\x:NotLam M1' ->
		 SN.sn (Normalize.app n1 x n2)))
		nleq)
    (\vt:VarType \n:Nat -> I.r (SN.sn (Normalize.var vt n)))
    (\vt:VarType -> I.r (SN.sn (Normalize.univ vt)))
Definition SN.case.eq = {\t:Term} \sn:SN t ->
  I.subst (SN.sn.destruct.eq sn)
     (\x:SN t -> I (SN.case x) x)
     (Normalize.case.eq (SN.destruct sn))
TypeCheck SN.case.eq : {t:Term} -> sn:SN t -> I (SN.case sn) sn

Definition Normalize.unique.aux =
  Let Thesis = ({\t:Term} {\t':Term} \n:Normalize t t' ->
      sn: SN t -> I (SN.sn n) sn) ->
  Normalize.rec Thesis
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2
     \sn:SN (Term.lam vt M1 M2) ->
     I.trans (I.cong2 (\x:SN M1 \y:SN M2 ->
	        SN.sn (Normalize.lam vt (SN.destruct x) (SN.destruct y)))
                (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)))
	     (SN.case.eq sn))
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2
     \sn:SN (Term.pi vt M1 M2) ->
     I.trans (I.cong2 (\x:SN M1 \y:SN M2 ->
	        SN.sn (Normalize.pi vt (SN.destruct x) (SN.destruct y)))
                (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)))
	     (SN.case.eq sn))
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12') \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2
     \M':Term \n3:Normalize (Term.subst M12' M2') M' \HypM3:Thesis n3
     \sn:SN (Term.app M1 M2) ->
     Assume I (SN.sn (Normalize.applam n1 n2 n3)) sn)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1 \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2
     \sn:SN (Term.app M1 M2) ->
     I.trans (I.subst (HypM1 (SN.arg1 sn))
     	        (\x:SN M1 ->
		 z:NotLam (SN.normalized x) ->
		 I (SN.sn (Normalize.app n1 nl n2))
		       (SN.sn (Normalize.app (SN.destruct x) z
			         (SN.destruct (SN.arg2 sn)))))
	        (\z:NotLam M1' ->
		 I.cong2 (\x:NotLam M1' \y:SN M2 ->
			 SN.sn (Normalize.app n1 x (SN.destruct y)))
	          (NotLam.alleq nl z)
		  (HypM2 (SN.arg2 sn))))
	     (SN.case.eq sn))
    (\vt:VarType \i:Nat \sn:SN (Term.var vt i) -> SN.case.eq sn)
    (\vt:VarType \sn:SN (Term.univ vt) -> SN.case.eq sn)

Definition Term.normalize.applam = {\t:Term} \sn:SN t \M':Term \N':Term ->
     Term.rec (\t:Term -> Term)
       (\vt:VarType \M1:Term \_:Term \M2:Term \_:Term ->
        SN.rec ({\t:Term} \_:SN t -> Term)
	  (\t:Term \t':Term \_:Normalize t t' -> t')
	  sn)
       (\vt:VarType \M1:Term \_:Term \M2:Term \_:Term ->
        Term.app M' N')
       (\M1:Term \_:Term \M2:Term \_:Term -> Term.app M' N')
       (\vt:VarType \n:Nat -> Term.app M' N')
       (\vt:VarType -> Term.app M' N')

Definition Term.normalizex = 
  Term.rec (\t:Term -> SN t -> Term)
    (\vt:VarType \M:Term \HypM:(SN M -> Term) \N:Term \HypN:(SN N -> Term)
     \sn:SN (Term.lam vt M N) ->
     Term.lam vt (HypM (SN.arg1 sn)) (HypN (SN.arg2 sn)))
    (\vt:VarType \M:Term \HypM:(SN M -> Term) \N:Term \HypN:(SN N -> Term)
     \sn:SN (Term.pi vt M N) ->
     Term.pi vt (HypM (SN.arg1 sn)) (HypN (SN.arg2 sn)))
    (\M:Term \HypM:(SN M -> Term) \N:Term \HypN:(SN N -> Term)
     \sn:SN (Term.app M N)
     Let M' = (HypM (SN.arg1 sn))
     Let N' = (HypN (SN.arg2 sn)) ->
     ; for app we check if M' normalizes to lambda. In that case we
     ; have to cheat and lookup the normalization
     Term.normalize.applam sn M' N' M')
    (\vt:VarType \n:Nat \sn:SN (Term.var vt n) -> Term.var vt n)
    (\vt:VarType \sn:SN (Term.univ vt) -> Term.univ vt)
Definition Term.normalize = {\t:Term} -> Term.normalizex t

Definition Normalize.idempotent =
  Normalize.rec (\M:Term \M':Term \_:Normalize M M' -> Normalize M' M')
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Normalize M1' M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Normalize M2' M2' ->
     Normalize.lam vt HypM1 HypM2)
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Normalize M1' M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Normalize M2' M2' ->
     Normalize.pi vt HypM1 HypM2)
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12')
     \HypM1:Normalize (Term.lam vt M11' M12') (Term.lam vt M11' M12')
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Normalize M2' M2'
     \M':Term
     \n3:Normalize (Term.subst M12' M2') M' \HypM3: Normalize M' M' ->
     HypM3)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Normalize M1' M1'
     \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Normalize M2' M2' ->
     Normalize.app HypM1 nl HypM2)
    (\vt:VarType \n:Nat -> Normalize.var vt n)
    (\vt:VarType -> Normalize.univ vt)

Definition Term.normalize.applam.lemma = {\t:Term} \sn:SN t \t2:Term ->
  NotLam.rec ({\t1:Term} \nl:NotLam t1 ->
  	      I (Term.normalize.applam sn t1 t2 t1) (Term.app t1 t2))
   (\vt:VarType \M:Term \N:Term -> I.r (Term.app (Term.pi vt M N) t2))
   (\M:Term \N:Term -> I.r (Term.app (Term.app M N) t2))
   (\vt:VarType \n:Nat -> I.r (Term.app (Term.var vt n) t2))
   (\vt:VarType -> I.r (Term.app (Term.univ vt) t2))

Definition Term.normalize.self =
  Let Thesis = ({\M:Term} {\M':Term} \n:Normalize M M' ->
      	        I (Term.normalize (SN.sn n)) M') ->
  Normalize.rec (\M:Term \M':Term \n:Normalize M M' -> Thesis n)
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2 ->
     I.cong2 (Term.lam vt) HypM1 HypM2)
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2 ->
     I.cong2 (Term.pi vt) HypM1 HypM2)
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12') \HypM1: Thesis n1
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2
     \M':Term
     \n3:Normalize (Term.subst M12' M2') M' \HypM3:Thesis n3 ->
     I.cong2 (\x:Term \y:Term ->
	         (Term.normalize.applam
		         (SN.sn (Normalize.applam n1 n2 n3)) x y x))
	     HypM1 HypM2)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis n1
     \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis n2 ->
     I.subst2 (I.symm HypM1) (I.symm HypM2)
     	 (\x:Term \y:Term ->
	    I (Term.normalize.applam
		         (SN.sn (Normalize.app n1 nl n2)) x y x)
	      (Term.app M1' M2'))
	 (Term.normalize.applam.lemma
		(SN.sn (Normalize.app n1 nl n2)) M2' nl))
    (\vt:VarType \n:Nat -> I.r (Term.var vt n))
    (\vt:VarType -> I.r (Term.univ vt))

Definition Normalize.unique =
  Let Thesis = (\M:Term \M':Term -> sn:SN M -> I M' (Term.normalize sn)) ->
  Normalize.rec (\M:Term \M':Term \_:Normalize M M' -> Thesis M M')
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis M1 M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \sn:SN (Term.lam vt M1 M2) ->
     I.cong2 (Term.lam vt) (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)))
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis M1 M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \sn:SN (Term.pi vt M1 M2) ->
     I.cong2 (Term.pi vt) (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)))
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12')
     \HypM1:Thesis M1 (Term.lam vt M11' M12')
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \M':Term
     \n3:Normalize (Term.subst M12' M2') M'
     \HypM3:Thesis (Term.subst M12' M2') M'
     \sn:SN (Term.app M1 M2) ->
     Let Th3 = (sn3:SN (Term.subst M12' M2') -> I M' (Term.normalize sn3)) ->
     Let Th2 = ({\t:Term} \snx:SN t -> Term.isApp t ->
       I (Term.lam vt M11' M12') (Term.normalize (SN.arg1 snx)) ->
       I M2' (Term.normalize (SN.arg2 snx)) ->
       Th3 ->
       I M' (Term.normalize snx)) ->
     SN.rec (\t:Term\sn:SN t -> Th2 sn)
       (Normalize.rec (\t:Term\t':Term\nx:Normalize t t' -> Th2 (SN.sn nx))
         (\vtx:VarType
          \M1x:Term \M1x':Term \n1x:Normalize M1x M1x' \HypM1:Th2 (SN.sn n1x)
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
	  Let sn = SN.sn (Normalize.lam vtx n1x n2x) ->
          \f:F \_:I (Term.lam vt M11' M12') (Term.normalize (SN.arg1 sn))
	  \_:I M2' (Term.normalize (SN.arg2 sn))
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f)
         (\vtx:VarType
          \M1x:Term \M1x':Term \n1x:Normalize M1x M1x' \HypM1:Th2 (SN.sn n1x)
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
	  Let sn = SN.sn (Normalize.pi vtx n1x n2x) ->
          \f:F \_:I (Term.lam vt M11' M12') (Term.normalize (SN.arg1 sn))
	  \_:I M2' (Term.normalize (SN.arg2 sn))
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f)
         (\M1x:Term \vtx:VarType \M11x':Term \M12x':Term
	  \n1x:Normalize M1x (Term.lam vtx M11x' M12x') \HypM1:Th2 (SN.sn n1x)
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
	  \Mx:Term
	  \n3x:Normalize (Term.subst M12x' M2x') Mx \HypM3:Th2 (SN.sn n3x)
          \t:T \eq1:I (Term.lam vt M11' M12') (Term.normalize (SN.sn n1x))
	  \eq2:I M2' (Term.normalize (SN.sn n2x)) ->
	  \Hyp:Th3 ->
	  (I.subst2 eq1 eq2
	      (\x:Term \y:Term ->
	      	 I M' (Term.normalize.applam
		         (SN.sn (Normalize.applam n1x n2x n3x)) x y x))
	      (I.subst (Term.normalize.self n3x)
	        (\x:Term -> I M' x)
		(I.subst2 (I.trans eq1 (Term.normalize.self n1x))
		          (I.trans eq2 (Term.normalize.self n2x))
			  (\x:Term \y:Term ->
			    (sn3:SN (Term.subst (Term.arg2 x) y) ->
			     I M' (Term.normalize sn3)))
			    Hyp (SN.sn n3x)))))
         (\M1x:Term \M1x':Term \n1x:Normalize M1x M1x' \HypM1:Th2 (SN.sn n1x)
	  \nlx:NotLam M1x'
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
          \t:T
	  \eq1:I (Term.lam vt M11' M12') (Term.normalize (SN.sn n1x))
	  \_:I M2' (Term.normalize (SN.sn n2x))
	  \_:Th3 ->
	  F.rec (\_:F ->
	  	 I M' (Term.normalize (SN.sn (Normalize.app n1x nlx n2x))))
	    (NotLam.lam.false
	       (I.subst (I.symm (I.trans eq1 (Term.normalize.self n1x)))
			(\x:Term -> (NotLam x))
			nlx)))
         (\vtx:VarType \n:Nat \f:F
	  Let sn = SN.sn (Normalize.var vtx n) ->
	  \_:I (Term.lam vt M11' M12') Term.* \_:I M2' Term.*
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f)
         (\vtx:VarType
	  Let sn = SN.sn (Normalize.univ vtx) ->
          \f:F \_:I (Term.lam vt M11' M12') Term.* \_:I M2' Term.*
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f))
       sn T.tt (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)) HypM3)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis M1 M1'
     \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \sn:SN (Term.app M1 M2) ->
     I.symm
	(I.subst2 (I.symm (HypM1 (SN.arg1 sn))) (I.symm (HypM2 (SN.arg2 sn)))
	      (\x:Term \y:Term -> NotLam x ->
	       I (Term.normalize sn) (Term.app x y))
	      (\nl:NotLam (Term.normalize (SN.arg1 sn)) ->
               Term.normalize.applam.lemma sn
       	        (Term.normalize (SN.arg2 sn)) nl) nl))
    (\vt:VarType \n:Nat \sn:SN (Term.var vt n) -> I.r (Term.var vt n))
    (\vt:VarType \sn:SN (Term.univ vt) -> I.r (Term.univ vt))
Definition Normalize.unique =
  Let Thesis = (\M:Term \M':Term -> sn:SN M -> I M' (Term.normalize sn)) ->
  Normalize.rec (\M:Term \M':Term \_:Normalize M M' -> Thesis M M')
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis M1 M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \sn:SN (Term.lam vt M1 M2) ->
     I.cong2 (Term.lam vt) (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)))
    (\vt:VarType
     \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis M1 M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \sn:SN (Term.pi vt M1 M2) ->
     I.cong2 (Term.pi vt) (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)))
    (\M1:Term \vt:VarType \M11':Term \M12':Term
     \n1:Normalize M1 (Term.lam vt M11' M12')
     \HypM1:Thesis M1 (Term.lam vt M11' M12')
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \M':Term
     \n3:Normalize (Term.subst M12' M2') M'
     \HypM3:Thesis (Term.subst M12' M2') M'
     \sn:SN (Term.app M1 M2) ->
     Let Th3 = (sn3:SN (Term.subst M12' M2') -> I M' (Term.normalize sn3)) ->
     Let Th2 = ({\t:Term} \snx:SN t -> Term.isApp t ->
       I (Term.lam vt M11' M12') (Term.normalize (SN.arg1 snx)) ->
       I M2' (Term.normalize (SN.arg2 snx)) ->
       Th3 ->
       I M' (Term.normalize snx)) ->
     SN.rec (\t:Term\sn:SN t -> Th2 sn)
       (Normalize.rec (\t:Term\t':Term\nx:Normalize t t' -> Th2 (SN.sn nx))
         (\vtx:VarType
          \M1x:Term \M1x':Term \n1x:Normalize M1x M1x' \HypM1:Th2 (SN.sn n1x)
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
	  Let sn = SN.sn (Normalize.lam vtx n1x n2x) ->
          \f:F \_:I (Term.lam vt M11' M12') (Term.normalize (SN.arg1 sn))
	  \_:I M2' (Term.normalize (SN.arg2 sn))
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f)
         (\vtx:VarType
          \M1x:Term \M1x':Term \n1x:Normalize M1x M1x' \HypM1:Th2 (SN.sn n1x)
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
	  Let sn = SN.sn (Normalize.pi vtx n1x n2x) ->
          \f:F \_:I (Term.lam vt M11' M12') (Term.normalize (SN.arg1 sn))
	  \_:I M2' (Term.normalize (SN.arg2 sn))
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f)
         (\M1x:Term \vtx:VarType \M11x':Term \M12x':Term
	  \n1x:Normalize M1x (Term.lam vtx M11x' M12x') \HypM1:Th2 (SN.sn n1x)
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
	  \Mx:Term
	  \n3x:Normalize (Term.subst M12x' M2x') Mx \HypM3:Th2 (SN.sn n3x)
          \t:T \eq1:I (Term.lam vt M11' M12') (Term.normalize (SN.sn n1x))
	  \eq2:I M2' (Term.normalize (SN.sn n2x)) ->
	  \Hyp:Th3 ->
	  (I.subst2 eq1 eq2
	      (\x:Term \y:Term ->
	      	 I M' (Term.normalize.applam
		         (SN.sn (Normalize.applam n1x n2x n3x)) x y x))
	      (I.subst (Term.normalize.self n3x)
	        (\x:Term -> I M' x)
		(I.subst2 (I.trans eq1 (Term.normalize.self n1x))
		          (I.trans eq2 (Term.normalize.self n2x))
			  (\x:Term \y:Term ->
			    (sn3:SN (Term.subst (Term.arg2 x) y) ->
			     I M' (Term.normalize sn3)))
			    Hyp (SN.sn n3x)))))
         (\M1x:Term \M1x':Term \n1x:Normalize M1x M1x' \HypM1:Th2 (SN.sn n1x)
	  \nlx:NotLam M1x'
          \M2x:Term \M2x':Term \n2x:Normalize M2x M2x' \HypM2:Th2 (SN.sn n2x)
          \t:T
	  \eq1:I (Term.lam vt M11' M12') (Term.normalize (SN.sn n1x))
	  \_:I M2' (Term.normalize (SN.sn n2x))
	  \_:Th3 ->
	  F.rec (\_:F ->
	  	 I M' (Term.normalize (SN.sn (Normalize.app n1x nlx n2x))))
	    (NotLam.lam.false
	       (I.subst (I.symm (I.trans eq1 (Term.normalize.self n1x)))
			(\x:Term -> (NotLam x))
			nlx)))
         (\vtx:VarType \n:Nat \f:F
	  Let sn = SN.sn (Normalize.var vtx n) ->
	  \_:I (Term.lam vt M11' M12') Term.* \_:I M2' Term.*
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f)
         (\vtx:VarType
	  Let sn = SN.sn (Normalize.univ vtx) ->
          \f:F \_:I (Term.lam vt M11' M12') Term.* \_:I M2' Term.*
	  \_:Th3 ->
	  F.rec (\_:F -> I M' (Term.normalize sn)) f))
       sn T.tt (HypM1 (SN.arg1 sn)) (HypM2 (SN.arg2 sn)) HypM3)
    (\M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis M1 M1'
     \nl:NotLam M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM2:Thesis M2 M2'
     \sn:SN (Term.app M1 M2) ->
     I.symm
	(I.subst2 (I.symm (HypM1 (SN.arg1 sn))) (I.symm (HypM2 (SN.arg2 sn)))
	      (\x:Term \y:Term -> NotLam x ->
	       I (Term.normalize sn) (Term.app x y))
	      (\nl:NotLam (Term.normalize (SN.arg1 sn)) ->
               Term.normalize.applam.lemma sn
       	        (Term.normalize (SN.arg2 sn)) nl) nl))
    (\vt:VarType \n:Nat \sn:SN (Term.var vt n) -> I.r (Term.var vt n))
    (\vt:VarType \sn:SN (Term.univ vt) -> I.r (Term.univ vt))

Definition Normalize.subst = {\N:Term} {\N':Term} \nn': Normalize N N' ->
  Let Thesis = (\M:Term \M':Term -> n:Nat -> {M'':Term} ->
   		 Normalize (Term.substn M n N) M'' ->
   		 Normalize (Term.substn M' n N') M'') ->
  Normalize.rec (\M:Term \M':Term \_:Normalize M M' -> Thesis M M')
    ;lam
    (\vt:VarType \M1:Term \M1':Term \n1:Normalize M1 M1' \HypM1:Thesis M1 M1'
     \M2:Term \M2':Term \n2:Normalize M2 M2' \HypM1:Thesis M2 M2'
     \n:Nat \M'':Term
     \n2:Normalize (Term.substn (Term.lam vt M1 M2) n N) M'' ->
     Normalize.lam (HypM1 (Normalize.arg1 n2))
     		   (HypM2 (Nat.s n) (Normalize.arg1 n2)))

     (HypM1 
     Normalize.lam HypM1
     
     Let Th2 = (I (Term.substn (Term.lam v1 M1 M2) n N) Mx ->
	Normalize (Term.substn (Term.lam v1 M1' M2') n N) M'') ->
     Normalize.rec (\Mx:Term\M'':Term\_:Normalize Mx M'' -> Th2 Mx M''
	;lam
        (\vtx:VarType \M1x:Term \M1x':Term \HypM1:Th2 M1x M1x'
         \M2x:Term \M2x':Term \HypM1:Th2 M2 M2'a
	 \eq:I (Term.substn (Term.lam vt M1 M2) n N) (Term.lam vtx M1x M2x))
	 I.rsubst eq
	    (\x:Term -> Normalize (Term.substn (lam1 x)
         \n:Term
	(
     	Normalize (Term.substn (Term.lam v1 M1 M2) n N) M''
   
Definition Normalize.redk =
  (Normalize (SN.redk t) t' -> SN (SN.redk.arg t) -> Normalize t t')
  case t=app mn
    Hyp: Normalize (redk m) m' -> SN redk.arg t -> Normalize m m'
    case NotLam t,  Normalize (redk t) t':
      applam: (redk t):
        (redk t) = app (redk m) n
        Normalize (redk m) lam m1 m2
	Normalize n n'
	Normalize (Term.subst m2 n') t'
	Hyp: Normalize m (lam m1 m2)
	--> Normalize.applam , finished
      app:
        Normalize (redk m) m', Normalize n n', NotLam m'
	Hyp: Normalize m m'
	--> Thesis with Normalize.app, finished
    case t=lam m1 m2, case Normalize (redk t) t'
      
        case m' = lam m1 m2 ->
	   Normalize (Term.subst m2 n') z  --> 
	   Normalize (redk t) z
	
Definition Normalize.subst				
  

Definition SN.func = {\M:Term} -> {\N:Term}
  Let Aux = (Term.rec (\t:Term -> U)
      (\vt:VarType\M:Term\_:U\N:Term\_:U -> T)
      (\vt:VarType\M:Term\_:U\N:Term\_:U -> T)
      (\M:Term\_:U\N:Term\_:U -> SN M)
      (\vt:VarType\n:Nat -> T)
      (\vt:VarType -> T)) ->
  SN.rec (\t:Term \_:SN t -> Aux t)
    (Normalize.rec (\t:Term \t':Term \_:Normalize t t' -> Aux t)
       (\vt:VarType\M:Term\M':Term\_:Normalize M M'\_:Aux M->
  	\N:Term\N':Term\_:Normalize N N'\_:Aux N -> T.tt)
       (\vt:VarType\M:Term\M':Term\_:Normalize M M'\_:Aux M->
  	\N:Term\N':Term\_:Normalize N N'\_:Aux N -> T.tt)
       (\M:Term\vt:VarType\M1:Term\M2:Term
  	\NormM:Normalize M (Term.lam vt M1 M2)\_:Aux M
	\N:Term\MN':Term\_:Normalize (Term.subst M2 N) MN'
	\_:Aux (Term.subst M2 N) ->
	SN.sn NormM)
       (\M:Term \M':Term \NormM:Normalize M M' \_:Aux M \_:NotLam M' ->
  	\N:Term \N':Term \_:Normalize N N' \_:Aux N ->
	SN.sn NormM)
       (\vt:VarType\n:Nat -> T.tt)
       (\vt:VarType -> T.tt))
    (Term.app M N)

TypeCheck SN.func : {M:Term} -> {N:Term} -> SN (Term.app M N) -> SN M
	  
Inductive Base : Term -> U =
  pi   : {vt:VarType} -> {M:Term} -> {N:Term} -> SN (Term.pi vt M N) ->
	 Base (Term.pi vt M N),
  app  : {M:Term} -> Base M -> {N:Term} -> SN N -> Base (Term.app M N),
  var  : vt:VarType -> n:Nat -> Base (Term.var vt n),
  univ : vt:VarType -> Base (Term.univ vt)

Definition pow = \X : U -> (X -> U)
Inductive SAT : X : (pow Term) -> U =
  def : (t:Term -> X t -> SN t) ->
        ({t:Term} -> Base t -> X t) ->
        ({t:Term} -> SN t -> X (redk t) -> X t) -> SAT X
Definition SAT.sn = {\X:(pow Term)} ->
  SAT.rec X (\_:SAT X -> t:Term -> X t -> SN t)
    (\x:(t:Term -> X t -> SN t)
     \_:({t:Term} -> Base t -> X t)
     \_:({t:Term} -> SN t -> X (redk t) -> X t) -> x)
Definition SAT.base = {\X:(pow Term)} ->
  SAT.rec X (\_:SAT X -> {t:Term} -> Base t -> X t)
    (\_:(t:Term -> X t -> SN t)
     \x:({t:Term} -> Base t -> X t)
     \_:({t:Term} -> SN t -> X (redk t) -> X t) -> x)
Definition SAT.red = {\X:(pow Term)} ->
  SAT.rec X (\_:SAT X -> {t:Term} -> SN t -> X (redk t) -> X t)
    (\_:(t:Term -> X t -> SN t)
     \_:({t:Term} -> Base t -> X t)
     \x:({t:Term} -> SN t -> X (redk t) -> X t) -> x)

Definition Function = \dom : pow Term -> \rng : pow Term
  \t:Term -> (a:Term -> dom a -> rng (Term.app t a))
Definition Intersect = \A : U -> \sets : (A -> pow Term)
  \t:Term -> (a:A -> sets a t)

Definition Function.closed =
  {\dom:pow Term} -> \sdom:SAT dom -> {\rng:pow Term} -> \srng:SAT rng ->
  SAT.def (Function dom rng)
    (\t:Term -> \xt:(a:Term -> dom a -> rng (Term.app t a)) ->
     SN.func (SAT.sn srng (Term.app t Term.*)
			  (xt Term.* ((SAT.base sdom) (Base.univ VarType.*)))))
    (\t:Term \bt:Base t \a:Term \doma: dom a ->
     SAT.base srng (Base.app bt (SAT.sn sdom a doma)))
    (\t:Term \snt:SN t \xredk:(a:Term -> dom a -> rng (Term.app (redk t) a))
     \a:Term \doma: dom a ->
     Let Thesis = (\t:Term ->
        rngred:rng (Term.app (redk t) a) -> rng (Term.app t a)) ->
     Let sna = SAT.sn sdom a doma ->
     Term.rec (\t:Term -> Thesis t)
        (\vt:VarType \M:Term \_:Thesis M \N:Term \_:Thesis N ->
	 \rngred:(rng (Term.app (redk (Term.lam vt M N)) a)) ->
	 rngred)
        (\vt:VarType \M:Term \_:Thesis M \N:Term \_:Thesis N ->
	 \rngred:rng (Term.app (redk (Term.pi vt M N)) a) ->
	 rngred)
        (\M:Term \Hyp:Thesis M \N:Term \_:Thesis N ->
	 \rngred:rng (Term.app (redk (Term.app M N)) a) ->
	 SAT.red srng
	 	 ((Assume t:Term -> SN (redk t) -> SN t)
		    (Term.app (Term.app M N) a)
		    (SAT.sn srng (Term.app (redk (Term.app M N)) a) rngred))
	         rngred)
	(\vt:VarType \i:Nat ->
	 \rngred:rng (Term.app (redk (Term.var vt i)) a) ->
	 rngred)
        (\vt:VarType ->
	 \rngred:rng (Term.app (redk (Term.univ vt)) a) ->
	 rngred)
	t (xredk a doma))


TypeCheck Function.closed :
  {dom:pow Term} -> sdom:SAT dom -> {rng:pow Term} -> srng:SAT rng ->
  SAT (Function dom rng)


Inductive Class : U =
  []     : Class,
  kind   : Class,
  prop   : Class,
  constr : Class,
  obj    : Class

Definition Class.constr2prop =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.prop Class.prop Class.prop
Definition Class.prop2constr =
  Class.rec (\_:Class -> Class)
    Class.[] Class.constr Class.constr Class.constr Class.obj
Definition Class.constrobj =
  VarType.rec (\_:VarType -> Class) Class.constr Class.obj
Definition Class.kindprop =
  VarType.rec (\_:VarType -> Class) Class.kind Class.prop
Definition Class.boxkind =
  VarType.rec (\_:VarType -> Class) Class.[] Class.kind

Definition Term.classify =
  Term.rec (\t:Term -> Class)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; lam
        Class.prop2constr Nc)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; pi
        Class.constr2prop Nc)
    (\M:Term \Mc:Class \N:Term \_:Class -> Mc)          ; app
    (\vt:VarType \n:Nat -> Class.constrobj vt)          ; var
    Class.boxkind                                       ; univ

Definition Term.shiftn.classify =
  Term.rec (\M:Term -> n:Nat ->
            I (Term.classify (Term.shiftn M n)) (Term.classify M))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class.prop2constr (Hyp (Nat.s n)))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class.constr2prop (Hyp (Nat.s n)))
    (\M:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> Hyp n)
    (\vt:VarType \i:Nat \n:Nat -> I.r (Class.constrobj vt))
    (\vt:VarType \n:Nat -> I.r (Class.boxkind vt))

Inductive TypedClass : Gamma:VarList -> S:Term -> A:Term -> Class -> U =
  kind  : CCTypeCheck Gamma S Term.[] -> TypedClass Gamma S A Class.kind,
  prop  : CCTypeCheck Gamma S A -> CCTypeCheck Gamma A Term.[] ->
  	  CCTypeCheck Gamma S Term.*  -> TypedClass Gamma S A Class.prop,
  constr: CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.[] -> TypedClass Gamma S A Class.constr,
  obj   : CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.* -> TypedClass Gamma S A Class.obj

Definition CCTypeCheck.constraints = \Gamma:VarList ->
  Term.rec (\S:Term -> U)
    ; lam
    (\vt:VarType \M:Term \_:U \N:Term \_:U ->
       Sigma (\S:Term ->
          CCTypeCheck Gamma (Term.lam vt M N) (Term.pi vt M S)))
    ; pi
    (\vt:VarType \M:Term \_:U \N:Term \_:U ->
       Sigma VarType (\vt2:VarType ->
          CCTypeCheck (VarList.cons vt M Gamma) N (Term.univ vt2)))
    (\M:Term \_:U \N:Term \_:U -> T) ; app
    (\vt:VarType \n:Nat -> T)        ; var
    (\vt:VarType -> T)               ; univ

Definition CCTypeCheck.okay =
   CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term
   		    \_:CCTypeCheck Gamma M S ->
		          CCTypeCheck.constraints Gamma S)
     T.tt ; ax
     (\Gamma:VarList \vt:VarType \T0:Term                 ; var
      \prf:CCTypeCheck Gamma T0 (Term.univ vt)
      \Hyp:CCTypeCheck.constraints Gamma (Term.univ vt) ->
      )
     (\Gamma:VarList \vt:VarType \T0:Term                 ; weak
      \prf1:CCTypeCheck Gamma T0 (Term.univ vt)
      \_:CCTypeCheck.constraints Gamma (Term.univ vt)
      \prf2:CCTypeCheck Gamma M S
      \Hyp:CCTypeCheck.constraints Gamma S ->
      Term.rec (S:Term -> CCTypeCheck.constraints Gamma S ->
                CCTypeCheck.constraints (VarList.cons vt T0 Gamma) S)
	(\vt1:VarType \M:Term \_:U \N:Term \_:U ->
	 Sigma.rec Term (\S1:Term ->
         	         CCTypeCheck Gamma (Term.lam vt1 M N) (Term.pi vt1 M S1))
	     (\_:Sigma (\S1:Term -> CCTypeCheck Gamma (Term.lam vt1 M N) (Term.pi vt1 M S1)) ->
	       CCTypeCheck (VarList.cons vt T0 Gamma)
	       		   (Term.shiftvar (Term.lam vt1 M N)) (Term.shiftvar (Term.pi.vt1 M S1)))
	     (\S1:Term
	      \prf3:CCTypeCheck Gamma (Term.lam vt M N) (Term.pi vt M S1) ->
	      CCTypeCheck.weak prf1 prf3)))

      
Definition Term.classify.type.correct =
   CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \t:CCTypeCheck Gamma M S ->
                    TypedClass Gamma M S (Term.classify M))
    ;ax
    (TypedClass.kind VarList.nil Term.* Term.[] CCTypeCheck.ax)
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf:CCTypeCheck Gamma T0 (Term.univ vt)
     \_:TypedClass Gamma T0 (Term.univ vt) (Term.classify T0) ->
     VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term -> A:Term ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M A (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt (VarList.cons vt T0 Gamma) (Term.var vt Nat.0) (Term.shiftvar T0)
	(CCTypeCheck.var prf)
	(CCTypeCheck.weak prf prf))
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: TypedClass Gamma T0 (Term.univ vt) (Term.classify T0) ->
     \M: Term -> \S:Term -> \prf2:CCTypeCheck Gamma M S ->
     I.rsubst (Term.shiftn.classify M Nat.0)
     	 (\x:Class -> TypedClass Gamma M S (Term.classify M) ->
	 	   TypedClass (VarList.cons vt T0 Gamma)
		   	      (Term.shiftvar M) (Term.shiftvar S) x)
     (TypedClass.rec Gamma M S
         (\class: Class \_:TypedClass Gamma M S class ->
          TypedClass (VarList.cons vt T0 Gamma)
	  	     (Term.shiftvar M) (Term.shiftvar S) class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  TypedClass.kind (VarList.cons vt T0 Gamma)
	  		  (Term.shiftvar M) (Term.shiftvar S)
	                  (CCTypeCheck.weak prf prf3))
	 ; prop
	 (\prf3: CCTypeCheck Gamma M S
	  \prf4: CCTypeCheck Gamma S Term.[] ->
	  \prf5: CCTypeCheck Gamma M Term.* ->
	  TypedClass.prop (VarList.cons vt T0 Gamma)
	  		  (Term.shiftvar M) (Term.shiftvar S)
	                  (CCTypeCheck.weak prf prf3)
			  (CCTypeCheck.weak prf prf4)
			  (CCTypeCheck.weak prf prf5))
	 ; constr
	 (\prf3: CCTypeCheck Gamma M S
	  \prf4: CCTypeCheck Gamma S Term.[] ->
	  TypedClass.constr (VarList.cons vt T0 Gamma)
	  		    (Term.shiftvar M) (Term.shiftvar S)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 ; obj
	 (\prf3: CCTypeCheck Gamma M S
	  \prf4: CCTypeCheck Gamma S Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar S)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 (Term.classify M)))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \_: TypedClass Gamma T1 (Term.univ vt1) (Term.classify T1) ->
     \vt2: VarType -> \S:Term ->
     \prf2: CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp: TypedClass (VarList.cons vt1 T1 Gamma)
     	   	      S (Term.univ vt2) (Term.classify S) ->
     I.rsubst (Assume I (Class.constr2prop (Term.classify S))
     	      	      	(Class.kindprop vt2))
	       (\x:Class -> TypedClass Gamma (Term.pi vt1 T1 S) (Term.univ vt2) x)
     (VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term ->
		  CCTypeCheck Gamma M (Term.univ vt) ->
                  TypedClass Gamma M (Term.univ vt) (Class.kindprop vt))
	(\Gamma:VarList \M:Term ->
         TypedClass.kind Gamma M Term.[])
	(\Gamma:VarList \M:Term \prf: CCTypeCheck Gamma M Term.* ->
	 TypedClass.prop Gamma M Term.* prf
	                 (CCTypeCheck.ax2 Gamma
			    (CCTypeCheck.gammatc Gamma M Term.* prf)) prf)
	vt2 Gamma (Term.pi vt1 T1 S) (CCTypeCheck.pi prf1 prf2)))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \_: TypedClass (VarList.cons vt1 T1 Gamma) M S (Term.classify M) ->
     \vt2: VarType ->
     \prf2: CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp: TypedClass Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     	   	      (Class.constr2prop (Term.classify S)) ->
     I.rsubst  (Assume I (Class.prop2constr (Term.classify M)) (Class.constrobj vt2))
	       (\x:Class -> TypedClass Gamma (Term.lam vt1 T1 M)
	       		    	       	     (Term.pi vt1 T1 S) x)
     (VarType.rec (\vt:VarType ->
     		  {Gamma:VarList} -> {M:Term} -> {A:Term} ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M A (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt2 (CCTypeCheck.lam prf1 prf2) prf2))
    ;app
    (\Gamma:VarList \M:Term \vt1:VarType \T1:Term \S:Term
     \prf1: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
     \Hyp: TypedClass Gamma M (Term.pi vt1 T1 S) (Term.classify M) ->
     \N:Term
     \prf2: CCTypeCheck Gamma N T1
     \_: TypedClass Gamma N T1 (Term.classify N) ->
     Let SN = Term.subst S N ->
     (TypedClass.rec Gamma M (Term.pi vt1 T1 S)
         (\class: Class \_:TypedClass Gamma M (Term.pi vt1 T1 S) class ->
          TypedClass Gamma (Term.app M N) SN class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  Assume TypedClass Gamma (Term.app M N) SN Class.kind)
	 ; prop
	 (\prf3: CCTypeCheck Gamma M (Term.pi vt1 T1 S) ->
	  \prf4: CCTypeCheck Gamma (Term.pi vt1 T1 S) Term.[] ->
	  \prf5: CCTypeCheck Gamma M Term.* ->
	  Assume TypedClass Gamma (Term.app M N) SN Class.prop)
	 ; constr
	 (\prf3: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
	  \prf4: CCTypeCheck Gamma (Term.pi vt1 T1 S) Term.[] ->
	  TypedClass.constr Gamma (Term.app M N) SN
	     (CCTypeCheck.app prf1 prf2)
	     (CCTypeCheck.subst (CCTypeCheck.weak prf prf4) prf2))
	 ; obj
	 (\prf3: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
	  \prf4: CCTypeCheck Gamma (Term.pi vt1 T1 S) Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 (Term.classify M)))
     Class.rec (
     I.rsubst  (Assume I (Class.prop2constr (Term.classify M)) (Class.constrobj vt2))
	       (\x:Class -> TypedClass Gamma (Term.lam vt1 T1 M) x)
     (VarType.rec (\vt:VarType ->
     		  {Gamma:VarList} -> {M:Term} -> {A:Term} ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt2 (CCTypeCheck.lam prf1 prf2) prf2))

Definition Term.ispi = 
   Term.rec (\t:Term -> U)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> F)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> T)
      (\M:Term \_:U \N:Term \_:U -> F)
      (\vt:VarType \n:Nat -> F)
      (\vt:VarType -> F)
Definition Term.casepi = \C:(t:Term -> U1)
   \case:(vt:VarType -> T:Term -> S:Term -> C (Term.pi vt T S)) ->
   Term.rec (\t:Term -> Term.ispi t -> C t)
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.lam vt M N)))
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         \_:T -> case vt M N)
      (\M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.app M N)))
      (\vt:VarType \n:Nat -> F.rec (\_:F -> C (Term.var vt n)))
      (\vt:VarType -> F.rec (\_:F -> C (Term.univ vt)))

Inductive KindOrProp : Gamma:VarList -> S:Term -> U =
  kind: CCTypeCheck Gamma S Term.[] -> KindOrProp Gamma S,
  prop: CCTypeCheck Gamma S Term.*  -> KindOrProp Gamma S



Definition PiRangeCorrectType = \Gamma:VarList ->
  Term.casepi (\_:Term -> U)
              (\vt0:VarType \T0:Term \S0:Term ->
	         KindOrProp (VarList.cons vt0 T0 Gamma) S0)

Definition PiRangeCorrect = 
  CCTypeCheck.rec
     (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
      PiRangeCorrectType Gamma M)
    ;ax
    T.tt
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     T.tt)
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     Term.casepi (\M: Term -> S:Term -> CCTypeCheck Gamma M S ->
        PiRangeCorrectType Gamma M ->
        PiRangeCorrectType (VarList.cons vt T0 Gamma) (Term.shiftvar M))
        (\vt1:VarType \T1:Term \S1:Term
	 \S:Term \_:CCTypeCheck Gamma (Term.pi vt1 T1 S1) S ->
	 KindOrProp.rec (VarList.cons vt1 T1 Gamma) S1
	    (\_:KindOrProp (VarList.cons vt1 T1 Gamma) S1 ->
	     KindOrProp (VarList.cons vt1 (Term.shiftvar T1) (VarList.cons vt T0 Gamma)) (Term.shiftn S1 Nat.1))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.[] ->
	     KindOrProp.kind (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.* ->
	     KindOrProp.prop (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf)))
	(\M:Term \S:Term \_:CCTypeCheck Gamma M S
	 \_:PiRangeCorrectType Gamma M ->
	 T.tt))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Inductive TermClass : Gamma:VarList -> M:Term -> U =
  kind   : CCTypeCheck Gamma M Term.[] -> TermClass Gamma M,
  constr : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.[]
           -> TermClass Gamma M,
  obj    : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.*
           -> TermClass Gamma M
  
Definition Term.classify =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
  		   TermClass Gamma M)
    (TermClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList -> VarType.rec
        (\vt:VarType -> T:Term -> CCTypeCheck Gamma T (Term.univ vt) ->
	 TermClass Gamma T ->
	 TermClass (VarList.cons vt T Gamma) (Term.var vt Nat.0))
        (\T:Term \prf:CCTypeCheck Gamma T Term.[] \rec:TermClass Gamma T ->
	 TermClass.constr (VarList.cons VarType.[] T Gamma)
	 		  (Term.var VarType.[] Nat.0)
			  (Term.shiftvar T)
	                  (CCTypeCheck.var Gamma VarType.[] T prf)
	             (CCTypeCheck.weak Gamma VarType.[] T prf T Term.[] prf))
        (\T:Term \prf:CCTypeCheck Gamma T Term.* \rec:TermClass Gamma T ->
	 TermClass.obj (VarList.cons VarType.* T Gamma)
	 	       (Term.var VarType.* Nat.0)
		       (Term.shiftvar T)
	               (CCTypeCheck.var Gamma VarType.* T prf)
		       (CCTypeCheck.weak Gamma VarType.* T prf T Term.* prf)))
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prfvar: CCTypeCheck Gamma T (Term.univ vt) \_: TermClass Gamma T
     \M : Term \S:Term
     \_: CCTypeCheck Gamma M S ->
     TermClass.rec Gamma M (\_:TermClass Gamma M ->
                   TermClass (VarList.cons vt T Gamma) (Term.shiftvar M))
     	;kind
        (\prf1:CCTypeCheck Gamma M Term.[] ->
	 TermClass.kind (VarList.cons vt T Gamma) (Term.shiftvar M)
	                (CCTypeCheck.weak Gamma vt T prfvar
					  M Term.[] prf1))
     	;constr
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.[] ->
	 TermClass.constr (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.[] prf2))
     	;obj
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.* ->
	 TermClass.obj (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.* prf2)))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \prf1:CCTypeCheck Gamma T (Term.univ vt) \rec:TermClass Gamma T ->
     VarType.rec (\vt2:VarType -> S:Term ->
     		  CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
		  TermClass (VarList.cons vt T Gamma) S ->
		  TermClass Gamma (Term.pi vt T S))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.[]
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.kind Gamma (Term.pi vt T S)
	 		(CCTypeCheck.pi Gamma vt T prf1 VarType.[] S prf2))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.*
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.constr Gamma (Term.pi vt T S) Term.*
	 		  (CCTypeCheck.pi Gamma vt T prf1 VarType.* S prf2)
			  (CCTypeCheck.ax2 (CCTypeCheck.gammatc Gamma T
			  		                 (Term.univ vt) prf1))))
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \prf1:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:TermClass (VarList.cons vt T Gamma) M ->
     VarType.rec (\vt2:VarType -> 
     		  CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
		  TermClass Gamma (Term.pi vt T S) ->
		  TermClass Gamma (Term.lam vt T M))
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.[]
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.constr Gamma (Term.lam vt T M) (Term.pi vt T S)
	 		  (CCTypeCheck.lam Gamma vt T M S prf1 VarType.[] prf2)
			  prf2)
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.*
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.obj Gamma (Term.lam vt T M) (Term.pi vt T S)
	 	       (CCTypeCheck.lam Gamma vt T M S prf1 VarType.* prf2)
		       prf2))
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \prf1:CCTypeCheck Gamma M (Term.pi vt T S) \_:TermClass Gamma M
     \N:Term \prf2:CCTypeCheck Gamma N T \_:TermClass Gamma N ->
     Ter
     TermClass
     TermClass Gamma (Term.app M N)
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:TermClass Gamma M
     \S:Term \_:ConvSymmStep T S -> rec)
    

Inductive NotLam : Term -> U =
  pi    : vt:VarType -> M:Term -> N:Term -> NotLam (Term.pi vt M N),
  app   : M:Term -> N:Term -> NotLam (Term.app M N),
  var   : vt:VarType -> i:Nat -> NotLam (Term.var vt i),
  univ  : vt:VarType -> NotLam (Term.univ vt)

Definition NotLam.term =
  NotLam.rec ({\t:Term} \nl1:NotLam t -> Term)
    (\vt:VarType \M:Term \N:Term -> Term.pi vt M N)
    (\M:Term \N:Term -> Term.app M N)
    (\vt:VarType \i:Nat -> Term.var vt i)
    (\vt:VarType -> Term.univ vt)
Definition NotLam.eqterm =
  NotLam.rec ({\t:Term} \nl1:NotLam t -> I (NotLam.term nl1) t)
    (\vt:VarType \M:Term \N:Term -> I.r (Term.pi vt M N))
    (\M:Term \N:Term -> I.r (Term.app M N))
    (\vt:VarType \i:Nat -> I.r (Term.var vt i))
    (\vt:VarType -> I.r (Term.univ vt))

Definition NotLam.alleq = 
  NotLam.rec ({\t:Term} \nl1:NotLam t -> nl2:NotLam t -> I nl1 nl2)
    (\vt:VarType \M:Term \N:Term \nl:NotLam (Term.pi vt M N) ->
     NotLam.rec ({\t':Term} \nl2:NotLam t' ->
     		 eq:I (Term.pi vt M N) t' ->
     		 I (I.subst eq NotLam (NotLam.pi vt M N)) nl2)
       (\vt':VarType \M':Term \N':Term ->
        eq:I (Term.pi vt M N) (Term.pi vt' M' N') ->
        I.cong3 (\x:VarType \y:Term \z:Term -> NotLam.pi x y z)
		(I.cong Term.vt eq) (I.cong Term.arg1 eq) (I.cong Term.arg2 eq))
     NotLam.eqterm 
       (\vt':VarType \M':Term \N':Term
        \eq:I (Term.pi vt M N) (Term.pi vt' M' N') ->
        I.cong3 Var.pi
       (\vt:VarType \M
     		 I (Term.pi M N) t' -> I (Var.pi M N) nl2)
       
     (caseelse (NotLam.pi vt M N))
  I.trans (I.symm (NotLam.alleq.aux nl1)) (NotLam.alleq.aux nl2)

Definition Term.caseLam = \C:(Term -> U1)
  \caselam :(vt:VarType -> M:Term -> N:Term -> C (Term.lam vt M N))
  \caseelse:({t:Term} -> NotLam t -> C t) ->
  Term.rec (\t:Term -> C t)
    (\vt:VarType \M:Term \_:C M \N:Term \_:C N -> caselam vt M N)
    (\vt:VarType \M:Term \_:C M \N:Term \_:C N -> caseelse (NotLam.pi vt M N))
    (\M:Term \_:C M \N:Term \_:C N -> caseelse (NotLam.app M N))
    (\vt:VarType \n:Nat -> caseelse (NotLam.var vt n))
    (\vt:VarType -> caseelse (NotLam.univ vt))

