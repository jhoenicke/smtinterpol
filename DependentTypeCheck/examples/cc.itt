Definition Prop = U
Inductive T : Prop = tt:T
Inductive F : Prop =

Inductive * : A:U -> B:U -> U =
  p:A->B-> * A B
Definition *.1 = \A:U \B:U -> *.rec A B (\_:* A B -> A) (\a:A \_:B -> a)
Definition *.2 = \A:U \B:U -> *.rec A B (\_:* A B -> B) (\_:A \b:B -> b)

Inductive + : A:U -> B:U -> U =
  1: A -> + A B,
  2: B -> + A B
Definition +.case = \A:U\B:U\C:U \1:(A -> C) \2:(B -> C) ->
  +.rec A B (\_:+ A B -> C) 1 2

Inductive Sigma : A:U -> B:(A->U) -> U =
  p:a:A->b:(B a)-> Sigma A B
Definition Sigma.1 = \A:U \B:(A->U) ->
  Sigma.rec A B (\_:Sigma A B -> A) (\a:A \_:B a -> a)
Definition Sigma.2 = \A:U \B:(A->U) ->
  Sigma.rec A B (\p:Sigma A B -> B (Sigma.1 A B p)) (\a:A \b:B a -> b)

Inductive I : {A:U} -> a:A -> b:A -> U =
  r : I a a

Definition I.symm = {\A:U} {\a:A} {\b:A} ->
  I.rec a (\x:A \_: I a x -> I x a) (I.r a) b
Definition I.subst = {\A:U} {\a:A} {\b:A} \eq:I a b \C:(A -> U) ->
    I.rec a (\x:A \_:I a x -> C a -> C x)
      (\z:C a -> z) b eq
TypeCheck I.subst :
  {A:U} -> {a:A} -> {b:A} -> I a b -> C:(A -> U) -> C a -> C b
EvaluateType I.subst
Definition I.subst2 = {\A:U} {\a1:A} {\a2:A} \eq1:I a1 a2
	              {\B:U} {\b1:B} {\b2:B} \eq2:I b1 b2
		      \C:(A -> B -> U) ->
  I.subst eq2 (\b:B -> C a1 b1 -> C a2 b)
    (I.subst eq1 (\a:A -> C a b1))
TypeCheck I.subst2 :
  {A:U} -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {B:U} -> {b1:B} -> {b2:B} -> I b1 b2 -> C:(A -> B -> U) -> C a1 b1 -> C a2 b2
Definition I.rsubst = {\A:U} {\b:A} {\a:A} \eq:I a b \C:(A -> U) ->
    I.subst (I.symm eq) C
Definition I.cong = {\A:U} {\B:U}
  \c:(A -> B) {\a:A} {\b:A} \eq: I a b ->
    I.subst eq (\x:A -> I (c a) (c x)) (I.r (c a))
TypeCheck I.cong :
  A:U -> B:U -> c:(A -> B) -> {a:A} -> {b:A} -> I a b -> I (c a) (c b)
Definition I.cong2 = {\A:U} {\B:U} {\C:U} \f:(A->B->C)
  {\a1:A} {\a2:A} \eq1: I a1 a2 {\b1:B}{\b2:B} \eq2: I b1 b2 ->
  I.subst eq1 (\x:A -> I (f a1 b1) (f x b2)) (I.cong (f a1) eq2)
TypeCheck I.cong2 :
  {A:U} -> {B:U} -> {C:U} -> f:(A -> B -> C) -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {b1:B} -> {b2:B} -> I b1 b2 -> I (f a1 b1) (f a2 b2)

Inductive Bool : U = tt:Bool, ff:Bool
Inductive Nat : U =
  0 : Nat,
  s : Nat -> Nat
Definition Nat.1 = Nat.s Nat.0

Definition Nat.plus = Nat.rec (\_:Nat -> Nat -> Nat)
    (\b:Nat -> b) (\a:Nat \rec:(Nat->Nat) \b:Nat -> Nat.s (rec b))

Definition Nat.plus.zero =
    Nat.rec (\a:Nat -> I (Nat.plus a Nat.0) a)
       (I.r Nat.0)
       (\a:Nat \Hyp:I (Nat.plus a Nat.0) a -> I.cong Nat.s Hyp)
Definition Nat.s.plus.commutes = \a:Nat \b:Nat ->
    Nat.rec (\a:Nat -> I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)))
       (I.r (Nat.s b))
       (\a:Nat \Hyp: I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)) ->
        I.subst Hyp
	   (\x:Nat -> I (Nat.s (Nat.s (Nat.plus a b))) (Nat.s x))
	   (I.r (Nat.s (Nat.s (Nat.plus a b)))))
       a

Definition Nat.plus.commutes = \a:Nat ->
    Nat.rec (\b:Nat -> I (Nat.plus a b) (Nat.plus b a))
       (Nat.plus.zero a)
       (\b:Nat \Hyp:I (Nat.plus a b) (Nat.plus b a) ->
        I.subst Hyp
	        (\x:Nat -> I (Nat.plus a (Nat.s b)) (Nat.s x))
		(I.symm (Nat.s.plus.commutes a b)))

Definition Nat.iter = {\A:U} \f:(A->A) ->
  Nat.rec (\n:Nat -> A -> A) (\a:A -> a) (\_:Nat \rec:(A->A) \a:A -> f (rec a))
Definition Nat.iter.associative = {\A:U} \f:(A->A) \n:Nat \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)))
    (I.r (f a))
    (\n:Nat \Hyp:I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)) ->
     I.cong f Hyp)
    n
Definition Nat.iter.plus = {\A:U} \f:(A->A) \m:Nat \n:Nat \a:A ->
  Nat.rec (\m:Nat -> I (Nat.iter f m (Nat.iter f n a))
                       (Nat.iter f (Nat.plus m n) a))
    (I.r (Nat.iter f n a))
    (\m:Nat
     \eq:I (Nat.iter f m (Nat.iter f n a)) (Nat.iter f (Nat.plus m n) a) ->
     I.cong f eq)
    m

Definition Nat.iter.g.commutes = \A:U \f:(A->A) \g:(A->A)
  \fgcommutes:(a:A -> I (f (g a)) (g (f a))) \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f n (g a)) (g (Nat.iter f n a)))
    (I.r (g a))
    (\n:Nat\Hyp:I (Nat.iter f n (g a)) (g (Nat.iter f n a)) ->
     I.subst (fgcommutes (Nat.iter f n a))
        (\x:A -> I (Nat.iter f (Nat.s n) (g a)) x)
        (I.cong f Hyp))

Inductive Test : b:Bool -> U =
  tt : Test Bool.tt
Definition Test.false = \test:Test Bool.ff \C:U ->
  Test.rec (\b:Bool \_:Test b -> Bool.rec (\_:Bool->U) T C b) (T.tt) Bool.ff test
TypeCheck Test.false : (Test Bool.ff -> C:U -> C)

Inductive VarType : U = []:VarType, *:VarType

Inductive Term : U =
  lam   : VarType -> Term -> Term -> Term,
  pi    : VarType -> Term -> Term -> Term,
  app   : Term -> Term -> Term,
  var   : VarType -> Nat -> Term,
  univ  : VarType -> Term

Definition Term.[] = Term.univ VarType.[]
Definition Term.*  = Term.univ VarType.*

; increment m by one, if m greater equal n.
Definition Nat.shiftn =
  Nat.rec (\n:Nat -> m:Nat -> Nat)
     Nat.s
     (\_:Nat \shiftn1:(Nat -> Nat) ->
       Nat.rec (\m:Nat -> Nat) Nat.0
	  (\m1:Nat \_:Nat -> Nat.s (shiftn1 m1)))

Definition Nat.shiftn.commutes.Thesis = \i:Nat -> \n:Nat -> \m:Nat ->
    I (Nat.shiftn n (Nat.shiftn (Nat.plus m n) i))
          (Nat.shiftn (Nat.s (Nat.plus m n)) (Nat.shiftn n i))
 
Definition Nat.shiftn.commutes =
   Nat.rec (\n:Nat -> m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i n m)
     (Nat.rec (\m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 m)
        (\i:Nat -> I.r (Nat.s (Nat.s i)))
	(\m:Nat \HypM: (i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 m) ->
	 Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 (Nat.s m))
	   (I.r (Nat.s Nat.0))
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i Nat.0 (Nat.s m) ->
	    I.r (Nat.s (Nat.s (Nat.shiftn (Nat.plus m Nat.0) i))))))
     (\n:Nat \HypN: (m:Nat ->i:Nat -> Nat.shiftn.commutes.Thesis i n m) ->
      Nat.rec (\m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) m)
        (Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) Nat.0)
	   (I.r Nat.0)
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i (Nat.s n) Nat.0 ->
	    I.cong Nat.s (HypN Nat.0 i)))
        (\m:Nat \HypM: (i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) m) ->
	 Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) (Nat.s m))
	   (I.r Nat.0)
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i (Nat.s n) (Nat.s m) ->
	    I.subst (Nat.s.plus.commutes m n)
		    (\x:Nat -> I (Nat.s (Nat.shiftn n (Nat.shiftn x i)))
		               (Nat.s (Nat.shiftn (Nat.s x) (Nat.shiftn n i))))
	    (I.cong Nat.s (HypN (Nat.s m) i)))))

Definition Nat.plus.shiftn.lemma = \i:Nat \n:Nat ->
  I.subst (Nat.plus.commutes n i)
          (\x:Nat -> I (Nat.shiftn n x) (Nat.plus (Nat.shiftn Nat.0 i) n))
  (I.subst (Nat.plus.commutes n (Nat.shiftn Nat.0 i))
           (\x:Nat -> I (Nat.shiftn n (Nat.plus n i)) x)
    (Nat.rec (\n:Nat -> I (Nat.shiftn n (Nat.plus n i))
                              (Nat.plus n (Nat.shiftn Nat.0 i)))
	  (I.r (Nat.s i))
	  (\n:Nat \Hyp:I (Nat.shiftn n (Nat.plus n i))
			 (Nat.plus n (Nat.shiftn Nat.0 i)) ->
	   I.cong Nat.s Hyp)
	  n))

; Increment all variables >= n by one.
Definition Term.shiftn =
  Term.rec (\_:Term -> n:Nat -> Term)
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.lam vt (rt1 n) (rt2 (Nat.s n)))
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.pi vt (rt1 n) (rt2 (Nat.s n)))
    (\_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.app (rt1 n) (rt2 n))
    (\vt:VarType \i: Nat \n:Nat -> Term.var vt (Nat.shiftn n i))
    (\vt:VarType \n: Nat -> Term.univ vt)
Definition Term.shiftvar = \term:Term ->
    Term.shiftn term Nat.0

Definition Term.shiftn.commutes.Thesis = \T:Term -> n:Nat -> m:Nat ->
    I (Term.shiftn (Term.shiftn T (Nat.plus m n)) n)
      (Term.shiftn (Term.shiftn T n) (Nat.s (Nat.plus m n)))

Definition Term.shiftn.commutes =
   Term.rec (\T:Term -> Term.shiftn.commutes.Thesis T)
      (\vt:VarType
       \S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 (\x:Term \y:Term -> Term.lam vt x y)
	   (HypS n m)
	   (I.rsubst (Nat.s.plus.commutes m n)
		(\x:Nat -> I
                 (Term.shiftn (Term.shiftn M x) (Nat.s n))
	         (Term.shiftn (Term.shiftn M (Nat.s n)) (Nat.s x)))
	        (HypM (Nat.s n) m)))
      (\vt:VarType
       \S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 (\x:Term \y:Term -> Term.pi vt x y)
	   (HypS n m)
	   (I.rsubst (Nat.s.plus.commutes m n)
		(\x:Nat -> I
                 (Term.shiftn (Term.shiftn M x) (Nat.s n))
	         (Term.shiftn (Term.shiftn M (Nat.s n)) (Nat.s x)))
	        (HypM (Nat.s n) m)))
      (\S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 (\x:Term \y:Term -> Term.app x y) (HypS n m) (HypM n m))
     (\vt:VarType \i:Nat \n:Nat \m:Nat ->
      I.cong (\i:Nat -> Term.var vt i)
             (Nat.shiftn.commutes n m i))
     (\vt:VarType \n:Nat \m:Nat -> I.r (Term.univ vt))
TypeCheck Term.shiftn.commutes : T:Term -> Term.shiftn.commutes.Thesis T
Definition Term.shiftvarn.commutes  = \T:Term \n:Nat ->
     I.subst  (Nat.plus.zero n)
	      (\x:Nat -> I (Term.shiftvar (Term.shiftn T x))
	                   (Term.shiftn (Term.shiftvar T) (Nat.s x)))
	      (Term.shiftn.commutes T Nat.0 n)
TypeCheck Term.shiftvarn.commutes : T:Term -> n:Nat ->
     I (Term.shiftvar (Term.shiftn T n))
       (Term.shiftn (Term.shiftvar T) (Nat.s n))

Inductive Subst : U =
   offset : Nat -> Subst,
   cons   : Term -> Subst -> Subst,
   consn  : Nat -> Subst -> Subst

Definition Subst.shift =
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset (Nat.s i))
    (\t:Term \_:Subst \sigmashift:Subst ->
     Subst.cons (Term.shiftvar t) sigmashift)
    (\i:Nat \_:Subst \sigmashift:Subst ->
     Subst.consn (Nat.s i) sigmashift)
Definition Subst.consshift = \sigma:Subst ->
  Subst.consn Nat.0 (Subst.shift sigma)
Definition Subst.len =
  Subst.rec (\_:Subst -> Nat)
    (\i:Nat -> Nat.0)
    (\_:Term \_:Subst \r:Nat -> Nat.s r)
    (\_:Nat \_:Subst \r:Nat -> Nat.s r)
Definition Subst.drop1 =
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset (Nat.s i))
    (\t:Term \sigma:Subst \_:Subst -> sigma)
    (\n:Nat \sigma:Subst \_:Subst -> sigma)
Definition Subst.drop = Nat.iter Subst.drop1
Definition Subst.evalhead = \vt:VarType ->
  Subst.rec (\tau:Subst -> Term)
    (\i:Nat -> Term.var vt i)
    (\t:Term \_:Subst \_:Term -> t)
    (\n:Nat \_:Subst \_:Term -> Term.var vt n)
Definition Subst.eval = \sigma:Subst \vt:VarType \n:Nat ->
  Subst.evalhead vt (Subst.drop n sigma)

Definition Term.substapp =
  Term.rec (\_:Term -> Subst -> Term)
    (\vt:VarType \_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst -> Term)
     \subst:Subst ->
     Term.lam vt (r1 subst) (r2 (Subst.consshift subst)))
    (\vt:VarType \_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst->Term)
     \subst:Subst ->
     Term.pi vt (r1 subst) (r2 (Subst.consshift subst)))
    (\_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst->Term)
     \subst:Subst -> Term.app (r1 subst) (r2 subst))
    (\vt:VarType \n:Nat \subst:Subst -> Subst.eval subst vt n)
    (\vt:VarType \subst:Subst -> Term.univ vt)

Definition Subst.unit = \t:Term -> Subst.cons t (Subst.offset Nat.0)
Definition Term.subst = \term:Term \subst:Term ->
    Term.substapp term (Subst.unit subst)

Definition Subst.isEmpty =
  Subst.rec (\_:Subst -> U)
     (\_:Nat -> T) (\_:Term\_:Subst\_:U -> F) (\_:Nat\_:Subst\_:U -> F)

Definition Subst.substshiftn = \n:Nat ->
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset i)
    (\t:Term \sigma:Subst \recurse:Subst ->
     Subst.cons (Term.shiftn t n) recurse)
    (\i:Nat \sigma:Subst \recurse:Subst ->
     Subst.consn (Nat.shiftn n i) recurse)

Definition Subst.shift.substshiftn.commutes = \n:Nat ->
  Subst.rec (\sigma:Subst ->
     I (Subst.shift (Subst.substshiftn n sigma))
       (Subst.substshiftn (Nat.s n) (Subst.shift sigma)))
    (\i:Nat -> I.r (Subst.offset (Nat.s i)))
    (\t:Term \sigma:Subst
     \Hyp: I (Subst.shift (Subst.substshiftn n sigma))
             (Subst.substshiftn (Nat.s n) (Subst.shift sigma)) ->
     I.cong2 (\t:Term \sigma:Subst -> Subst.cons t sigma)
	(Term.shiftvarn.commutes t n) Hyp)
    (\i:Nat \sigma:Subst
     \Hyp: I (Subst.shift (Subst.substshiftn n sigma))
             (Subst.substshiftn (Nat.s n) (Subst.shift sigma)) ->
     I.cong (\sigma:Subst -> Subst.consn (Nat.s (Nat.shiftn n i)) sigma)
	    Hyp)
	
Definition Subst.drop1.substshiftn.commutes = \n:Nat ->
  Subst.rec (\sigma:Subst ->
             I (Subst.drop1 (Subst.substshiftn n sigma))
	       (Subst.substshiftn n (Subst.drop1 sigma)))
    (\i:Nat -> I.r (Subst.offset (Nat.s i)))
    (\t:Term \sigma:Subst
     \_:     I (Subst.drop1 (Subst.substshiftn n sigma))
	       (Subst.substshiftn n (Subst.drop1 sigma)) ->
     I.r (Subst.substshiftn n sigma))
    (\i:Nat \sigma:Subst
     \_:     I (Subst.drop1 (Subst.substshiftn n sigma))
	       (Subst.substshiftn n (Subst.drop1 sigma)) ->
     I.r (Subst.substshiftn n sigma))
		     
Definition Subst.substshift.consshift.Claim = 
  \subst:Subst -> n:Nat ->
     I (Subst.consshift (Subst.substshiftn n subst))
       (Subst.substshiftn (Nat.s n) (Subst.consshift subst))
Definition Subst.substshift.consshift.Lemma = \subst:Subst ->
  \n:Nat ->
  I.cong (\sigma:Subst -> Subst.consn Nat.0 sigma)
     (Subst.shift.substshiftn.commutes n subst)

TypeCheck Subst.substshift.consshift.Lemma :
  sigma:Subst -> Subst.substshift.consshift.Claim sigma

Definition Subst.drop.offset = \n:Nat ->
  Nat.rec (\i:Nat -> I (Subst.drop i (Subst.offset n))
                       (Subst.offset (Nat.plus i n)))
    (I.r (Subst.offset n))
    (\i:Nat \Hyp:I (Subst.drop i (Subst.offset n))
	           (Subst.offset (Nat.plus i n)) ->
     I.cong Subst.drop1 Hyp)
            

Definition Subst.evalshift.offsetcomp = \m:Nat \offset:Nat \n:Nat ->
   I.rsubst (Subst.drop.offset offset m)
	   (\x: Subst -> I x (Subst.offset n) ->
	                 I (Nat.plus m offset) n)
    (\Hyp: I (Subst.offset (Nat.plus m offset))
             (Subst.offset n)  ->
     I.cong (Subst.rec (\_:Subst -> Nat) (\x:Nat -> x)
	               (\_:Term \_:Subst\_:Nat -> Nat.0)
	               (\_:Nat \_:Subst\_:Nat -> Nat.0)) Hyp)
	    

Definition Subst.evalshift.help = \m:Nat \n:Nat ->
   I.subst (Nat.plus.commutes m (Nat.s n))
	   (\x:Nat -> I (Nat.shiftn x m) m)
	   (Nat.rec (\m:Nat -> I (Nat.shiftn (Nat.plus m (Nat.s n)) m) m)
	      (I.r Nat.0)
	      (\m:Nat \Hyp:I (Nat.shiftn (Nat.plus m (Nat.s n)) m) m ->
	       I.cong Nat.s Hyp)
	      m)



Definition Subst.evalshift.claim = \n:Nat \vt:VarType ->
  \i:Nat -> \m:Nat -> sigma:Subst ->
  I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
  I (Term.shiftn (Subst.eval sigma vt i) n)
    (Subst.eval (Subst.substshiftn n sigma) vt (Nat.shiftn (Nat.s m) i))

Definition Subst.evalshift.lemma = \vt:VarType ->
   Nat.rec (\i:Nat -> (m:Nat -> n:Nat -> Subst.evalshift.claim n vt i m))
    (\m:Nat \n:Nat ->
     (Subst.rec (\sigma:Subst ->
                 eq:I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
     		 I (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     		   (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
        (\offset:Nat
	 \eq : I (Subst.drop (Nat.s m) (Subst.offset offset))
	       (Subst.offset n) ->
	 ; argue with eq that m+1+offset = n
         I.cong (\x:Nat -> Term.var vt x)
  	    (I.subst
	       (Subst.evalshift.offsetcomp (Nat.s m) offset n eq)
	       (\x:Nat -> I (Nat.shiftn x offset) offset)
	       (Subst.evalshift.help offset m)))
	(\t:Term \sigma:Subst
	 \_:(I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
	     I (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     	       (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
	 \_:I (Subst.drop (Nat.s m) (Subst.cons t sigma))
	      (Subst.offset n) ->
	 I.r (Term.shiftn t n))
	(\i:Nat \sigma:Subst
	 \_:(I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
	     I (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     	       (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
	 \_:I (Subst.drop (Nat.s m) (Subst.consn i sigma))
	      (Subst.offset n) ->
	 I.r (Term.var vt (Nat.shiftn n i)))))
    (\i:Nat \Hyp:(m:Nat -> n:Nat -> Subst.evalshift.claim n vt i m)
     \m:Nat \n:Nat \sigma:Subst
     \eq:I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
     I.rsubst (I.subst (Subst.drop1.substshiftn.commutes n sigma)
		       (\x: Subst -> I
              (Subst.drop (Nat.s (Nat.shiftn m i)) (Subst.substshiftn n sigma))
              (Subst.drop (Nat.shiftn m i) x))
		       (Nat.iter.associative Subst.drop1
		       			     (Nat.shiftn m i)
					     (Subst.substshiftn n sigma)))
	      (\x:Subst ->
	       I (Term.shiftn (Subst.eval sigma vt (Nat.s i)) n)
                 (Subst.evalhead vt x))
     (I.rsubst (Nat.iter.associative Subst.drop1 i sigma)
	      (\x:Subst -> I (Term.shiftn (Subst.evalhead vt x) n)
      (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt (Nat.shiftn m i)))
     (Nat.rec (\m:Nat ->
               eq:I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
               I (Term.shiftn (Subst.eval (Subst.drop1 sigma) vt i) n)
                 (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt
		      		  (Nat.shiftn m i)))
       (\eq:I (Subst.drop1 sigma) (Subst.offset n) ->
	I.rsubst eq
	   (\x:Subst -> I (Term.shiftn (Subst.eval x vt i) n)
               (Subst.eval (Subst.substshiftn n x) vt (Nat.shiftn Nat.0 i)))
	(I.rsubst (Subst.drop.offset n i)
		 (\x:Subst -> I (Term.shiftn (Subst.evalhead vt x) n)
               (Subst.eval (Subst.offset n) vt (Nat.shiftn (Nat.0) i)))
	(I.rsubst (Subst.drop.offset n (Nat.shiftn (Nat.0) i))
		 (\x:Subst -> I (Term.shiftn (Term.var vt (Nat.plus i n)) n)
                                (Subst.evalhead vt x))

		 (I.cong (\x:Nat -> Term.var vt x)
	                (Nat.plus.shiftn.lemma i n)))))
       (\m:Nat \_:(I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
               I (Term.shiftn (Subst.eval (Subst.drop1 sigma) vt i) n)
                 (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt
		      		  (Nat.shiftn m i)))
        \eq:I (Subst.drop (Nat.s (Nat.s m)) sigma) (Subst.offset n) ->
        (Hyp m n (Subst.drop1 sigma)
	  (I.subst (Nat.iter.associative Subst.drop1 (Nat.s m) sigma)
		   (\x:Subst -> I x (Subst.offset n))
		   eq)))
       m eq)))

Definition Term.substshift.shiftn.Thesis =
  \t:Term -> n:Nat -> sigma:Subst ->
     I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
     I (Term.shiftn (Term.substapp t sigma) n)
       (Term.substapp (Term.shiftn t (Nat.s n))
		      (Subst.substshiftn n sigma))

Definition Subst.drop1.shift.commutes =
  Subst.rec (\sigma:Subst ->
             I (Subst.drop1 (Subst.shift sigma))
	       (Subst.shift (Subst.drop1 sigma)))
    (\i:Nat -> I.r (Subst.offset (Nat.s (Nat.s i))))
    (\t:Term \sigma:Subst
     \_:     I (Subst.drop1 (Subst.shift sigma))
	       (Subst.shift (Subst.drop1 sigma)) ->
     I.r (Subst.shift sigma))
    (\i:Nat \sigma:Subst
     \_:     I (Subst.drop1 (Subst.shift sigma))
	       (Subst.shift (Subst.drop1 sigma)) ->
     I.r (Subst.shift sigma))

Definition Subst.drop.shift.commutes =
  Nat.iter.g.commutes Subst Subst.drop1 Subst.shift Subst.drop1.shift.commutes

Definition Term.substshift.shiftn.shifteq = \n:Nat \vt:VarType \sigma:Subst ->
  (I.rsubst (Nat.iter.associative Subst.drop1 (Nat.s n)
	                          (Subst.consshift sigma))
   (\x:Subst ->
      I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
      I x (Subst.offset (Nat.s n)))
   (\eq:I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
    I.rsubst (Subst.drop.shift.commutes sigma (Nat.s n))
	     (\x:Subst -> I x (Subst.offset (Nat.s n)))
    (I.cong Subst.shift eq)))

Definition Term.substshift.shiftn =
  Term.rec (\t:Term -> Term.substshift.shiftn.Thesis t)
    (\vt:VarType
     \M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat
     \subst:Subst
     \eq : I (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 (\x:Term \y:Term -> Term.lam vt x y)
	   (HypM n subst eq)
	   (I.rsubst (Subst.substshift.consshift.Lemma subst n)
		    (\x: Subst ->
                      I (Term.shiftn (Term.substapp N (Subst.consshift subst)) (Nat.s n))
		        (Term.substapp (Term.shiftn N (Nat.s (Nat.s n))) x))
	      (HypN (Nat.s n) (Subst.consshift subst)
	            (Term.substshift.shiftn.shifteq n vt subst eq))))
    (\vt:VarType
     \M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat \subst:Subst
     \eq : I (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 (\x:Term \y:Term -> Term.pi vt x y)
	   (HypM n subst eq)
	   (I.rsubst (Subst.substshift.consshift.Lemma subst n)
		    (\x: Subst ->
                      I (Term.shiftn (Term.substapp N (Subst.consshift subst)) (Nat.s n))
		        (Term.substapp (Term.shiftn N (Nat.s (Nat.s n))) x))
	      (HypN (Nat.s n) (Subst.consshift subst)
	            (Term.substshift.shiftn.shifteq n vt subst eq))))
    (\M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat \subst:Subst
     \eq : I (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 (\x:Term \y:Term -> Term.app x y)
	   (HypM n subst eq) (HypN n subst eq))
    (\vt: VarType \i:Nat
     \n:Nat \sigma:Subst ->
     Subst.evalshift.lemma vt i n n sigma)
    (\vt: VarType \n:Nat \sigma:Subst
     \eq : I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
     I.r (Term.univ vt))

Definition Term.subst.shift = \t:Term \subst:Term \n:Nat ->
  Term.substshift.shiftn t n (Subst.unit subst)
     (Nat.rec (\n:Nat -> I (Subst.drop (Nat.s n) (Subst.unit subst))
      	      	      	   (Subst.offset n))
        (I.r (Subst.offset Nat.0))
	(\n:Nat \Hyp:I (Subst.drop (Nat.s n) (Subst.unit subst))
		       (Subst.offset n) ->
	 I.cong Subst.drop1 Hyp)
	n)
    
TypeCheck Term.subst.shift : t:Term -> subst:Term -> n:Nat ->
    I (Term.shiftn (Term.subst t subst) n)
      (Term.subst (Term.shiftn t (Nat.s n)) (Term.shiftn subst n))

Inductive ConvStep : Term -> Term -> U =
  beta : vt:VarType -> T:Term -> M:Term -> N:Term ->
         ConvStep (Term.app (Term.lam vt T M) N) (Term.subst M N),
  lam1 : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.lam vt T1 M) (Term.lam vt T2 M),
  lam2 : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.lam vt T M1) (Term.lam vt T M2),
  pi1  : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.pi vt T1 M) (Term.pi vt T2 M),
  pi2  : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.pi vt T M1) (Term.pi vt T M2),
  app1 : {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> N:Term ->
         ConvStep (Term.app M1 N) (Term.app M2 N),
  app2 : M:Term -> {N1:Term} -> {N2:Term} -> ConvStep N1 N2 ->
         ConvStep (Term.app M N1) (Term.app M N2)

Definition ConvStep.shiftn = 
  ConvStep.rec (\T:Term \S: Term \step : ConvStep T S -> n:Nat ->
                ConvStep (Term.shiftn T n) (Term.shiftn S n))
    (\vt:VarType \T:Term \M:Term \N:Term \n:Nat ->
     I.rsubst (Term.subst.shift M N n)
	      (\x: Term -> ConvStep (Term.shiftn (Term.app (Term.lam vt T M) N) n) x)
     (ConvStep.beta vt (Term.shiftn T n) (Term.shiftn M (Nat.s n)) (Term.shiftn N n)))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.lam1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \T:Term \n:Nat ->
     ConvStep.lam2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.pi1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \T:Term \n:Nat ->
     ConvStep.pi2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.app1 (hyp n) (Term.shiftn M n))
    (\T:Term \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \n:Nat ->
     ConvStep.app2 (Term.shiftn T n) (hyp n))

Inductive ConvSymmStep : M:Term -> N:Term -> U =
  forw : ConvStep M N -> ConvSymmStep M N,
  back : ConvStep N M -> ConvSymmStep M N

Definition ConvSymmStep.shiftn = \T:Term \S: Term ->
   ConvSymmStep.rec T S (\step : ConvSymmStep T S -> n:Nat -> 
                         ConvSymmStep (Term.shiftn T n) (Term.shiftn S n))
	(\fstep:ConvStep T S \n:Nat -> ConvSymmStep.forw (Term.shiftn T n) (Term.shiftn S n)
			     	       			 (ConvStep.shiftn T S fstep n))
	(\bstep:ConvStep S T \n:Nat -> ConvSymmStep.back (Term.shiftn T n) (Term.shiftn S n)
			     	       			 (ConvStep.shiftn S T bstep n))

Inductive List : A:U -> U =
  nil  : List A,
  cons : A -> List A -> List A

Inductive VarList : U =
  nil  : VarList,
  cons : vt:VarType -> T:Term -> Gamma:VarList -> VarList

Inductive CCTypeCheck : VarList -> Term -> Term -> Prop =
  ax   : CCTypeCheck VarList.nil Term.* Term.[],
  var  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.var vt Nat.0) (Term.shiftvar T),
  weak : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         {M : Term} -> {S:Term} -> CCTypeCheck Gamma M S ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.shiftvar M) (Term.shiftvar S),
  pi   : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
	 {vt2 : VarType} -> {S : Term} ->
	 CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2),
  lam  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         {M:Term} -> {S:Term} ->
         CCTypeCheck (VarList.cons vt T Gamma) M S ->
	 {vt2: VarType} -> CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.lam vt T M) (Term.pi vt T S),
  app  : {Gamma:VarList} -> {M:Term} -> {vt: VarType} -> {T : Term} -> {S:Term} ->
         CCTypeCheck Gamma M (Term.pi vt T S) ->
	 {N : Term} -> CCTypeCheck Gamma N T ->
	 CCTypeCheck Gamma (Term.app M N) (Term.subst S N),
  conv : {Gamma:VarList} -> {M:Term} -> {T:Term} -> CCTypeCheck Gamma M T ->
	 {S : Term} -> ConvSymmStep T S ->
	 CCTypeCheck Gamma M S

Inductive VarListTypeCheck : VarList -> U =
  nil  : VarListTypeCheck VarList.nil,
  cons : {vt:VarType} -> {T:Term} -> {Gamma:VarList} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
 	 VarListTypeCheck Gamma -> 
         VarListTypeCheck (VarList.cons vt T Gamma)

Definition CCTypeCheck.case =
  \C:(Gamma:VarList -> M:Term -> S:Term -> U1)
  \caseax: (C VarList.nil Term.* Term.[])
  \casevar:(Gamma:VarList -> vt:VarType -> T : Term ->
            CCTypeCheck Gamma T (Term.univ vt) ->
	    C (VarList.cons vt T Gamma) (Term.var vt Nat.0) (Term.shiftvar T))
  \caseweak:(Gamma:VarList -> vt:VarType -> T : Term ->
             CCTypeCheck Gamma T (Term.univ vt) ->
             M : Term -> S:Term -> CCTypeCheck Gamma M S ->
             C (VarList.cons vt T Gamma) (Term.shiftvar M) (Term.shiftvar S))
  \casepi:  (Gamma:VarList -> vt:VarType -> T : Term ->
             CCTypeCheck Gamma T (Term.univ vt) ->
	     vt2 : VarType -> S : Term ->
	     CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	     C Gamma (Term.pi vt T S) (Term.univ vt2))
  \caselam: (Gamma:VarList -> vt:VarType -> T : Term -> M:Term -> S:Term ->
             CCTypeCheck (VarList.cons vt T Gamma) M S ->
	     vt2: VarType ->
	     CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	     C Gamma (Term.lam vt T M) (Term.pi vt T S))
  \caseapp: (Gamma:VarList -> M:Term -> vt: VarType -> T : Term -> S:Term ->
             CCTypeCheck Gamma M (Term.pi vt T S) ->
	     N : Term -> CCTypeCheck Gamma N T ->
	     C Gamma (Term.app M N) (Term.subst S N))
  \caseconv:(Gamma:VarList -> M:Term -> T:Term -> CCTypeCheck Gamma M T ->
	     S : Term -> ConvSymmStep T S ->
	     C Gamma M S) ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
  		   C Gamma M S)
    caseax
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt) ->
     casevar Gamma vt T prf)
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt)
     \M : Term \S:Term \prf2: CCTypeCheck Gamma M S \_: C Gamma M S ->
     caseweak Gamma vt T prf M S prf2)
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt)
     \vt2 : VarType \S:Term
     \prf2: CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_: C (VarList.cons vt T Gamma) S (Term.univ vt2) ->
     casepi Gamma vt T prf vt2 S prf2)
    (\Gamma:VarList \vt:VarType \T : Term \M:Term \S:Term
     \prf: CCTypeCheck (VarList.cons vt T Gamma) M S
     \_: C (VarList.cons vt T Gamma) M S
     \vt2 : VarType 
     \prf2: CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \_: C Gamma (Term.pi vt T S) (Term.univ vt2) ->
     caselam Gamma vt T M S prf vt2 prf2)
    (\Gamma:VarList \M:Term \vt:VarType \T : Term \S:Term
     \prf: CCTypeCheck Gamma M (Term.pi vt T S) \_: C Gamma M (Term.pi vt T S)
     \N:Term \prf2: CCTypeCheck Gamma N T \_: C Gamma N T ->
     caseapp Gamma M vt T S prf N prf2)
    (\Gamma:VarList \M:Term \T : Term
     \prf: CCTypeCheck Gamma M T \_: C Gamma M T
     \S:Term \step:ConvSymmStep T S ->
     caseconv Gamma M T prf S step)

Definition CCTypeCheck.ax2 = 
  VarListTypeCheck.rec ({\Gamma:VarList} \_:VarListTypeCheck Gamma ->
                        CCTypeCheck Gamma Term.* Term.[])
     CCTypeCheck.ax
     (\vt:VarType \T:Term \Gamma:VarList
      \tc:CCTypeCheck Gamma T (Term.univ vt)
      \_:VarListTypeCheck Gamma
      \r:CCTypeCheck Gamma Term.* Term.[] ->
        CCTypeCheck.weak tc r)

Definition CCTypeCheck.gammatc =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
                   VarListTypeCheck Gamma)
    VarListTypeCheck.nil
    ;var
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma
     \M : Term \S:Term \_: CCTypeCheck Gamma M S \_:VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Definition VarList.deleten =
  Nat.rec (\n:Nat -> VarList -> VarList)
    (\Gamma:VarList -> Gamma)
    (\_:Nat \delrec:(VarList -> VarList) ->
     VarList.rec (\Gamma:VarList -> VarList) VarList.nil
        (\vt1:VarType \T1:Term \Gamma:VarList \_:VarList -> delrec Gamma))
    
Definition VarList.insertn =
  Nat.rec (\n:Nat -> VarType -> Term -> VarList -> VarList)
    VarList.cons
    (\n:Nat \insertrec:(VarType -> Term -> VarList -> VarList)
     \vt:VarType \T0:Term ->
     VarList.rec (\Gamma:VarList -> VarList)
        (insertrec vt T0 VarList.nil)
	(\vt1:VarType \T1:Term \Gamma:VarList \_:VarList ->
	 VarList.cons vt1 (Term.shiftn T1 n) (insertrec vt T0 Gamma)))
	 
Definition deletenil =
  Nat.rec (\n:Nat -> I (VarList.deleten n VarList.nil) VarList.nil)
     (I.r VarList.nil)
     (\n:Nat \_:I (VarList.deleten n VarList.nil) VarList.nil ->
      I.r VarList.nil)

Definition CCTypeCheck.weakn =
  \vt:VarType \T0:Term ->
  CCTypeCheck.rec ({\Gamma:VarList} {\M:Term} {\N:Term}
  		   \_:CCTypeCheck Gamma M N ->
                   n:Nat ->
		   CCTypeCheck (VarList.deleten n Gamma)
		       		T0 (Term.univ vt) ->
                   CCTypeCheck (VarList.insertn n vt T0 Gamma)
		                (Term.shiftn M n)
				(Term.shiftn N n))
    ;ax
    (Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
	      CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                    (Term.shiftn Term.* n)
				    (Term.shiftn Term.[] n))
       (\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 CCTypeCheck.ax)
       (\n:Nat
        \rec:(CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
              CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                 (Term.shiftn Term.* n)
				 (Term.shiftn Term.[] n))
	\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
	rec (I.rsubst (deletenil n)
		      (\x:VarList -> CCTypeCheck x T0 (Term.univ vt))
		      prfT0)))
    ;var
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.var vt1 Nat.0) n)
			  (Term.shiftn (Term.shiftvar T1) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.var prf1))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.var vt1 Nat.0) n)
			 (Term.shiftn (Term.shiftvar T1) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst (Term.shiftvarn.commutes T1 n)
	        (\x:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       (Term.var vt1 Nat.0)  x)
	 (CCTypeCheck.var (Hyp n prfT0))))
    ;weak
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \M : Term \S:Term
     \prf2: CCTypeCheck Gamma M S
     \Hyp2: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma) 
	              (Term.shiftn M n) (Term.shiftn S n)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.shiftvar M) n)
			  (Term.shiftn (Term.shiftvar S) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.weak prf1 prf2))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.shiftvar M) n)
			 (Term.shiftn (Term.shiftvar S) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst2 (Term.shiftvarn.commutes M n)
		 (Term.shiftvarn.commutes S n)
	         (\x:Term \y:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       x y)
	 (CCTypeCheck.weak (Hyp1 n prfT0) (Hyp2 n prfT0))))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \vt2:VarType \S:Term
     \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n
     	    	          (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                 (Term.shiftn S n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.pi (Hyp1 n prfT0) (Hyp2 (Nat.s n) prfT0))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	    		T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                (Term.shiftn M n) (Term.shiftn S n)) ->
     \vt2:VarType
     \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn (Term.pi vt1 T1 S) n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.lam (Hyp1 (Nat.s n) prfT0) (Hyp2 n prfT0))
    ;app
    (\Gamma:VarList \M:Term \vt1:VarType \T1:Term \S:Term
     \prf1: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn (Term.pi vt1 T1 S) n)) ->
     \N:Term
     \prf2:CCTypeCheck Gamma N T1
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn N n) (Term.shiftn T1 n))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     I.rsubst (Term.subst.shift S N n)
	      (\x: Term -> CCTypeCheck (VarList.insertn n vt T0 Gamma)
	      	                       (Term.shiftn (Term.app M N) n) x)
     (CCTypeCheck.app (Hyp1 n prfT0) (Hyp2 n prfT0)))
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \prf1: CCTypeCheck Gamma M T
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn T n))
     \S:Term \step:ConvSymmStep T S
     \n:Nat 
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     (CCTypeCheck.conv (Hyp1 n prfT0) (ConvSymmStep.shiftn T S step n)))

Definition Subst.consshifti = Nat.iter Subst.consshift

Definition Subst.consshifti.shifti.Thesis = \sigma:Subst \t: Term ->
  n:Nat -> I (Term.substapp (Term.shiftn t n)
  	     	  	    (Subst.consshifti n sigma))
  	     (Term.shiftn (Term.substapp t (Subst.consshifti n sigma)) n)



Inductive CCSubstCheck : Subst -> VarList -> VarList -> U =
  start  : Gamma:VarList ->
           CCSubstCheck (Subst.offset Nat.0) Gamma Gamma,
  offset : Gamma:VarList ->
	   vt:VarType -> S:Term -> CCTypeCheck Gamma S (Term.univ vt) ->
           i:Nat -> Gamma':VarList ->
	   CCSubstCheck (Subst.offset i) Gamma Gamma' ->
           CCSubstCheck (Subst.offset (Nat.s i))
	   		(VarList.cons vt S Gamma) Gamma',
  cons   : Gamma:VarList -> vt:VarType -> t:Term -> sigma:Subst ->
  	   Gamma':VarList -> S:Term ->
	   CCTypeCheck Gamma t S ->
	   CCSubstCheck sigma Gamma Gamma' ->
           CCSubstCheck (Subst.cons t sigma) Gamma (VarList.cons vt S Gamma')


Definition Subst.consshifti.shifti = \sigma:Subst ->
  Term.rec (\t:Term -> Subst.consshifti.shifti.Thesis sigma t)
     (\vt:VarType
      \M:Term \HypM:Subst.consshifti.shifti.Thesis sigma M
      \N:Term \HypN:Subst.consshifti.shifti.Thesis sigma N
      \n:Nat ->
      I.cong2 (\M:Term\N:Term -> Term.lam vt M N)
        (HypM n) (HypN (Nat.s n)))
     (\vt:VarType
      \M:Term \HypM:Subst.consshifti.shifti.Thesis sigma M
      \N:Term \HypN:Subst.consshifti.shifti.Thesis sigma N
      \n:Nat ->
      I.cong2 (\M:Term\N:Term -> Term.pi vt M N)
        (HypM n) (HypN (Nat.s n)))
     (\M:Term \HypM:Subst.consshifti.shifti.Thesis sigma M
      \N:Term \HypN:Subst.consshifti.shifti.Thesis sigma N
      \n:Nat ->
      I.cong2 (\M:Term\N:Term -> Term.app M N) (HypM n) (HypN n))
;     (\vt:VarType \i:Nat \n:Nat ->
;      I.r (Subst.eval (Subst.consshifti n sigma) vt (Nat.shiftn n i)))
;     (\vt:VarType \n:Nat -> I.r (Term.univ vt))

Definition CCTypeCheck.subst.Thesis = \vt:VarType \T0:Term \N:Term
  \Gamma:VarList \M:Term \S:Term ->
  n:Nat -> Gamma':VarList -> I Gamma (VarList.insertn n vt T0 Gamma') ->
  CCTypeCheck (VarList.deleten n Gamma') N T0 ->
  CCTypeCheck Gamma' (Term.substapp M (Subst.consshifti n (Subst.unit N)))
                     (Term.substapp S (Subst.consshifti n (Subst.unit N)))

Definition VarList.isEmpty =
  VarList.rec (\_:VarList -> U) T (\_:VarType\_:Term\_:VarList\_:U -> F)

Definition VarList.notEmpty.insert =
  Nat.rec (\n:Nat -> vt:VarType -> T0:Term -> Gamma:VarList ->
  	   VarList.isEmpty (VarList.insertn n vt T0 Gamma) -> F)
    (\vt:VarType \T0:Term \Gamma:VarList \x:F -> x)
    (\n:Nat \Hyp:(vt:VarType -> T0:Term -> Gamma:VarList ->
  	   VarList.isEmpty (VarList.insertn n vt T0 Gamma) -> F)
     \vt:VarType \T0:Term ->
     VarList.rec (\Gamma:VarList ->
                  VarList.isEmpty (VarList.insertn (Nat.s n) vt T0 Gamma) -> F)
       (Hyp vt T0 VarList.nil)
       (\vt1:VarType \T1:Term \Gamma:VarList
        \_:(VarList.isEmpty (VarList.insertn (Nat.s n) vt T0 Gamma) -> F)
	\x:F -> x))

Definition CCTypeCheck.subst = \vt:VarType \T0:Term \N:Term ->
  Let Thesis = (\Gamma:VarList \M:Term \S:Term ->
     n:Nat -> Gamma': VarList ->
     I Gamma (VarList.insertn n vt T0 Gamma') ->
     CCTypeCheck (VarList.deleten n Gamma') N T0 ->
     CCTypeCheck Gamma' (Term.substapp M (Subst.consshifti n (Subst.unit N)))
                        (Term.substapp S (Subst.consshifti n (Subst.unit N))))
  ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term
                   \_:CCTypeCheck Gamma M S -> Thesis Gamma M S)
     ;ax
     (\n:Nat \Gamma':VarList
      \eq:I VarList.nil (VarList.insertn n vt T0 Gamma')
      \_:CCTypeCheck (VarList.deleten n Gamma') N T0 ->
      F.rec (\_:F -> CCTypeCheck Gamma' Term.* Term.[])
        (VarList.notEmpty.insert n vt T0 Gamma'
           (I.subst eq VarList.isEmpty T.tt)))
     ; var
     (\vt1:VarType \T1:Term \prf:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp:Thesis Gamma T1 (Term.univ vt1)
      Nat.rec (\n:Nat -> Gamma': VarList ->
     I VarList Gamma (VarList.insertn n vt T0 Gamma') ->
     CCTypeCheck (VarList.deleten n Gamma') N T0 ->
     CCTypeCheck Gamma' (Term.substapp (Term.var vt1 Nat.0) (Subst.consshifti n (Subst.unit N)))
                        (Term.substapp T1 (Subst.consshifti n (Subst.unit N))))
	  (\Gamma':VarList \_:I VarList Gamma (VarList.cons vt T0 Gamma') ->
	   \x:CCTypeCheck Gamma' N T0 ->
	   x)
	  (\n:Nat\_:(Gamma': VarList ->
     I VarList Gamma (VarList.insertn n vt T0 Gamma') ->
     CCTypeCheck (VarList.deleten n Gamma') N T0 ->
     CCTypeCheck Gamma' (Term.substapp (Term.var vt1 Nat.0) (Subst.consshifti n (Subst.unit N))))
	   \Gamma':VarList \_:I VarList Gamma (VarList.insertn (Nat.s n) vt T0 Gamma') ->
	   \x:CCTypeCheck (VarList.deleten (Nat.s n) Gamma') N T0 ->
	   Hyp
            
	   
      \n:Nat \Gamma':VarList
      \eq:I VarList VarList.nil (VarList.insertn n vt T0 Gamma')
      \_:CCTypeCheck (VarList.deleten n Gamma') N T0 ->
      F.rec (\_:F -> CCTypeCheck Gamma' Term.* Term.[])
        (VarList.notEmpty.insert n vt T0 Gamma'
           (I.subst eq
	     VarList.isEmpty
	     T.tt)))


  Subst.rec (\_:Subst -> U)
    (\Nat:n -> CCTypeCheck Gamma M S)
    (\vt0:VarType -> T0:Term -> sigma:Subst ->
       CCTypeCheck Gamma (Term.substapp (M 
      
                   (Term.substapp M (Subst.offset 0))
                   (Term.substapp S (Subst.offset n)))
    (
    VarList.rec (\_:VarList -> U) T
  	      (\vt:VarType \T0:Term \Gamma':VarList \_:U ->
	       N:Term ->
	       CCTypeCheck Gamma' N T0 ->
	       CCTypeCheck Gamma' (Term.subst M N) (Term.subst S N))
	      Gamma


Definition CCTypeCheck.substapp =
  CCSubstCheck.rec (\sigma:Subst \Gamma:VarList \Gamma':VarList
  		    \_:CCSubstCheck sigma Gamma Gamma' ->
                    M:Term -> S:Term -> CCTypeCheck Gamma' M S ->
	    CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma))
     (\Gamma:VarList \M:Term \S:Term \prf:CCTypeCheck Gamma M S ->
      prf)
     (\Gamma:VarList \vt0:VarType \S0:Term
      \prf0:CCTypeCheck Gamma S0 (Term.univ vt0) \i:Nat \Gamma':VarList
      \chk:CCSubstCheck (Subst.offset i) Gamma Gamma'
      \Hyp:(M:Term -> S:Term -> CCTypeCheck Gamma' M S ->
	    CCTypeCheck Gamma (Term.substapp M (Subst.offset i))
	                      (Term.substapp S (Subst.offset i)))
      \M:Term \S:Term \prf:CCTypeCheck Gamma' M S ->
      CCTypeCheck.weak prf0 (Hyp M S prf))

Definition Term.substapp.offset.0.Thesis = \t:Term -> i:Nat -> 
  I Term (Term.substapp t (Subst.consshifti i (Subst.offset Nat.0))) t
Definition Term.substapp.offset.0 =
  Term.rec (\t:Term -> Term.substapp.offset.0.Thesis t)
     (\vt:VarType
      \M:Term \HypM:Term.substapp.offset.0.Thesis M
      \N:Term \HypN:Term.substapp.offset.0.Thesis N
      \i:Nat ->
      I.cong2 Term Term Term (\M:Term\N:Term -> Term.lam vt M N)
        (Term.substapp M (Subst.consshifti i (Subst.offset Nat.0))) M
        (HypM i)
        (Term.substapp N (Subst.consshifti (Nat.s i) (Subst.offset Nat.0))) N
	(HypN (Nat.s i)))
     (\vt:VarType
      \M:Term \HypM:Term.substapp.offset.0.Thesis M
      \N:Term \HypN:Term.substapp.offset.0.Thesis N
      \i:Nat ->
      I.cong2 Term Term Term (\M:Term\N:Term -> Term.pi vt M N)
        (Term.substapp M (Subst.consshifti i (Subst.offset Nat.0))) M
        (HypM i)
        (Term.substapp N (Subst.consshifti (Nat.s i) (Subst.offset Nat.0))) N
	(HypN (Nat.s i)))
     (\M:Term \HypM:Term.substapp.offset.0.Thesis M
      \N:Term \HypN:Term.substapp.offset.0.Thesis N
      \i:Nat ->
      I.cong2 Term Term Term (\M:Term\N:Term -> Term.app M N)
        (Term.substapp M (Subst.consshifti i (Subst.offset Nat.0))) M
        (HypM i)
        (Term.substapp N (Subst.consshifti i (Subst.offset Nat.0))) N
	(HypN i))
     (\vt:VarType \n:Nat \i:Nat ->
      Nat.rec (\i:Nat -> n:Nat ->
               I Term
	       	 (Subst.eval (Subst.consshifti i (Subst.offset Nat.0)) vt n)
	         (Term.var vt n))
	(\n:Nat ->
	 I.cong Subst Term (\x:Subst -> Subst.evalhead vt x)
	   (Subst.drop n (Subst.offset Nat.0)) (Subst.offset n)
	   (I.subst (Nat.plus.zero n)
	      (\x:Nat -> I Subst (Subst.drop n (Subst.offset Nat.0))
	      	           (Subst.offset x))
              (Subst.drop.offset Nat.0 n)))
	(\i:Nat
	 \Hyp:(n:Nat -> I Term (Subst.eval (Subst.consshifti i
	 	     	  	      	     (Subst.offset Nat.0)) vt n)
	        	  (Term.var vt n)) ->
	 Nat.rec (\n:Nat -> m:Nat
	    I Term (Subst.eval (Nat.iter Subst Subst.shift m
	                       (Subst.consshifti (Nat.s i)
	 	     	       (Subst.offset Nat.0)) vt n))
	        	    (Term.var vt (Nat.plus m n)))
	    (\m:Nat -> I Term
	               (Subst.evalhead vt (Nat.iter Subst Subst.shift m
	                       (Subst.consshifti (Nat.s i)
	 	     	       (Subst.offset Nat.0))))
	    	       (Term.var vt (Nat.plus m Nat.0)))
	       (I.r Term (Term.var vt Nat.0))
	       (\m:Nat
	        \Hyp:I Term (Subst.evalhead vt (Nat.iter Subst Subst.shift m
	                        (Subst.consshifti (Nat.s i)
	 	     	        (Subst.offset Nat.0))))
	    	       (Term.var vt (Nat.plus m Nat.0))
	    (\n:Nat \_:I Term (Subst.eval (Subst.consshifti (Nat.s i)
	 	     	  	      	     (Subst.offset Nat.0)) vt n)
			      (Term.var vt n) ->
	     I.subst (Nat.iter.associative Subst.drop1 n
                         (Subst.consshifti (Nat.s i) (Subst.offset Nat.0)))
		 (\x: Subst -> I Term (Subst.evalhead vt x) (Term.var vt n))
	     (Hyp (Nat.s n)))))
     (\vt:VarType -> I.r Term (Term.univ vt))

      
      
Definition Term.subst.offes
Definition Term.substshift.shiftn.Thesis =
  \t:Term -> n:Nat -> sigma:Subst ->
     I Subst (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
     I Term (Term.shiftn (Term.substapp t sigma) n)
  	    (Term.substapp (Term.shiftn t (Nat.s n))
	    		   (Subst.substshiftn n sigma))


Definition CCTypeCheck.subst = \sigma:Subst \Gamma:VarList ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
  		   CCTypeCheck.subst.Thesis Gamma M S)
    T.tt ;ax
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf1: CCTypeCheck Gamma T0 (Term.univ vt)
     \Hyp: CCTypeCheck.subst.Thesis Gamma T0 (Term.univ vt)
     \N:Term
     \prf2: CCTypeCheck Gamma N T0 ->
     I.subst (Term.subst.shift0 T0 N)
        (\x:Term -> CCTypeCheck Gamma N x)
        prf2)
     
     \Hyp: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     Nat.rec (\n:Nat ->

     (\M:Term \S:Term
      \prf: CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma) ->
      prf)      
     (\vt:VarType \T:Term \vl:VarList
      \Hyp:(M:Term -> ....)
      \M:Term \S:Term
      \prf: CCTypeCheck Gamma
         (Term.substapp M (Subst.consshift (Subst.consshift.list sigma vl))
	 (Term.substapp S (Subst.consshift (Subst.consshift.list sigma vl))
      ->
      prf)      


Definition CCTypeCheck.substapp =
  CCSubstCheck.rec (\sigma:Subst \Gamma:VarList \Gamma':VarList
  		    \_:CCSubstCheck sigma Gamma Gamma' ->
                    M:Term -> S:Term -> CCTypeCheck Gamma' M S ->
	    CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma))
     (\Gamma:VarList \M:Term \S:Term \prf:CCTypeCheck Gamma M S ->
      prf)
     (\Gamma:VarList \vt0:VarType \S0:Term
      \prf0:CCTypeCheck Gamma S0 (Term.univ vt0) \i:Nat \Gamma':VarList
      \chk:CCSubstCheck (Subst.offset i) Gamma Gamma'
      \Hyp:(M:Term -> S:Term -> CCTypeCheck Gamma' M S ->
	    CCTypeCheck Gamma (Term.substapp M (Subst.offset i))
	                      (Term.substapp S (Subst.offset i)))
      \M:Term \S:Term \prf:CCTypeCheck Gamma' M S ->
      CCTypeCheck.weak prf0 (Hyp M S prf))

  CCTypeCheck.rec (\Gamma':VarList \M:Term \S:Term \t:CCTypeCheck Gamma' M S ->
	           sigma:Subst -> Gamma:VarList -> 
	           CCSubstCheck sigma Gamma Gamma' ->
	    CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma))
     ; ax
     (\sigma:Subst \Gamma:VarList \check:CCSubstCheck sigma Gamma VarList.nil ->
      CCSubstCheck.rec (\sigma:Subst \Gamma:VarList \Gamma':VarList
     		        \_:CCSubstCheck sigma Gamma Gamma' ->
			I VarList Gamma' VarList.nil ->
	    		CCTypeCheck Gamma Term.* Term.[])
       (\Gamma:VarList \eq:I VarList Gamma VarList.nil ->
        I.rsubst eq
	   (\x:VarList -> CCTypeCheck x Term.* Term.[])
           CCTypeCheck.ax)
       (\Gamma:VarList 
	\vt:VarType \S:Term  \prf:CCTypeCheck Gamma S (Term.univ vt)
        \i:Nat \Gamma':VarList \chk:CCSubstCheck (Subst.offset i) Gamma Gamma'
	\Hyp:(I VarList Gamma' VarList.nil -> CCTypeCheck Gamma Term.* Term.[])
	\eq:I VarList Gamma' VarList.nil ->
	CCTypeCheck.weak prf (Hyp eq))
       (\Gamma:VarList 
	\vt:VarType \t:Term \sigma:Subst \Gamma':VarList \S:Term
	\prf:CCTypeCheck Gamma t S
        \chk:CCSubstCheck sigma Gamma Gamma'
	\Hyp:(I VarList Gamma' VarList.nil -> CCTypeCheck Gamma Term.* Term.[])
	\eq:I VarList (VarList.cons vt S Gamma') VarList.nil ->
	I.rsubst eq
	  (\x:VarList ->
	   VarList.rec (\_:VarList -> U) T
	   	       (\vt:VarType\t:Term\tail:VarList\hyp:U ->
		        CCTypeCheck Gamma Term.* Term.[]) x)
	  T.tt)
       sigma Gamma VarList.nil check (I.r VarList VarList.nil))

     ; var
     (\Gamma':VarList \vt:VarType \T0:Term
      \prf:CCTypeCheck Gamma' T0 (Term.univ vt)
      \Hyp:(sigma:Subst -> Gamma:VarList -> 
	    CCSubstCheck sigma Gamma Gamma' ->
	    CCTypeCheck Gamma (Term.substapp T0 sigma)
	                      (Term.substapp (Term.univ vt) sigma))

      \sigma:Subst \Gamma:VarList
      \check:CCSubstCheck sigma Gamma (VarList.cons vt T0 Gamma') ->
      CCSubstCheck.rec (\sigma:Subst \Gamma:VarList \Gamma'':VarList
     		        \_:CCSubstCheck sigma Gamma Gamma'' ->
			I VarList Gamma'' (VarList.cons vt T0 Gamma') ->
	    		CCTypeCheck Gamma (Term.var vt Nat.0) T0)
       (\Gamma:VarList \eq:I VarList Gamma (VarList.cons vt T0 Gamma') ->
        I.rsubst eq
	   (\x:VarList -> CCTypeCheck x (Term.var vt Nat.0) T0)
           (CCTypeCheck.var prf))
       (\Gamma:VarList 
	\vt:VarType \S:Term  \prf:CCTypeCheck Gamma S (Term.univ vt)
        \i:Nat \Gamma'':VarList \chk:CCSubstCheck (Subst.offset i) Gamma Gamma''
	\Hyp:(I VarList Gamma'' (VarList.cons vt T0 Gamma') ->
	      CCTypeCheck Gamma (Term.var vt Nat.0 T0))
	\eq:I VarList Gamma'' (VarList.cons vt T0 Gamma') ->
	CCTypeCheck.weak prf (Hyp eq))
       (\Gamma:VarList 
	\vt:VarType \t:Term \sigma:Subst \Gamma':VarList \S:Term
	\prf:CCTypeCheck Gamma t S
        \chk:CCSubstCheck sigma Gamma Gamma'
	\Hyp:(I VarList Gamma' VarList.nil -> CCTypeCheck Gamma Term.* Term.[])
	\eq:I VarList (VarList.cons vt S Gamma') VarList.nil ->
	I.rsubst eq
	  (\x:VarList ->
	   VarList.rec (\_:VarList -> U) T
	   	       (\vt:VarType\t:Term\tail:VarList\hyp:U ->
		        CCTypeCheck Gamma Term.* Term.[]) x)
	  T.tt)
       sigma Gamma VarList.nil check (I.r VarList VarList.nil))


  Term.rec (\M:Term -> S:Term -> 
  	    Gamma':VarList ->
	    CCTypeCheck Gamma' M S
	    Gamma:VarList -> sigma:Subst ->
	    CCSubstCheck sigma Gamma Gamma' ->
	    CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma))
   ; lam
   (\vt:VarType \M:Term \HypM:(CCTypeCheck.substapp.Thesis M)
    \N:Term \HypM:(CCTypeCheck.substapp.Thesis M)
    \S:Term \Gamma':VarList \tc:CCTypeCheck Gamma' M S
    \Gamma:VarList \sigma:Subst
    \check:CCSubstCheck sigma Gamma Gamma' ->
    CCTypeCheck.lam Gamma vt (Term.substapp M sigma)
                    (Term.substapp N (Subst.consshift sigma))
		    
)

Assume CCTypeCheck.substapp :
  CCTypeCheck Gamma' M S ->
  CCSubstCheck sigma Gamma Gamma' ->
  CCTypeCheck Gamma (Term.substapp M sigma) (Term.substapp S sigma)
;Proof Idea: Induction over M

Inductive Class : U =
  []     : Class,
  kind   : Class,
  prop   : Class,
  constr : Class,
  obj    : Class

Definition Class.constr2prop =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.prop Class.prop Class.obj
Definition Class.prop2constr =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.constr Class.constr Class.obj
Definition Class.constrobj =
  VarType.rec (\_:VarType -> Class) Class.constr Class.obj
Definition Class.kindprop =
  VarType.rec (\_:VarType -> Class) Class.kind Class.prop
Definition Class.boxkind =
  VarType.rec (\_:VarType -> Class) Class.[] Class.kind


Definition Term.classify =
  Term.rec (\t:Term -> Class)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; lam
        Class.prop2constr Nc)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; pi
        Class.constr2prop Nc)
    (\M:Term \Mc:Class \N:Term \_:Class -> Mc)          ; app
    (\vt:VarType \n:Nat -> Class.constrobj vt)          ; var
    Class.boxkind                                       ; univ

Definition Term.shiftn.classify =
  Term.rec (\M:Term -> n:Nat ->
            I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I Class (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class Class Class.prop2constr
               (Term.classify (Term.shiftn N (Nat.s n)))
               (Term.classify N)
	       (Hyp (Nat.s n)))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I Class (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class Class Class.constr2prop
               (Term.classify (Term.shiftn N (Nat.s n)))
               (Term.classify N)
	       (Hyp (Nat.s n)))
    (\M:Term
     \Hyp:(n:Nat -> I Class (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \_:(n:Nat -> I Class (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> Hyp n)
    (\vt:VarType \i:Nat \n:Nat -> I.r Class (Class.constrobj vt))
    (\vt:VarType \n:Nat -> I.r Class (Class.boxkind vt))

Inductive TypedClass : Gamma:VarList -> S:Term -> Class -> U =
  kind  : CCTypeCheck Gamma S Term.[] -> TypedClass Gamma S Class.kind,
  prop  : CCTypeCheck Gamma S Term.*  -> TypedClass Gamma S Class.prop,
  constr: A:Term -> CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.[] -> TypedClass Gamma S Class.constr,
  obj   : A:Term -> CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.* -> TypedClass Gamma S Class.obj

Assume XXX : Gamma:VarList -> S:Term -> vt:VarType ->
     CCTypeCheck Gamma S (Term.univ vt) ->
     TypedClass Gamma S (Term.classify S) ->
     I Class (Class.constr2prop (Term.classify S)) (Class.kindprop vt)

Definition Term.classify.type.correct =
   CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \t:CCTypeCheck Gamma M S ->
                    TypedClass Gamma M (Term.classify M))
    ;ax
    (TypedClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf:CCTypeCheck Gamma T0 (Term.univ vt)
     \_:TypedClass Gamma T0 (Term.classify T0) ->
     VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term -> A:Term ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt (VarList.cons vt T0 Gamma) (Term.var vt Nat.0) (Term.shiftvar T0)
	(CCTypeCheck.var Gamma vt T0 prf)
	(CCTypeCheck.weak Gamma vt T0 prf T0 (Term.univ vt) prf))
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: TypedClass Gamma T0 (Term.classify T0) ->
     \M: Term -> \S:Term -> \prf2:CCTypeCheck Gamma M S ->
     I.rsubst (Term.shiftn.classify M Nat.0)
     	 (\x:Class -> TypedClass Gamma M (Term.classify M) ->
	 	   TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) x)
     (TypedClass.rec Gamma M
         (\class: Class \_:TypedClass Gamma M class ->
          TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  TypedClass.kind (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.[] prf3))
	 ; prop
	 (\prf3: CCTypeCheck Gamma M Term.* ->
	  TypedClass.prop (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.* prf3))
	 ; constr
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.[] ->
	  TypedClass.constr (VarList.cons vt T0 Gamma)
	  		    (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.[] prf4))
	 ; obj
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.* prf4))
	 (Term.classify M)))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \_: TypedClass Gamma T1 (Term.classify T1) ->
     \vt2: VarType -> \S:Term ->
     \prf2: CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp: TypedClass (VarList.cons vt1 T1 Gamma) S (Term.classify S) ->
     I.rsubst (XXX (VarList.cons vt1 T1 Gamma) S vt2 prf2 Hyp)
	       (\x:Class -> TypedClass Gamma (Term.pi vt1 T1 S) x)
     (VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term ->
		  CCTypeCheck Gamma M (Term.univ vt) ->
                  TypedClass Gamma M (Class.kindprop vt))
        TypedClass.kind
	TypedClass.prop
	vt2 Gamma (Term.pi vt1 T1 S)
	    (CCTypeCheck.pi Gamma vt1 T1 prf1 vt2 S prf2)))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \_: TypedClass (VarList.cons vt1 T1 Gamma) M (Term.classify M) ->
     \vt2: VarType ->
     \prf2: CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp: TypedClass Gamma (Term.pi vt1 T1 S)
     	   	      (Class.constr2prop (Term.classify S)) ->
     I.rsubst  (XXX2 Gamma S vt2 prf2 Hyp)
	       (\x:Class -> TypedClass Gamma (Term.lam vt1 T1 M) x)
     (VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term -> A:Term 
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.kindprop vt))
        TypedClass.constr
	TypedClass.obj
	vt2 Gamma (Term.lam vt1 T1 M)
	    (CCTypeCheck.lam Gamma vt1 T1 M S prf1 vt2 prf2)))

     I.rsubst (Term.shiftn.classify M Nat.0)
     	 (\x:Class -> TypedClass Gamma M (Term.classify M) ->
	 	   TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) x)
     \
     (TypedClass.rec Gamma M
         (\class: Class \_:TypedClass Gamma M class ->
          TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  TypedClass.kind (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.[] prf3))
	 ; prop
	 (\prf3: CCTypeCheck Gamma M Term.* ->
	  TypedClass.prop (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak Gamma vt T0 prf M Term.* prf3))
	 ; constr
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.[] ->
	  TypedClass.constr (VarList.cons vt T0 Gamma)
	  		    (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.[] prf4))
	 ; obj
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak Gamma vt T0 prf M A prf3)
	     (CCTypeCheck.weak Gamma vt T0 prf A Term.* prf4))
	 (Term.classify M)))

Definition Term.ispi = 
   Term.rec (\t:Term -> U)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> F)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> T)
      (\M:Term \_:U \N:Term \_:U -> F)
      (\vt:VarType \n:Nat -> F)
      (\vt:VarType -> F)
Definition Term.casepi = \C:(t:Term -> U1)
   \case:(vt:VarType -> T:Term -> S:Term -> C (Term.pi vt T S)) ->
   Term.rec (\t:Term -> Term.ispi t -> C t)
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.lam vt M N)))
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         \_:T -> case vt M N)
      (\M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.app M N)))
      (\vt:VarType \n:Nat -> F.rec (\_:F -> C (Term.var vt n)))
      (\vt:VarType -> F.rec (\_:F -> C (Term.univ vt)))

Inductive KindOrProp : Gamma:VarList -> S:Term -> U =
  kind: CCTypeCheck Gamma S Term.[] -> KindOrProp Gamma S,
  prop: CCTypeCheck Gamma S Term.*  -> KindOrProp Gamma S



Definition PiRangeCorrectType = \Gamma:VarList ->
  Term.casepi (\_:Term -> U)
              (\vt0:VarType \T0:Term \S0:Term ->
	         KindOrProp (VarList.cons vt0 T0 Gamma) S0)

Definition PiRangeCorrect = 
  CCTypeCheck.rec
     (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
      PiRangeCorrectType Gamma M)
    ;ax
    T.tt
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     T.tt)
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     Term.casepi (\M: Term -> S:Term -> CCTypeCheck Gamma M S ->
        PiRangeCorrectType Gamma M ->
        PiRangeCorrectType (VarList.cons vt T0 Gamma) (Term.shiftvar M))
        (\vt1:VarType \T1:Term \S1:Term
	 \S:Term \_:CCTypeCheck Gamma (Term.pi vt1 T1 S1) S ->
	 KindOrProp.rec (VarList.cons vt1 T1 Gamma) S1
	    (\_:KindOrProp (VarList.cons vt1 T1 Gamma) S1 ->
	     KindOrProp (VarList.cons vt1 (Term.shiftvar T1) (VarList.cons vt T0 Gamma)) (Term.shiftn S1 Nat.1))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.[] ->
	     KindOrProp.kind (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.* ->
	     KindOrProp.prop (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf)))
	(\M:Term \S:Term \_:CCTypeCheck Gamma M S
	 \_:PiRangeCorrectType Gamma M ->
	 T.tt))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Inductive TermClass : Gamma:VarList -> M:Term -> U =
  kind   : CCTypeCheck Gamma M Term.[] -> TermClass Gamma M,
  constr : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.[]
           -> TermClass Gamma M,
  obj    : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.*
           -> TermClass Gamma M
  
Definition Term.classify =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
  		   TermClass Gamma M)
    (TermClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList -> VarType.rec
        (\vt:VarType -> T:Term -> CCTypeCheck Gamma T (Term.univ vt) ->
	 TermClass Gamma T ->
	 TermClass (VarList.cons vt T Gamma) (Term.var vt Nat.0))
        (\T:Term \prf:CCTypeCheck Gamma T Term.[] \rec:TermClass Gamma T ->
	 TermClass.constr (VarList.cons VarType.[] T Gamma)
	 		  (Term.var VarType.[] Nat.0)
			  (Term.shiftvar T)
	                  (CCTypeCheck.var Gamma VarType.[] T prf)
	             (CCTypeCheck.weak Gamma VarType.[] T prf T Term.[] prf))
        (\T:Term \prf:CCTypeCheck Gamma T Term.* \rec:TermClass Gamma T ->
	 TermClass.obj (VarList.cons VarType.* T Gamma)
	 	       (Term.var VarType.* Nat.0)
		       (Term.shiftvar T)
	               (CCTypeCheck.var Gamma VarType.* T prf)
		       (CCTypeCheck.weak Gamma VarType.* T prf T Term.* prf)))
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prfvar: CCTypeCheck Gamma T (Term.univ vt) \_: TermClass Gamma T
     \M : Term \S:Term
     \_: CCTypeCheck Gamma M S ->
     TermClass.rec Gamma M (\_:TermClass Gamma M ->
                   TermClass (VarList.cons vt T Gamma) (Term.shiftvar M))
     	;kind
        (\prf1:CCTypeCheck Gamma M Term.[] ->
	 TermClass.kind (VarList.cons vt T Gamma) (Term.shiftvar M)
	                (CCTypeCheck.weak Gamma vt T prfvar
					  M Term.[] prf1))
     	;constr
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.[] ->
	 TermClass.constr (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.[] prf2))
     	;obj
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.* ->
	 TermClass.obj (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.* prf2)))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \prf1:CCTypeCheck Gamma T (Term.univ vt) \rec:TermClass Gamma T ->
     VarType.rec (\vt2:VarType -> S:Term ->
     		  CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
		  TermClass (VarList.cons vt T Gamma) S ->
		  TermClass Gamma (Term.pi vt T S))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.[]
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.kind Gamma (Term.pi vt T S)
	 		(CCTypeCheck.pi Gamma vt T prf1 VarType.[] S prf2))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.*
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.constr Gamma (Term.pi vt T S) Term.*
	 		  (CCTypeCheck.pi Gamma vt T prf1 VarType.* S prf2)
			  (CCTypeCheck.ax2 (CCTypeCheck.gammatc Gamma T
			  		                 (Term.univ vt) prf1))))
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \prf1:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:TermClass (VarList.cons vt T Gamma) M ->
     VarType.rec (\vt2:VarType -> 
     		  CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
		  TermClass Gamma (Term.pi vt T S) ->
		  TermClass Gamma (Term.lam vt T M))
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.[]
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.constr Gamma (Term.lam vt T M) (Term.pi vt T S)
	 		  (CCTypeCheck.lam Gamma vt T M S prf1 VarType.[] prf2)
			  prf2)
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.*
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.obj Gamma (Term.lam vt T M) (Term.pi vt T S)
	 	       (CCTypeCheck.lam Gamma vt T M S prf1 VarType.* prf2)
		       prf2))
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \prf1:CCTypeCheck Gamma M (Term.pi vt T S) \_:TermClass Gamma M
     \N:Term \prf2:CCTypeCheck Gamma N T \_:TermClass Gamma N ->
     Ter
     TermClass
     TermClass Gamma (Term.app M N)
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:TermClass Gamma M
     \S:Term \_:ConvSymmStep T S -> rec)
    

