Intuitionistic Type Theory
==========================

This directory contains an implementation of Martin-LÃ¶f style 
Intuitionistic Type Theory (ITT).

Compilation
-----------

Run ant in the main folder with

    ant create_itt_jar


Usage
-----

To run ITT from command line you need the standalone jar.  Run it as

    java -jar itt.jar DependentTypeCheck/examples/numbers.itt


Syntax
------

ITT only supports a very minimal syntax.  The expressions are
generated by this syntax

    expr := expr expr         ;; function application
            \id:expr -> expr  ;; lambda abstraction
            id:expr -> expr   ;; dependent function type
            id                ;; previously defined expression/variable

Function application binds to the left and stronger than lambda and
dependent function type, which bind to the right.

The overall syntax of a file is:

     file ::= decl*
     decl ::= Inductive id : expr = id : expr, ..., id : expr
            | Definition id = expr
            | TypeCheck expr : expr
            | Check expr = expr
            | Assume id : expr
            | Evaluate expr
            | EvaluateType expr

Note that the `Assume` command can introduce unsoundness.  Every expression
has a type.  There is one predefined expression `U` that has type `U` and
stands for the universe of all types.  New types can be created with the
keyword `Inductive`.  An inductive declaration looks like this:

    Inductive Nat : U =
        0 : Nat,
        s : Nat -> Nat

This declaration defines `Nat : U`, `Nat.0 : Nat`, `Nat.s : Nat -> Nat`, and
additionally a recursion operator `Nat.rec`.  The latter has the type

    TypeCheck Nat.rec : C:(Nat -> U) -> (C Nat.0) -> 
                        (n:Nat -> rec:C n -> C (Nat.s n)) ->
                        n:Nat -> C n

This type can be used to define recursive operations or prove theorems (if `C`
is a proposition).

There are some restriction on the types used in inductive definitions.
First the declared type must be a function returning `U` (or just `U`
without parameters).  The declared constructors must return an element
from the type.  If they use a parameter of the type, all constructors
must use it in every occurence of the type.  Finally the type may only
occur as a return value, as a parameter, or as the return value of a
functional parameter.  You cannot create mutual recursive types.

There is a builtin evaluation that is used when type-checking.  It
does beta-rewriting of lambda expressions and applies recursion
operators as far as possible.  Definitions are immediately expanded.
