Definition Prop = U
Inductive T : Prop = tt:T
Inductive F : Prop =

Inductive * : A:U -> B:U -> U =
  p:A->B-> * A B
Definition *.1 = \A:U \B:U -> *.rec A B (\_:* A B -> A) (\a:A \_:B -> a)
Definition *.2 = \A:U \B:U -> *.rec A B (\_:* A B -> B) (\_:A \b:B -> b)

Inductive + : A:U -> B:U -> U =
  1: A -> + A B,
  2: B -> + A B
Definition +.case = \A:U\B:U\C:U \1:(A -> C) \2:(B -> C) ->
  +.rec A B (\_:+ A B -> C) 1 2

Inductive Sigma : A:U -> B:(A->U) -> U =
  p:a:A->b:(B a)-> Sigma A B
Definition Sigma.1 = \A:U \B:(A->U) ->
  Sigma.rec A B (\_:Sigma A B -> A) (\a:A \_:B a -> a)
Definition Sigma.2 = \A:U \B:(A->U) ->
  Sigma.rec A B (\p:Sigma A B -> B (Sigma.1 A B p)) (\a:A \b:B a -> b)

Inductive I : {A:U} -> a:A -> b:A -> U =
  r : I a a

Definition I.subst = {\A:U} {\a:A} {\b:A} \eq:I a b \C:(A -> U) ->
    I.rec a (\x:A \_:I a x -> C a -> C x)
      (\z:C a -> z) b eq
TypeCheck I.subst :
  {A:U} -> {a:A} -> {b:A} -> I a b -> C:(A -> U) -> C a -> C b
Definition I.symm = {\A:U} {\a:A} {\b:A} \eq:I a b ->
  I.subst eq (\x:A -> I x a) (I.r a)
Definition I.trans = {\A:U} {\a:A} {\b:A} \eq1:I a b {\c:A} \eq2:I b c ->
  I.subst eq2 (\x:A -> I a x) eq1
Definition I.subst2 = {\A:U} {\a1:A} {\a2:A} \eq1:I a1 a2
	              {\B:U} {\b1:B} {\b2:B} \eq2:I b1 b2
		      \C:(A -> B -> U) ->
  I.subst eq2 (\b:B -> C a1 b1 -> C a2 b)
    (I.subst eq1 (\a:A -> C a b1))
TypeCheck I.subst2 :
  {A:U} -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {B:U} -> {b1:B} -> {b2:B} -> I b1 b2 -> C:(A -> B -> U) -> C a1 b1 -> C a2 b2
Definition I.rsubst = {\A:U} {\b:A} {\a:A} \eq:I a b \C:(A -> U) ->
    I.subst (I.symm eq) C
Definition I.cong = {\A:U} {\B:U}
  \c:(A -> B) {\a:A} {\b:A} \eq: I a b ->
    I.subst eq (\x:A -> I (c a) (c x)) (I.r (c a))
TypeCheck I.cong :
  A:U -> B:U -> c:(A -> B) -> {a:A} -> {b:A} -> I a b -> I (c a) (c b)
Definition I.cong2 = {\A:U} {\B:U} {\C:U} \f:(A->B->C)
  {\a1:A} {\a2:A} \eq1: I a1 a2 {\b1:B}{\b2:B} \eq2: I b1 b2 ->
  I.subst eq1 (\x:A -> I (f a1 b1) (f x b2)) (I.cong (f a1) eq2)
TypeCheck I.cong2 :
  {A:U} -> {B:U} -> {C:U} -> f:(A -> B -> C) -> {a1:A} -> {a2:A} -> I a1 a2 ->
  {b1:B} -> {b2:B} -> I b1 b2 -> I (f a1 b1) (f a2 b2)

Inductive Bool : U = tt:Bool, ff:Bool

;===========================================
;  Natural Numbers
;===========================================

Inductive Nat : U =
  0 : Nat,
  s : Nat -> Nat
Definition Nat.1 = Nat.s Nat.0

Definition Nat.plus = Nat.rec (\_:Nat -> Nat -> Nat)
    (\b:Nat -> b) (\a:Nat \rec:(Nat->Nat) \b:Nat -> Nat.s (rec b))

Definition Nat.plus.zero =
    Nat.rec (\a:Nat -> I (Nat.plus a Nat.0) a)
       (I.r Nat.0)
       (\a:Nat \Hyp:I (Nat.plus a Nat.0) a -> I.cong Nat.s Hyp)
Definition Nat.s.plus.commutes = \a:Nat \b:Nat ->
    Nat.rec (\a:Nat -> I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)))
       (I.r (Nat.s b))
       (\a:Nat \Hyp: I (Nat.s (Nat.plus a b)) (Nat.plus a (Nat.s b)) ->
        I.subst Hyp
	   (\x:Nat -> I (Nat.s (Nat.s (Nat.plus a b))) (Nat.s x))
	   (I.r (Nat.s (Nat.s (Nat.plus a b)))))
       a

Definition Nat.plus.commutes = \a:Nat ->
    Nat.rec (\b:Nat -> I (Nat.plus a b) (Nat.plus b a))
       (Nat.plus.zero a)
       (\b:Nat \Hyp:I (Nat.plus a b) (Nat.plus b a) ->
        I.subst Hyp
	        (\x:Nat -> I (Nat.plus a (Nat.s b)) (Nat.s x))
		(I.symm (Nat.s.plus.commutes a b)))

Definition Nat.iter = {\A:U} \f:(A->A) ->
  Nat.rec (\n:Nat -> A -> A) (\a:A -> a) (\_:Nat \rec:(A->A) \a:A -> f (rec a))
Definition Nat.iter.associative = {\A:U} \f:(A->A) \n:Nat \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)))
    (I.r (f a))
    (\n:Nat \Hyp:I (Nat.iter f (Nat.s n) a) (Nat.iter f n (f a)) ->
     I.cong f Hyp)
    n
Definition Nat.iter.plus = {\A:U} \f:(A->A) \m:Nat \n:Nat \a:A ->
  Nat.rec (\m:Nat -> I (Nat.iter f m (Nat.iter f n a))
                       (Nat.iter f (Nat.plus m n) a))
    (I.r (Nat.iter f n a))
    (\m:Nat
     \eq:I (Nat.iter f m (Nat.iter f n a)) (Nat.iter f (Nat.plus m n) a) ->
     I.cong f eq)
    m

Definition Nat.iter.g.commutes = \A:U \f:(A->A) \g:(A->A)
  \fgcommutes:(a:A -> I (f (g a)) (g (f a))) \a:A ->
  Nat.rec (\n:Nat -> I (Nat.iter f n (g a)) (g (Nat.iter f n a)))
    (I.r (g a))
    (\n:Nat\Hyp:I (Nat.iter f n (g a)) (g (Nat.iter f n a)) ->
     I.subst (fgcommutes (Nat.iter f n a))
        (\x:A -> I (Nat.iter f (Nat.s n) (g a)) x)
        (I.cong f Hyp))

Inductive Test : b:Bool -> U =
  tt : Test Bool.tt
Definition Test.false = \test:Test Bool.ff \C:U ->
  Test.rec (\b:Bool \_:Test b -> Bool.rec (\_:Bool->U) T C b) (T.tt) Bool.ff test
TypeCheck Test.false : (Test Bool.ff -> C:U -> C)

;===========================================
;  Terms
;===========================================

Inductive VarType : U = []:VarType, *:VarType

Inductive Term : U =
  lam   : VarType -> Term -> Term -> Term,
  pi    : VarType -> Term -> Term -> Term,
  app   : Term -> Term -> Term,
  var   : VarType -> Nat -> Term,
  univ  : VarType -> Term

Definition Term.[] = Term.univ VarType.[]
Definition Term.*  = Term.univ VarType.*

;===========================================
;  variable shifting
;===========================================

; increment m by one, if m greater equal n.
Definition Nat.shiftn =
  Nat.rec (\n:Nat -> m:Nat -> Nat)
     Nat.s
     (\_:Nat \shiftn1:(Nat -> Nat) ->
       Nat.rec (\m:Nat -> Nat) Nat.0
	  (\m1:Nat \_:Nat -> Nat.s (shiftn1 m1)))

Definition Nat.shiftn.commutes.Thesis = \i:Nat -> \n:Nat -> \m:Nat ->
    I (Nat.shiftn n (Nat.shiftn (Nat.plus m n) i))
          (Nat.shiftn (Nat.s (Nat.plus m n)) (Nat.shiftn n i))
 
Definition Nat.shiftn.commutes =
   Nat.rec (\n:Nat -> m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i n m)
     (Nat.rec (\m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 m)
        (\i:Nat -> I.r (Nat.s (Nat.s i)))
	(\m:Nat \HypM: (i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 m) ->
	 Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i Nat.0 (Nat.s m))
	   (I.r (Nat.s Nat.0))
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i Nat.0 (Nat.s m) ->
	    I.r (Nat.s (Nat.s (Nat.shiftn (Nat.plus m Nat.0) i))))))
     (\n:Nat \HypN: (m:Nat ->i:Nat -> Nat.shiftn.commutes.Thesis i n m) ->
      Nat.rec (\m:Nat -> i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) m)
        (Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) Nat.0)
	   (I.r Nat.0)
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i (Nat.s n) Nat.0 ->
	    I.cong Nat.s (HypN Nat.0 i)))
        (\m:Nat \HypM: (i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) m) ->
	 Nat.rec (\i:Nat -> Nat.shiftn.commutes.Thesis i (Nat.s n) (Nat.s m))
	   (I.r Nat.0)
	   (\i:Nat \HypI: Nat.shiftn.commutes.Thesis i (Nat.s n) (Nat.s m) ->
	    I.subst (Nat.s.plus.commutes m n)
		    (\x:Nat -> I (Nat.s (Nat.shiftn n (Nat.shiftn x i)))
		               (Nat.s (Nat.shiftn (Nat.s x) (Nat.shiftn n i))))
	    (I.cong Nat.s (HypN (Nat.s m) i)))))

Definition Nat.plus.shiftn.lemma = \i:Nat \n:Nat ->
  I.subst (Nat.plus.commutes n i)
          (\x:Nat -> I (Nat.shiftn n x) (Nat.plus (Nat.shiftn Nat.0 i) n))
  (I.subst (Nat.plus.commutes n (Nat.shiftn Nat.0 i))
           (\x:Nat -> I (Nat.shiftn n (Nat.plus n i)) x)
    (Nat.rec (\n:Nat -> I (Nat.shiftn n (Nat.plus n i))
                              (Nat.plus n (Nat.shiftn Nat.0 i)))
	  (I.r (Nat.s i))
	  (\n:Nat \Hyp:I (Nat.shiftn n (Nat.plus n i))
			 (Nat.plus n (Nat.shiftn Nat.0 i)) ->
	   I.cong Nat.s Hyp)
	  n))

; Increment all variables >= n by one.
Definition Term.shiftn =
  Term.rec (\_:Term -> n:Nat -> Term)
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.lam vt (rt1 n) (rt2 (Nat.s n)))
    (\vt:VarType \_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.pi vt (rt1 n) (rt2 (Nat.s n)))
    (\_: Term \rt1:(Nat->Term) \_:Term \rt2:(Nat->Term) \n:Nat ->
       Term.app (rt1 n) (rt2 n))
    (\vt:VarType \i: Nat \n:Nat -> Term.var vt (Nat.shiftn n i))
    (\vt:VarType \n: Nat -> Term.univ vt)
Definition Term.shiftvar = \term:Term ->
    Term.shiftn term Nat.0

Definition Term.shiftn.commutes.Thesis = \T:Term -> n:Nat -> m:Nat ->
    I (Term.shiftn (Term.shiftn T (Nat.plus m n)) n)
      (Term.shiftn (Term.shiftn T n) (Nat.s (Nat.plus m n)))

Definition Term.shiftn.commutes =
   Term.rec (\T:Term -> Term.shiftn.commutes.Thesis T)
      (\vt:VarType
       \S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 (\x:Term \y:Term -> Term.lam vt x y)
	   (HypS n m)
	   (I.rsubst (Nat.s.plus.commutes m n)
		(\x:Nat -> I
                 (Term.shiftn (Term.shiftn M x) (Nat.s n))
	         (Term.shiftn (Term.shiftn M (Nat.s n)) (Nat.s x)))
	        (HypM (Nat.s n) m)))
      (\vt:VarType
       \S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 (\x:Term \y:Term -> Term.pi vt x y)
	   (HypS n m)
	   (I.rsubst (Nat.s.plus.commutes m n)
		(\x:Nat -> I
                 (Term.shiftn (Term.shiftn M x) (Nat.s n))
	         (Term.shiftn (Term.shiftn M (Nat.s n)) (Nat.s x)))
	        (HypM (Nat.s n) m)))
      (\S:Term \HypS:Term.shiftn.commutes.Thesis S
       \M:Term \HypM:Term.shiftn.commutes.Thesis M
       \n:Nat \m:Nat ->
       I.cong2 (\x:Term \y:Term -> Term.app x y) (HypS n m) (HypM n m))
     (\vt:VarType \i:Nat \n:Nat \m:Nat ->
      I.cong (\i:Nat -> Term.var vt i)
             (Nat.shiftn.commutes n m i))
     (\vt:VarType \n:Nat \m:Nat -> I.r (Term.univ vt))
TypeCheck Term.shiftn.commutes : T:Term -> Term.shiftn.commutes.Thesis T
Definition Term.shiftvarn.commutes  = \T:Term \n:Nat ->
     I.subst  (Nat.plus.zero n)
	      (\x:Nat -> I (Term.shiftvar (Term.shiftn T x))
	                   (Term.shiftn (Term.shiftvar T) (Nat.s x)))
	      (Term.shiftn.commutes T Nat.0 n)
TypeCheck Term.shiftvarn.commutes : T:Term -> n:Nat ->
     I (Term.shiftvar (Term.shiftn T n))
       (Term.shiftn (Term.shiftvar T) (Nat.s n))

;===========================================
;  Substitutions
;===========================================

Inductive Subst : U =
   offset : Nat -> Subst,
   cons   : Term -> Subst -> Subst,
   consn  : Nat -> Subst -> Subst

Definition Subst.shift =
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset (Nat.s i))
    (\t:Term \_:Subst \sigmashift:Subst ->
     Subst.cons (Term.shiftvar t) sigmashift)
    (\i:Nat \_:Subst \sigmashift:Subst ->
     Subst.consn (Nat.s i) sigmashift)
Definition Subst.consshift = \sigma:Subst ->
  Subst.consn Nat.0 (Subst.shift sigma)
Definition Subst.len =
  Subst.rec (\_:Subst -> Nat)
    (\i:Nat -> Nat.0)
    (\_:Term \_:Subst \r:Nat -> Nat.s r)
    (\_:Nat \_:Subst \r:Nat -> Nat.s r)
Definition Subst.drop1 =
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset (Nat.s i))
    (\t:Term \sigma:Subst \_:Subst -> sigma)
    (\n:Nat \sigma:Subst \_:Subst -> sigma)
Definition Subst.drop = Nat.iter Subst.drop1
Definition Subst.evalhead = \vt:VarType ->
  Subst.rec (\tau:Subst -> Term)
    (\i:Nat -> Term.var vt i)
    (\t:Term \_:Subst \_:Term -> t)
    (\n:Nat \_:Subst \_:Term -> Term.var vt n)
Definition Subst.eval = \sigma:Subst \vt:VarType \n:Nat ->
  Subst.evalhead vt (Subst.drop n sigma)

Definition Term.substapp =
  Term.rec (\_:Term -> Subst -> Term)
    (\vt:VarType \_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst -> Term)
     \subst:Subst ->
     Term.lam vt (r1 subst) (r2 (Subst.consshift subst)))
    (\vt:VarType \_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst->Term)
     \subst:Subst ->
     Term.pi vt (r1 subst) (r2 (Subst.consshift subst)))
    (\_: Term \r1:(Subst->Term)
     \_:Term \r2:(Subst->Term)
     \subst:Subst -> Term.app (r1 subst) (r2 subst))
    (\vt:VarType \n:Nat \subst:Subst -> Subst.eval subst vt n)
    (\vt:VarType \subst:Subst -> Term.univ vt)

Definition Subst.unit = \t:Term -> Subst.cons t (Subst.offset Nat.0)
Definition Term.subst = \term:Term \subst:Term ->
    Term.substapp term (Subst.unit subst)

Definition Subst.isEmpty =
  Subst.rec (\_:Subst -> U)
     (\_:Nat -> T) (\_:Term\_:Subst\_:U -> F) (\_:Nat\_:Subst\_:U -> F)

Definition Subst.substshiftn = \n:Nat ->
  Subst.rec (\sigma:Subst -> Subst)
    (\i:Nat -> Subst.offset i)
    (\t:Term \sigma:Subst \recurse:Subst ->
     Subst.cons (Term.shiftn t n) recurse)
    (\i:Nat \sigma:Subst \recurse:Subst ->
     Subst.consn (Nat.shiftn n i) recurse)

Definition Subst.shift.substshiftn.commutes = \n:Nat ->
  Subst.rec (\sigma:Subst ->
     I (Subst.shift (Subst.substshiftn n sigma))
       (Subst.substshiftn (Nat.s n) (Subst.shift sigma)))
    (\i:Nat -> I.r (Subst.offset (Nat.s i)))
    (\t:Term \sigma:Subst
     \Hyp: I (Subst.shift (Subst.substshiftn n sigma))
             (Subst.substshiftn (Nat.s n) (Subst.shift sigma)) ->
     I.cong2 (\t:Term \sigma:Subst -> Subst.cons t sigma)
	(Term.shiftvarn.commutes t n) Hyp)
    (\i:Nat \sigma:Subst
     \Hyp: I (Subst.shift (Subst.substshiftn n sigma))
             (Subst.substshiftn (Nat.s n) (Subst.shift sigma)) ->
     I.cong (\sigma:Subst -> Subst.consn (Nat.s (Nat.shiftn n i)) sigma)
	    Hyp)
	
Definition Subst.drop1.substshiftn.commutes = \n:Nat ->
  Subst.rec (\sigma:Subst ->
             I (Subst.drop1 (Subst.substshiftn n sigma))
	       (Subst.substshiftn n (Subst.drop1 sigma)))
    (\i:Nat -> I.r (Subst.offset (Nat.s i)))
    (\t:Term \sigma:Subst
     \_:     I (Subst.drop1 (Subst.substshiftn n sigma))
	       (Subst.substshiftn n (Subst.drop1 sigma)) ->
     I.r (Subst.substshiftn n sigma))
    (\i:Nat \sigma:Subst
     \_:     I (Subst.drop1 (Subst.substshiftn n sigma))
	       (Subst.substshiftn n (Subst.drop1 sigma)) ->
     I.r (Subst.substshiftn n sigma))
		     
Definition Subst.substshift.consshift.Claim = 
  \subst:Subst -> n:Nat ->
     I (Subst.consshift (Subst.substshiftn n subst))
       (Subst.substshiftn (Nat.s n) (Subst.consshift subst))
Definition Subst.substshift.consshift.Lemma = \subst:Subst ->
  \n:Nat ->
  I.cong (\sigma:Subst -> Subst.consn Nat.0 sigma)
     (Subst.shift.substshiftn.commutes n subst)

TypeCheck Subst.substshift.consshift.Lemma :
  sigma:Subst -> Subst.substshift.consshift.Claim sigma

Definition Subst.drop.offset = \n:Nat ->
  Nat.rec (\i:Nat -> I (Subst.drop i (Subst.offset n))
                       (Subst.offset (Nat.plus i n)))
    (I.r (Subst.offset n))
    (\i:Nat \Hyp:I (Subst.drop i (Subst.offset n))
	           (Subst.offset (Nat.plus i n)) ->
     I.cong Subst.drop1 Hyp)
            

Definition Subst.evalshift.offsetcomp = \m:Nat \offset:Nat \n:Nat ->
   I.rsubst (Subst.drop.offset offset m)
	   (\x: Subst -> I x (Subst.offset n) ->
	                 I (Nat.plus m offset) n)
    (\Hyp: I (Subst.offset (Nat.plus m offset))
             (Subst.offset n)  ->
     I.cong (Subst.rec (\_:Subst -> Nat) (\x:Nat -> x)
	               (\_:Term \_:Subst\_:Nat -> Nat.0)
	               (\_:Nat \_:Subst\_:Nat -> Nat.0)) Hyp)
	    

Definition Subst.evalshift.help = \m:Nat \n:Nat ->
   I.subst (Nat.plus.commutes m (Nat.s n))
	   (\x:Nat -> I (Nat.shiftn x m) m)
	   (Nat.rec (\m:Nat -> I (Nat.shiftn (Nat.plus m (Nat.s n)) m) m)
	      (I.r Nat.0)
	      (\m:Nat \Hyp:I (Nat.shiftn (Nat.plus m (Nat.s n)) m) m ->
	       I.cong Nat.s Hyp)
	      m)



Definition Subst.evalshift.claim = \n:Nat \vt:VarType ->
  \i:Nat -> \m:Nat -> sigma:Subst ->
  I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
  I (Term.shiftn (Subst.eval sigma vt i) n)
    (Subst.eval (Subst.substshiftn n sigma) vt (Nat.shiftn (Nat.s m) i))

Definition Subst.evalshift.lemma = \vt:VarType ->
   Nat.rec (\i:Nat -> (m:Nat -> n:Nat -> Subst.evalshift.claim n vt i m))
    (\m:Nat \n:Nat ->
     (Subst.rec (\sigma:Subst ->
                 eq:I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
     		 I (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     		   (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
        (\offset:Nat
	 \eq : I (Subst.drop (Nat.s m) (Subst.offset offset))
	       (Subst.offset n) ->
	 ; argue with eq that m+1+offset = n
         I.cong (\x:Nat -> Term.var vt x)
  	    (I.subst
	       (Subst.evalshift.offsetcomp (Nat.s m) offset n eq)
	       (\x:Nat -> I (Nat.shiftn x offset) offset)
	       (Subst.evalshift.help offset m)))
	(\t:Term \sigma:Subst
	 \_:(I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
	     I (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     	       (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
	 \_:I (Subst.drop (Nat.s m) (Subst.cons t sigma))
	      (Subst.offset n) ->
	 I.r (Term.shiftn t n))
	(\i:Nat \sigma:Subst
	 \_:(I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
	     I (Term.shiftn (Subst.eval sigma vt Nat.0) n)
     	       (Subst.eval (Subst.substshiftn n sigma) vt Nat.0))
	 \_:I (Subst.drop (Nat.s m) (Subst.consn i sigma))
	      (Subst.offset n) ->
	 I.r (Term.var vt (Nat.shiftn n i)))))
    (\i:Nat \Hyp:(m:Nat -> n:Nat -> Subst.evalshift.claim n vt i m)
     \m:Nat \n:Nat \sigma:Subst
     \eq:I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
     I.rsubst (I.subst (Subst.drop1.substshiftn.commutes n sigma)
		       (\x: Subst -> I
              (Subst.drop (Nat.s (Nat.shiftn m i)) (Subst.substshiftn n sigma))
              (Subst.drop (Nat.shiftn m i) x))
		       (Nat.iter.associative Subst.drop1
		       			     (Nat.shiftn m i)
					     (Subst.substshiftn n sigma)))
	      (\x:Subst ->
	       I (Term.shiftn (Subst.eval sigma vt (Nat.s i)) n)
                 (Subst.evalhead vt x))
     (I.rsubst (Nat.iter.associative Subst.drop1 i sigma)
	      (\x:Subst -> I (Term.shiftn (Subst.evalhead vt x) n)
      (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt (Nat.shiftn m i)))
     (Nat.rec (\m:Nat ->
               eq:I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
               I (Term.shiftn (Subst.eval (Subst.drop1 sigma) vt i) n)
                 (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt
		      		  (Nat.shiftn m i)))
       (\eq:I (Subst.drop1 sigma) (Subst.offset n) ->
	I.rsubst eq
	   (\x:Subst -> I (Term.shiftn (Subst.eval x vt i) n)
               (Subst.eval (Subst.substshiftn n x) vt (Nat.shiftn Nat.0 i)))
	(I.rsubst (Subst.drop.offset n i)
		 (\x:Subst -> I (Term.shiftn (Subst.evalhead vt x) n)
               (Subst.eval (Subst.offset n) vt (Nat.shiftn (Nat.0) i)))
	(I.rsubst (Subst.drop.offset n (Nat.shiftn (Nat.0) i))
		 (\x:Subst -> I (Term.shiftn (Term.var vt (Nat.plus i n)) n)
                                (Subst.evalhead vt x))

		 (I.cong (\x:Nat -> Term.var vt x)
	                (Nat.plus.shiftn.lemma i n)))))
       (\m:Nat \_:(I (Subst.drop (Nat.s m) sigma) (Subst.offset n) ->
               I (Term.shiftn (Subst.eval (Subst.drop1 sigma) vt i) n)
                 (Subst.eval (Subst.substshiftn n (Subst.drop1 sigma)) vt
		      		  (Nat.shiftn m i)))
        \eq:I (Subst.drop (Nat.s (Nat.s m)) sigma) (Subst.offset n) ->
        (Hyp m n (Subst.drop1 sigma)
	  (I.subst (Nat.iter.associative Subst.drop1 (Nat.s m) sigma)
		   (\x:Subst -> I x (Subst.offset n))
		   eq)))
       m eq)))

Definition Term.substshift.shiftn.Thesis =
  \t:Term -> n:Nat -> sigma:Subst ->
     I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
     I (Term.shiftn (Term.substapp t sigma) n)
       (Term.substapp (Term.shiftn t (Nat.s n))
		      (Subst.substshiftn n sigma))

Definition Subst.drop1.shift.commutes =
  Subst.rec (\sigma:Subst ->
             I (Subst.drop1 (Subst.shift sigma))
	       (Subst.shift (Subst.drop1 sigma)))
    (\i:Nat -> I.r (Subst.offset (Nat.s (Nat.s i))))
    (\t:Term \sigma:Subst
     \_:     I (Subst.drop1 (Subst.shift sigma))
	       (Subst.shift (Subst.drop1 sigma)) ->
     I.r (Subst.shift sigma))
    (\i:Nat \sigma:Subst
     \_:     I (Subst.drop1 (Subst.shift sigma))
	       (Subst.shift (Subst.drop1 sigma)) ->
     I.r (Subst.shift sigma))

Definition Subst.drop.shift.commutes =
  Nat.iter.g.commutes Subst Subst.drop1 Subst.shift Subst.drop1.shift.commutes

Definition Term.substshift.shiftn.shifteq = \n:Nat \vt:VarType \sigma:Subst ->
  (I.rsubst (Nat.iter.associative Subst.drop1 (Nat.s n)
	                          (Subst.consshift sigma))
   (\x:Subst ->
      I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
      I x (Subst.offset (Nat.s n)))
   (\eq:I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
    I.rsubst (Subst.drop.shift.commutes sigma (Nat.s n))
	     (\x:Subst -> I x (Subst.offset (Nat.s n)))
    (I.cong Subst.shift eq)))

Definition Term.substshift.shiftn =
  Term.rec (\t:Term -> Term.substshift.shiftn.Thesis t)
    (\vt:VarType
     \M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat
     \subst:Subst
     \eq : I (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 (\x:Term \y:Term -> Term.lam vt x y)
	   (HypM n subst eq)
	   (I.rsubst (Subst.substshift.consshift.Lemma subst n)
		    (\x: Subst ->
                      I (Term.shiftn (Term.substapp N (Subst.consshift subst)) (Nat.s n))
		        (Term.substapp (Term.shiftn N (Nat.s (Nat.s n))) x))
	      (HypN (Nat.s n) (Subst.consshift subst)
	            (Term.substshift.shiftn.shifteq n vt subst eq))))
    (\vt:VarType
     \M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat \subst:Subst
     \eq : I (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 (\x:Term \y:Term -> Term.pi vt x y)
	   (HypM n subst eq)
	   (I.rsubst (Subst.substshift.consshift.Lemma subst n)
		    (\x: Subst ->
                      I (Term.shiftn (Term.substapp N (Subst.consshift subst)) (Nat.s n))
		        (Term.substapp (Term.shiftn N (Nat.s (Nat.s n))) x))
	      (HypN (Nat.s n) (Subst.consshift subst)
	            (Term.substshift.shiftn.shifteq n vt subst eq))))
    (\M: Term \HypM:(Term.substshift.shiftn.Thesis M)
     \N: Term \HypN:(Term.substshift.shiftn.Thesis N)
     \n: Nat \subst:Subst
     \eq : I (Subst.drop (Nat.s n) subst) (Subst.offset n) ->
     I.cong2 (\x:Term \y:Term -> Term.app x y)
	   (HypM n subst eq) (HypN n subst eq))
    (\vt: VarType \i:Nat
     \n:Nat \sigma:Subst ->
     Subst.evalshift.lemma vt i n n sigma)
    (\vt: VarType \n:Nat \sigma:Subst
     \eq : I (Subst.drop (Nat.s n) sigma) (Subst.offset n) ->
     I.r (Term.univ vt))

Definition Term.subst.shift = \t:Term \subst:Term \n:Nat ->
  Term.substshift.shiftn t n (Subst.unit subst)
     (Nat.rec (\n:Nat -> I (Subst.drop (Nat.s n) (Subst.unit subst))
      	      	      	   (Subst.offset n))
        (I.r (Subst.offset Nat.0))
	(\n:Nat \Hyp:I (Subst.drop (Nat.s n) (Subst.unit subst))
		       (Subst.offset n) ->
	 I.cong Subst.drop1 Hyp)
	n)
TypeCheck Term.subst.shift : t:Term -> subst:Term -> n:Nat ->
    I (Term.shiftn (Term.subst t subst) n)
      (Term.subst (Term.shiftn t (Nat.s n)) (Term.shiftn subst n))

Definition Subst.consshifti = Nat.iter Subst.consshift

Definition Subst.consshifti.shifti.Thesis = \sigma:Subst \t: Term ->
  n:Nat -> I (Term.substapp (Term.shiftn t n)
  	     	  	    (Subst.consshifti n sigma))
  	     (Term.shiftn (Term.substapp t (Subst.consshifti n sigma)) n)

Definition Subst.evalhead.shift = \vt:VarType ->
  Subst.rec (\sigma:Subst -> I (Subst.evalhead vt (Subst.shift sigma))
                               (Term.shiftvar (Subst.evalhead vt sigma)))
     (\n:Nat -> I.r (Term.var vt (Nat.s n)))
     (\t:Term \sigma:Subst \_: I (Subst.evalhead vt (Subst.shift sigma))
                               (Term.shiftvar (Subst.evalhead vt sigma)) ->
      I.r (Term.shiftvar t))			       
     (\n:Nat \sigma:Subst \_: I (Subst.evalhead vt (Subst.shift sigma))
                               (Term.shiftvar (Subst.evalhead vt sigma)) ->
      I.r (Term.var vt (Nat.s n)))

Definition Subst.eval.consshift = \vt:VarType \sigma:Subst \i:Nat ->
     I.trans (I.cong (Subst.evalhead vt)
     	     (I.trans (Nat.iter.associative Subst.drop1 i
		         	   (Subst.consshift sigma))
		      (Subst.drop.shift.commutes sigma i)))
       	     (Subst.evalhead.shift vt (Subst.drop i sigma))
TypeCheck Subst.eval.consshift : vt:VarType -> sigma:Subst -> i:Nat ->
     I (Subst.eval (Subst.consshift sigma) vt (Nat.s i))
       (Term.shiftvar (Subst.eval sigma vt i))

Definition Nat.shiftn.consshifti.unit = \vt:VarType \N:Term ->
  Let Thesis = (\n:Nat \i:Nat -> 
           I (Subst.eval (Subst.consshifti n (Subst.unit N))
	     		 vt (Nat.shiftn n i))
    	     (Term.var vt i)) ->
  Nat.rec (\n:Nat -> i:Nat -> Thesis n i)
    (\i:Nat ->
    I.cong (Subst.evalhead vt)
       (Nat.rec (\i:Nat -> I (Subst.drop (Nat.s i) (Subst.unit N))
    	     	     	     (Subst.offset i))
	   (I.r (Subst.offset Nat.0))
	   (\i:Nat \Hyp: I (Subst.drop (Nat.s i) (Subst.unit N))
    	     	     	     (Subst.offset i) ->
	    I.cong Subst.drop1 Hyp)
	   i))
    (\n:Nat \Hyp:(i:Nat -> Thesis n i) ->
     Nat.rec (\i:Nat -> Thesis (Nat.s n) i)
       (I.r (Term.var vt Nat.0))
       (\i:Nat \_:(Thesis (Nat.s n) i) ->
          (I.rsubst (Nat.iter.associative Subst.drop1 (Nat.shiftn n i)
	              (Subst.consshifti (Nat.s n) (Subst.unit N)))
	   (\x:Subst -> I (Subst.evalhead vt x) (Term.var vt (Nat.s i)))
             (I.rsubst (Subst.drop.shift.commutes
	   	         (Subst.consshifti n (Subst.unit N))
			 (Nat.shiftn n i))
 	       (\x:Subst -> I (Subst.evalhead vt x) (Term.var vt (Nat.s i)))
	        (I.trans (Subst.evalhead.shift vt
		           (Subst.drop (Nat.shiftn n i)
			   	       (Subst.consshifti n (Subst.unit N))))
	                 (I.cong Term.shiftvar (Hyp i)))))))

;; Lemma 1: Substitution on M.shift
;; I (Term.subst (Term.shiftvar M) N) M
Definition Term.shiftn.subst =
  Let Thesis = (\M:Term -> n:Nat ->
     N:Term -> I (Term.substapp (Term.shiftn M n)
     	       	 		(Subst.consshifti n (Subst.unit N))) M) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 (Term.lam vt) (HypM1 n N) (HypM2 (Nat.s n) N))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 (Term.pi vt) (HypM1 n N) (HypM2 (Nat.s n) N))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat \N:Term ->
     I.cong2 Term.app (HypM1 n N) (HypM2 n N))
    (\vt:VarType \i:Nat \n:Nat \N:Term ->
     Nat.shiftn.consshifti.unit vt N n i)
    (\vt:VarType \n:Nat \N:Term -> I.r (Term.univ vt))
	     
Definition Nat.shiftn.consshifti.swap = \vt:VarType \sigma:Subst ->
  Let Thesis = (\n:Nat \i:Nat -> 
           I (Subst.eval (Subst.consshifti (Nat.s n) sigma)
                          vt (Nat.shiftn n i))
	     (Term.shiftn (Subst.eval (Subst.consshifti n sigma)
                           	       vt i) n)) ->
  Let Aux = (\n:Nat \i:Nat ->
      Subst.eval.consshift vt (Subst.consshifti n sigma) i)  ->
  Nat.rec (\n:Nat -> i:Nat -> Thesis n i)
    (\i:Nat -> Aux Nat.0 i)
    (\n:Nat \Hyp:(i:Nat -> Thesis n i) ->
     Nat.rec (\i:Nat -> Thesis (Nat.s n) i)
       (I.r (Term.var vt Nat.0))
       (\i:Nat \_:Thesis (Nat.s n) i ->
        I.trans (Aux (Nat.s n) (Nat.shiftn n i))
	(I.trans (I.cong Term.shiftvar (Hyp i))
	(I.trans (Let T = Subst.eval (Subst.consshifti n sigma) vt i ->
		  I.subst (Nat.plus.zero n)
		          (\x:Nat ->
			   I (Term.shiftvar (Term.shiftn T x))
			     (Term.shiftn (Term.shiftvar T) (Nat.s x)))
	                  (Term.shiftn.commutes T Nat.0 n))
		 (I.cong (\t:Term -> Term.shiftn t (Nat.s n))
		 (I.symm (Aux n i)))))))

;; Lemma 2: Arbitrary Substitution on M.shift
;; I (Term.substapp (Term.shiftvar M) (consshift sigma))
;;   (Term.shiftvar (Term.substapp M sigma)
Definition Term.shiftn.consshift = \sigma:Subst ->
  Let Thesis = (\M:Term -> n:Nat ->
      I (Term.substapp (Term.shiftn M n) (Subst.consshifti (Nat.s n) sigma))
      	(Term.shiftn (Term.substapp M (Subst.consshifti n sigma)) n)) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \i:Nat \n:Nat ->
     Nat.shiftn.consshifti.swap vt sigma n i)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))
  
Definition Term.shiftvar.consshift = \M:Term \sigma:Subst ->
  Term.shiftn.consshift sigma M Nat.0

TypeCheck Subst.eval.consshift : vt:VarType -> sigma:Subst -> i:Nat ->
     I (Subst.eval (Subst.consshift sigma) vt (Nat.s i))
       (Term.shiftvar (Subst.eval sigma vt i))

Definition Nat.substapp.consshiftn = \vt:VarType \N:Term \sigma:Subst ->
  Let Thesis = (\n:Nat -> \i:Nat -> 
    I (Term.substapp (Subst.eval (Subst.consshifti (Nat.s n) sigma) vt i)
      		     (Subst.consshifti n (Subst.unit (Term.substapp N sigma))))
      (Term.substapp (Subst.eval (Subst.consshifti n (Subst.unit N)) vt i)
     		     (Subst.consshifti n sigma))) ->
  Let Aux = (\n:Nat \i:Nat \n':Nat \sigma1:Subst \sigma2:Subst ->
    I.trans (I.cong (\x:Term -> Term.substapp x (Subst.consshifti (Nat.s n) sigma2))
      	    	    (Subst.eval.consshift vt (Subst.consshifti n' sigma1) i))
            (Term.shiftvar.consshift (Subst.eval (Subst.consshifti n' sigma1) vt i)
	                             (Subst.consshifti n sigma2))) ->
  Nat.rec (\n:Nat -> i:Nat -> Thesis n i)
    (Nat.rec (\i:Nat -> Thesis Nat.0 i)
       (I.r (Term.substapp N sigma))
       (\i:Nat \_:Thesis Nat.0 i ->
        I.trans (I.cong (\x:Term -> Term.subst x (Term.substapp N sigma))
      	                (Subst.eval.consshift vt sigma i))
	(I.trans (Term.shiftn.subst (Subst.eval sigma vt i) Nat.0
				    (Term.substapp N sigma))
	(I.cong (\x:Subst -> Term.substapp (Subst.evalhead vt x) sigma)
	(I.symm (I.trans (Nat.iter.associative Subst.drop1 i (Subst.unit N))
		(I.subst (Nat.plus.zero i)
	                 (\x:Nat -> I (Subst.drop i (Subst.offset Nat.0))
	      	                      (Subst.offset x))
                         (Subst.drop.offset Nat.0 i))))))))
    (\n:Nat \Hyp:(i:Nat -> Thesis n i) ->
     Nat.rec (\i:Nat -> Thesis (Nat.s n) i)
       (I.r (Term.var vt Nat.0))
       (\i:Nat \_:Thesis (Nat.s n) i ->
        I.trans (Aux n i (Nat.s n) sigma
		         (Subst.unit (Term.substapp N sigma)))
	(I.trans (I.cong Term.shiftvar (Hyp i))
		 (I.symm (Aux n i n (Subst.unit N) sigma)))))

;; Lemma 3: Nested Substitutions
;; I (Term.subst (Term.substapp M (consshift sigma)) (Term.substapp N sigma))
;;   (Term.substapp (Term.subst M N) sigma)
Definition Term.substapp.consshiftn = \N:Term \sigma:Subst ->
  Let Thesis = (\M:Term -> n:Nat ->
    I (Term.substapp (Term.substapp M (Subst.consshifti (Nat.s n) sigma))
      		     (Subst.consshifti n (Subst.unit (Term.substapp N sigma))))
      (Term.substapp (Term.substapp M (Subst.consshifti n (Subst.unit N)))
     		     (Subst.consshifti n sigma))) ->
  Term.rec (\M:Term -> Thesis M)
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.lam vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\vt:VarType
     \M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 (Term.pi vt) (HypM1 n) (HypM2 (Nat.s n)))
    (\M1:Term \HypM1:(Thesis M1) \M2:Term \HypM2:(Thesis M2)
     \n:Nat ->
     I.cong2 Term.app (HypM1 n) (HypM2 n))
    (\vt:VarType \i:Nat \n:Nat ->
     Nat.substapp.consshiftn vt N sigma n i)
    (\vt:VarType \n:Nat -> I.r (Term.univ vt))

Definition Term.substapp.consshift = \M:Term \N:Term \sigma:Subst ->
   Term.substapp.consshiftn N sigma M Nat.0

TypeCheck Term.substapp.consshift : M:Term -> N:Term -> sigma:Subst ->
   I (Term.subst (Term.substapp M (Subst.consshift sigma))
	    	 (Term.substapp N sigma))
     (Term.substapp (Term.subst M N) sigma)



Inductive ConvStep : Term -> Term -> U =
  beta : vt:VarType -> T:Term -> M:Term -> N:Term ->
         ConvStep (Term.app (Term.lam vt T M) N) (Term.subst M N),
  lam1 : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.lam vt T1 M) (Term.lam vt T2 M),
  lam2 : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.lam vt T M1) (Term.lam vt T M2),
  pi1  : vt:VarType -> {T1:Term} -> {T2:Term} -> ConvStep T1 T2 -> M:Term ->
         ConvStep (Term.pi vt T1 M) (Term.pi vt T2 M),
  pi2  : vt:VarType -> {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> T:Term ->
         ConvStep (Term.pi vt T M1) (Term.pi vt T M2),
  app1 : {M1:Term} -> {M2:Term} -> ConvStep M1 M2 -> N:Term ->
         ConvStep (Term.app M1 N) (Term.app M2 N),
  app2 : M:Term -> {N1:Term} -> {N2:Term} -> ConvStep N1 N2 ->
         ConvStep (Term.app M N1) (Term.app M N2)

Definition ConvStep.shiftn = 
  ConvStep.rec (\T:Term \S: Term \step : ConvStep T S -> n:Nat ->
                ConvStep (Term.shiftn T n) (Term.shiftn S n))
    (\vt:VarType \T:Term \M:Term \N:Term \n:Nat ->
     I.rsubst (Term.subst.shift M N n)
	      (\x: Term -> ConvStep (Term.shiftn (Term.app (Term.lam vt T M) N) n) x)
     (ConvStep.beta vt (Term.shiftn T n) (Term.shiftn M (Nat.s n)) (Term.shiftn N n)))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.lam1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \T:Term \n:Nat ->
     ConvStep.lam2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.pi1 vt (hyp n) (Term.shiftn M (Nat.s n)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \T:Term \n:Nat ->
     ConvStep.pi2 vt (hyp (Nat.s n)) (Term.shiftn T n))
    (\T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(n:Nat -> ConvStep (Term.shiftn T1 n) (Term.shiftn T2 n))
     \M:Term \n:Nat ->
     ConvStep.app1 (hyp n) (Term.shiftn M n))
    (\T:Term \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(n:Nat -> ConvStep (Term.shiftn M1 n) (Term.shiftn M2 n))
     \n:Nat ->
     ConvStep.app2 (Term.shiftn T n) (hyp n))

Definition ConvStep.substapp = 
  ConvStep.rec ({\T:Term} {\S: Term} \step : ConvStep T S -> sigma:Subst ->
                ConvStep (Term.substapp T sigma) (Term.substapp S sigma))
    (\vt:VarType \T:Term \M:Term \N:Term \sigma:Subst ->
     I.subst (Term.substapp.consshift M N sigma)
	      (\x: Term -> ConvStep (Term.substapp (Term.app (Term.lam vt T M) N) sigma) x)
     (ConvStep.beta vt (Term.substapp T sigma) (Term.substapp M (Subst.consshift sigma)) (Term.substapp N sigma)))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(sigma:Subst -> ConvStep (Term.substapp T1 sigma) (Term.substapp T2 sigma))
     \M:Term \sigma:Subst ->
     ConvStep.lam1 vt (hyp sigma) (Term.substapp M (Subst.consshift sigma)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(sigma:Subst -> ConvStep (Term.substapp M1 sigma) (Term.substapp M2 sigma))
     \T:Term \sigma:Subst ->
     ConvStep.lam2 vt (hyp (Subst.consshift sigma)) (Term.substapp T sigma))
    (\vt:VarType \T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(sigma:Subst -> ConvStep (Term.substapp T1 sigma) (Term.substapp T2 sigma))
     \M:Term \sigma:Subst ->
     ConvStep.pi1 vt (hyp sigma) (Term.substapp M (Subst.consshift sigma)))
    (\vt:VarType \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(sigma:Subst -> ConvStep (Term.substapp M1 sigma) (Term.substapp M2 sigma))
     \T:Term \sigma:Subst ->
     ConvStep.pi2 vt (hyp (Subst.consshift sigma)) (Term.substapp T sigma))
    (\T1:Term \T2:Term
     \step:ConvStep T1 T2 \hyp:(sigma:Subst -> ConvStep (Term.substapp T1 sigma) (Term.substapp T2 sigma))
     \M:Term \sigma:Subst ->
     ConvStep.app1 (hyp sigma) (Term.substapp M sigma))
    (\T:Term \M1:Term \M2:Term
     \step:ConvStep M1 M2 \hyp:(sigma:Subst -> ConvStep (Term.substapp M1 sigma) (Term.substapp M2 sigma))
     \sigma:Subst ->
     ConvStep.app2 (Term.substapp T sigma) (hyp sigma))

Inductive ConvSymmStep : M:Term -> N:Term -> U =
  forw : ConvStep M N -> ConvSymmStep M N,
  back : ConvStep N M -> ConvSymmStep M N

Definition ConvSymmStep.shiftn = {\T:Term} {\S: Term} ->
   ConvSymmStep.rec T S (\step : ConvSymmStep T S -> n:Nat -> 
                         ConvSymmStep (Term.shiftn T n) (Term.shiftn S n))
	(\fstep:ConvStep T S \n:Nat -> ConvSymmStep.forw (Term.shiftn T n) (Term.shiftn S n)
			     	       			 (ConvStep.shiftn T S fstep n))
	(\bstep:ConvStep S T \n:Nat -> ConvSymmStep.back (Term.shiftn T n) (Term.shiftn S n)
			     	       			 (ConvStep.shiftn S T bstep n))
Definition ConvSymmStep.substapp = {\T:Term} {\S: Term} ->
   ConvSymmStep.rec T S (\step : ConvSymmStep T S -> sigma:Subst -> 
                         ConvSymmStep (Term.substapp T sigma) (Term.substapp S sigma))
	(\fstep:ConvStep T S \sigma:Subst -> ConvSymmStep.forw (Term.substapp T sigma) (Term.substapp S sigma)
			     	       			 (ConvStep.substapp T S fstep sigma))
	(\bstep:ConvStep S T \sigma:Subst -> ConvSymmStep.back (Term.substapp T sigma) (Term.substapp S sigma)
			     	       			 (ConvStep.substapp S T bstep sigma))

Inductive List : A:U -> U =
  nil  : List A,
  cons : A -> List A -> List A

Inductive VarList : U =
  nil  : VarList,
  cons : vt:VarType -> T:Term -> Gamma:VarList -> VarList

Definition VarList.append = \Gamma:VarList ->
  VarList.rec (\_:VarList -> VarList) Gamma
     (\vt0:VarType \T0:Term \_:VarList \rec:VarList ->
      VarList.cons vt0 T0 rec)
Definition VarList.len =
  VarList.rec (\_:VarList -> Nat) Nat.0
     (\vt0:VarType \T0:Term \_:VarList \rec:Nat -> Nat.s rec)

Inductive CCTypeCheck : VarList -> Term -> Term -> Prop =
  ax   : CCTypeCheck VarList.nil Term.* Term.[],
  var  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.var vt Nat.0) (Term.shiftvar T),
  weak : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
         {M : Term} -> {S:Term} -> CCTypeCheck Gamma M S ->
         CCTypeCheck (VarList.cons vt T Gamma)
	 	     (Term.shiftvar M) (Term.shiftvar S),
  pi   : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
	 {vt2 : VarType} -> {S : Term} ->
	 CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2),
  lam  : {Gamma:VarList} -> {vt:VarType} -> {T : Term} ->
         {M:Term} -> {S:Term} ->
         CCTypeCheck (VarList.cons vt T Gamma) M S ->
	 {vt2: VarType} -> CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	 CCTypeCheck Gamma (Term.lam vt T M) (Term.pi vt T S),
  app  : {Gamma:VarList} -> {M:Term} -> {vt: VarType} -> {T : Term} -> {S:Term} ->
         CCTypeCheck Gamma M (Term.pi vt T S) ->
	 {N : Term} -> CCTypeCheck Gamma N T ->
	 CCTypeCheck Gamma (Term.app M N) (Term.subst S N),
  conv : {Gamma:VarList} -> {M:Term} -> {T:Term} -> CCTypeCheck Gamma M T ->
	 {S : Term} -> ConvSymmStep T S ->
	 CCTypeCheck Gamma M S

Inductive VarListTypeCheck : VarList -> U =
  nil  : VarListTypeCheck VarList.nil,
  cons : {vt:VarType} -> {T:Term} -> {Gamma:VarList} ->
         CCTypeCheck Gamma T (Term.univ vt) ->
 	 VarListTypeCheck Gamma -> 
         VarListTypeCheck (VarList.cons vt T Gamma)

Definition CCTypeCheck.case =
  \C:(Gamma:VarList -> M:Term -> S:Term -> U1)
  \caseax: (C VarList.nil Term.* Term.[])
  \casevar:(Gamma:VarList -> vt:VarType -> T : Term ->
            CCTypeCheck Gamma T (Term.univ vt) ->
	    C (VarList.cons vt T Gamma) (Term.var vt Nat.0) (Term.shiftvar T))
  \caseweak:(Gamma:VarList -> vt:VarType -> T : Term ->
             CCTypeCheck Gamma T (Term.univ vt) ->
             M : Term -> S:Term -> CCTypeCheck Gamma M S ->
             C (VarList.cons vt T Gamma) (Term.shiftvar M) (Term.shiftvar S))
  \casepi:  (Gamma:VarList -> vt:VarType -> T : Term ->
             CCTypeCheck Gamma T (Term.univ vt) ->
	     vt2 : VarType -> S : Term ->
	     CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
	     C Gamma (Term.pi vt T S) (Term.univ vt2))
  \caselam: (Gamma:VarList -> vt:VarType -> T : Term -> M:Term -> S:Term ->
             CCTypeCheck (VarList.cons vt T Gamma) M S ->
	     vt2: VarType ->
	     CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
	     C Gamma (Term.lam vt T M) (Term.pi vt T S))
  \caseapp: (Gamma:VarList -> M:Term -> vt: VarType -> T : Term -> S:Term ->
             CCTypeCheck Gamma M (Term.pi vt T S) ->
	     N : Term -> CCTypeCheck Gamma N T ->
	     C Gamma (Term.app M N) (Term.subst S N))
  \caseconv:(Gamma:VarList -> M:Term -> T:Term -> CCTypeCheck Gamma M T ->
	     S : Term -> ConvSymmStep T S ->
	     C Gamma M S) ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
  		   C Gamma M S)
    caseax
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt) ->
     casevar Gamma vt T prf)
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt)
     \M : Term \S:Term \prf2: CCTypeCheck Gamma M S \_: C Gamma M S ->
     caseweak Gamma vt T prf M S prf2)
    (\Gamma:VarList \vt:VarType \T : Term
     \prf: CCTypeCheck Gamma T (Term.univ vt) \_: C Gamma T (Term.univ vt)
     \vt2 : VarType \S:Term
     \prf2: CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_: C (VarList.cons vt T Gamma) S (Term.univ vt2) ->
     casepi Gamma vt T prf vt2 S prf2)
    (\Gamma:VarList \vt:VarType \T : Term \M:Term \S:Term
     \prf: CCTypeCheck (VarList.cons vt T Gamma) M S
     \_: C (VarList.cons vt T Gamma) M S
     \vt2 : VarType 
     \prf2: CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \_: C Gamma (Term.pi vt T S) (Term.univ vt2) ->
     caselam Gamma vt T M S prf vt2 prf2)
    (\Gamma:VarList \M:Term \vt:VarType \T : Term \S:Term
     \prf: CCTypeCheck Gamma M (Term.pi vt T S) \_: C Gamma M (Term.pi vt T S)
     \N:Term \prf2: CCTypeCheck Gamma N T \_: C Gamma N T ->
     caseapp Gamma M vt T S prf N prf2)
    (\Gamma:VarList \M:Term \T : Term
     \prf: CCTypeCheck Gamma M T \_: C Gamma M T
     \S:Term \step:ConvSymmStep T S ->
     caseconv Gamma M T prf S step)

Definition CCTypeCheck.ax2 = 
  VarListTypeCheck.rec ({\Gamma:VarList} \_:VarListTypeCheck Gamma ->
                        CCTypeCheck Gamma Term.* Term.[])
     CCTypeCheck.ax
     (\vt:VarType \T:Term \Gamma:VarList
      \tc:CCTypeCheck Gamma T (Term.univ vt)
      \_:VarListTypeCheck Gamma
      \r:CCTypeCheck Gamma Term.* Term.[] ->
        CCTypeCheck.weak tc r)

Definition CCTypeCheck.gammatc =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
                   VarListTypeCheck Gamma)
    VarListTypeCheck.nil
    ;var
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prf: CCTypeCheck Gamma T (Term.univ vt)
     \rec: VarListTypeCheck Gamma
     \M : Term \S:Term \_: CCTypeCheck Gamma M S \_:VarListTypeCheck Gamma ->
     VarListTypeCheck.cons prf rec)
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Definition VarList.deleten =
  Nat.rec (\n:Nat -> VarList -> VarList)
    (\Gamma:VarList -> Gamma)
    (\_:Nat \delrec:(VarList -> VarList) ->
     VarList.rec (\Gamma:VarList -> VarList) VarList.nil
        (\vt1:VarType \T1:Term \Gamma:VarList \_:VarList -> delrec Gamma))
    
Definition VarList.insertn =
  Nat.rec (\n:Nat -> VarType -> Term -> VarList -> VarList)
    VarList.cons
    (\n:Nat \insertrec:(VarType -> Term -> VarList -> VarList)
     \vt:VarType \T0:Term ->
     VarList.rec (\Gamma:VarList -> VarList)
        (insertrec vt T0 VarList.nil)
	(\vt1:VarType \T1:Term \Gamma:VarList \_:VarList ->
	 VarList.cons vt1 (Term.shiftn T1 n) (insertrec vt T0 Gamma)))
	 
Definition deletenil =
  Nat.rec (\n:Nat -> I (VarList.deleten n VarList.nil) VarList.nil)
     (I.r VarList.nil)
     (\n:Nat \_:I (VarList.deleten n VarList.nil) VarList.nil ->
      I.r VarList.nil)

Definition CCTypeCheck.weakn =
  \vt:VarType \T0:Term ->
  CCTypeCheck.rec ({\Gamma:VarList} {\M:Term} {\N:Term}
  		   \_:CCTypeCheck Gamma M N ->
                   n:Nat ->
		   CCTypeCheck (VarList.deleten n Gamma)
		       		T0 (Term.univ vt) ->
                   CCTypeCheck (VarList.insertn n vt T0 Gamma)
		                (Term.shiftn M n)
				(Term.shiftn N n))
    ;ax
    (Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
	      CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                    (Term.shiftn Term.* n)
				    (Term.shiftn Term.[] n))
       (\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 CCTypeCheck.ax)
       (\n:Nat
        \rec:(CCTypeCheck (VarList.deleten n VarList.nil) T0 (Term.univ vt) ->
              CCTypeCheck (VarList.insertn n vt T0 VarList.nil)
		                 (Term.shiftn Term.* n)
				 (Term.shiftn Term.[] n))
	\prfT0:CCTypeCheck VarList.nil T0 (Term.univ vt) ->
	rec (I.rsubst (deletenil n)
		      (\x:VarList -> CCTypeCheck x T0 (Term.univ vt))
		      prfT0)))
    ;var
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.var vt1 Nat.0) n)
			  (Term.shiftn (Term.shiftvar T1) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.var prf1))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.var vt1 Nat.0) n)
			 (Term.shiftn (Term.shiftvar T1) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst (Term.shiftvarn.commutes T1 n)
	        (\x:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       (Term.var vt1 Nat.0)  x)
	 (CCTypeCheck.var (Hyp n prfT0))))
    ;weak
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \M : Term \S:Term
     \prf2: CCTypeCheck Gamma M S
     \Hyp2: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma) 
	              (Term.shiftn M n) (Term.shiftn S n)) ->
     Nat.rec (\n:Nat ->
     	      CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
     	      CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		          (Term.shiftn (Term.shiftvar M) n)
			  (Term.shiftn (Term.shiftvar S) n))
       (\prfT0:CCTypeCheck (VarList.cons vt1 T1 Gamma) T0 (Term.univ vt) ->
        CCTypeCheck.weak prfT0 (CCTypeCheck.weak prf1 prf2))
       (\n:Nat
	\_: (CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	                 T0 (Term.univ vt) ->
	     CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
		         (Term.shiftn (Term.shiftvar M) n)
			 (Term.shiftn (Term.shiftvar S) n))
	\prfT0:CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
        I.subst2 (Term.shiftvarn.commutes M n)
		 (Term.shiftvarn.commutes S n)
	         (\x:Term \y:Term ->
	       	   CCTypeCheck (VarList.insertn (Nat.s n) vt T0
		   	             (VarList.cons vt1 T1 Gamma))
			       x y)
	 (CCTypeCheck.weak (Hyp1 n prfT0) (Hyp2 n prfT0))))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \Hyp1: (n:Nat -> CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	              (Term.shiftn T1 n) (Term.univ vt1)) ->
     \vt2:VarType \S:Term
     \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n
     	    	          (VarList.cons vt1 T1 Gamma)) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                 (Term.shiftn S n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.pi (Hyp1 n prfT0) (Hyp2 (Nat.s n) prfT0))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n (VarList.cons vt1 T1 Gamma))
	    		T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 (VarList.cons vt1 T1 Gamma))
	                (Term.shiftn M n) (Term.shiftn S n)) ->
     \vt2:VarType
     \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn (Term.pi vt1 T1 S) n) (Term.univ vt2))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     CCTypeCheck.lam (Hyp1 (Nat.s n) prfT0) (Hyp2 n prfT0))
    ;app
    (\Gamma:VarList \M:Term \vt1:VarType \T1:Term \S:Term
     \prf1: CCTypeCheck Gamma M (Term.pi vt1 T1 S)
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn (Term.pi vt1 T1 S) n)) ->
     \N:Term
     \prf2:CCTypeCheck Gamma N T1
     \Hyp2: (n:Nat ->
             CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
             CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                 (Term.shiftn N n) (Term.shiftn T1 n))
     \n:Nat
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     I.rsubst (Term.subst.shift S N n)
	      (\x: Term -> CCTypeCheck (VarList.insertn n vt T0 Gamma)
	      	                       (Term.shiftn (Term.app M N) n) x)
     (CCTypeCheck.app (Hyp1 n prfT0) (Hyp2 n prfT0)))
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \prf1: CCTypeCheck Gamma M T
     \Hyp1: (n:Nat ->
     	    CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
            CCTypeCheck (VarList.insertn n vt T0 Gamma)
	                (Term.shiftn M n) (Term.shiftn T n))
     \S:Term \step:ConvSymmStep T S
     \n:Nat 
     \prfT0: CCTypeCheck (VarList.deleten n Gamma) T0 (Term.univ vt) ->
     (CCTypeCheck.conv (Hyp1 n prfT0) (ConvSymmStep.shiftn step n)))


Inductive CCSubstCheck : Subst -> VarList -> VarList -> U =
  start  : Gamma:VarList ->
           CCSubstCheck (Subst.offset Nat.0) Gamma Gamma,
  offset : Gamma:VarList ->
	   vt:VarType -> S:Term -> CCTypeCheck Gamma S (Term.univ vt) ->
           i:Nat -> Gamma':VarList ->
	   CCSubstCheck (Subst.offset i) Gamma Gamma' ->
           CCSubstCheck (Subst.offset (Nat.s i))
	   		(VarList.cons vt S Gamma) Gamma',
  cons   : Gamma:VarList -> vt:VarType -> t:Term -> sigma:Subst ->
  	   Gamma':VarList -> S:Term ->
	   CCTypeCheck Gamma t S ->
	   CCSubstCheck sigma Gamma Gamma' ->
           CCSubstCheck (Subst.cons t sigma) Gamma (VarList.cons vt S Gamma')


Definition Subst.consshifti.shifti = \sigma:Subst ->
  Term.rec (\t:Term -> Subst.consshifti.shifti.Thesis sigma t)
     (\vt:VarType
      \M:Term \HypM:Subst.consshifti.shifti.Thesis sigma M
      \N:Term \HypN:Subst.consshifti.shifti.Thesis sigma N
      \n:Nat ->
      I.cong2 (\M:Term\N:Term -> Term.lam vt M N)
        (HypM n) (HypN (Nat.s n)))
     (\vt:VarType
      \M:Term \HypM:Subst.consshifti.shifti.Thesis sigma M
      \N:Term \HypN:Subst.consshifti.shifti.Thesis sigma N
      \n:Nat ->
      I.cong2 (\M:Term\N:Term -> Term.pi vt M N)
        (HypM n) (HypN (Nat.s n)))
     (\M:Term \HypM:Subst.consshifti.shifti.Thesis sigma M
      \N:Term \HypN:Subst.consshifti.shifti.Thesis sigma N
      \n:Nat ->
      I.cong2 (\M:Term\N:Term -> Term.app M N) (HypM n) (HypN n))
;     (\vt:VarType \i:Nat \n:Nat ->
;      I.r (Subst.eval (Subst.consshifti n sigma) vt (Nat.shiftn n i)))
;     (\vt:VarType \n:Nat -> I.r (Term.univ vt))

Definition CCTypeCheck.subst.Thesis = \vt:VarType \T0:Term \N:Term
  \Gamma:VarList \M:Term \S:Term ->
  n:Nat -> Gamma':VarList -> I Gamma (VarList.insertn n vt T0 Gamma') ->
  CCTypeCheck (VarList.deleten n Gamma') N T0 ->
  CCTypeCheck Gamma' (Term.substapp M (Subst.consshifti n (Subst.unit N)))
                     (Term.substapp S (Subst.consshifti n (Subst.unit N)))

Definition VarList.isEmpty =
  VarList.rec (\_:VarList -> U) T (\_:VarType\_:Term\_:VarList\_:U -> F)

Definition VarList.notEmpty.insert =
  Nat.rec (\n:Nat -> vt:VarType -> T0:Term -> Gamma:VarList ->
  	   VarList.isEmpty (VarList.insertn n vt T0 Gamma) -> F)
    (\vt:VarType \T0:Term \Gamma:VarList \x:F -> x)
    (\n:Nat \Hyp:(vt:VarType -> T0:Term -> Gamma:VarList ->
  	   VarList.isEmpty (VarList.insertn n vt T0 Gamma) -> F)
     \vt:VarType \T0:Term ->
     VarList.rec (\Gamma:VarList ->
                  VarList.isEmpty (VarList.insertn (Nat.s n) vt T0 Gamma) -> F)
       (Hyp vt T0 VarList.nil)
       (\vt1:VarType \T1:Term \Gamma:VarList
        \_:(VarList.isEmpty (VarList.insertn (Nat.s n) vt T0 Gamma) -> F)
	\x:F -> x))

Inductive VarListSplit : U =
  fail : VarListSplit,
  mk   : Term -> VarList -> VarList -> VarListSplit

Definition VarListSplit.extend =  \vt1:VarType \T1:Term ->
  VarListSplit.rec (\_:VarListSplit -> VarListSplit)
     VarListSplit.fail
     (\T2:Term \Gamma1:VarList \Gamma2:VarList ->
         VarListSplit.mk T2 Gamma1 (VarList.cons vt1 T1 Gamma2))

Definition VarList.split = \N:Term ->
  VarList.rec (\_:VarList -> Nat -> VarListSplit)
    (\n:Nat -> VarListSplit.fail)
    (\vt1:VarType \T1:Term \Gamma:VarList
    \Hyp:(Nat -> VarListSplit) ->
    Nat.rec (\i:Nat -> VarListSplit)
      (VarListSplit.mk T1 Gamma Gamma)
      (\i:Nat \_:VarListSplit ->
       Let T1' = Term.substapp T1 (Subst.consshifti i (Subst.unit N)) ->
       VarListSplit.extend vt1 T1' (Hyp i)))

Definition CCTypeCheck.subst = \vt:VarType \T0:Term \N:Term ->
  Let Thesis.aux = (\M:Term \S:Term \n:Nat ->
     VarListSplit.rec (\_:VarListSplit -> U) T
       (\T1:Term\Gamma1:VarList\Gamma2:VarList ->
	      Let sigma = (Subst.consshifti n (Subst.unit N)) ->
	      CCTypeCheck Gamma1 N T1 ->
	      CCTypeCheck Gamma2 (Term.substapp M sigma)
	                         (Term.substapp S sigma)))
  Let Thesis = (\Gamma:VarList \M:Term \S:Term \n:Nat ->
     Thesis.aux M S n (VarList.split N Gamma n)) ->
  CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term
                   \_:CCTypeCheck Gamma M S -> n:Nat -> Thesis Gamma M S n)
     ;ax
     (\n:Nat -> T.tt)
     ; var
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n) ->
      Nat.rec (\n:Nat -> Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	 	(Term.var vt1 Nat.0) (Term.shiftvar T1) n)
	  (I.rsubst (Term.shiftn.subst T1 Nat.0 N)
	   	    (\x:Term -> CCTypeCheck Gamma N x))
	  (\n:Nat\_:(Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	    (Term.var vt1 Nat.0) (Term.shiftvar T1) n) ->
	   Let sigma = (Subst.consshifti n (Subst.unit N)) ->
	   VarListSplit.rec
		(\split:VarListSplit ->
		 Thesis.aux T1 (Term.univ vt1) n split ->
		 Thesis.aux (Term.var vt1 Nat.0) (Term.shiftvar T1) (Nat.s n)
		   (VarListSplit.extend vt1 (Term.substapp T1 sigma) split))
		(\x:T -> T.tt)
		(\T2:Term\Gamma1:VarList\Gamma2:VarList
		 \Hyp1:(CCTypeCheck Gamma1 N T2 ->
		        CCTypeCheck Gamma2 (Term.substapp T1 sigma)
				    	   (Term.univ vt1))
		 \prf:CCTypeCheck Gamma1 N T2 ->
		 I.rsubst (Term.shiftvar.consshift T1 sigma)
		    (\x:Term -> CCTypeCheck
		    	 (VarList.cons vt1 (Term.substapp T1 sigma) Gamma2)
			 (Term.var vt1 Nat.0) x)
		    (CCTypeCheck.var (Hyp1 prf)))
		(VarList.split N Gamma n)
		(Hyp n)))
     ; weak
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n)
      \M1:Term \S1:Term
      \prf2:CCTypeCheck Gamma M1 S1
      \Hyp2:(n:Nat -> Thesis Gamma M1 S1 n) ->
      Nat.rec (\n:Nat -> Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	 	(Term.shiftvar M1) (Term.shiftvar S1) n)
	  (\_:CCTypeCheck Gamma N T1 ->
	   I.subst2 (I.symm (Term.shiftn.subst M1 Nat.0 N))
	  	    (I.symm (Term.shiftn.subst S1 Nat.0 N))
	   	    (\x:Term \y:Term -> CCTypeCheck Gamma x y)
		    prf2)
	  (\n:Nat\_:(Thesis (VarList.cons vt1 T1 Gamma)
      	      	      	    (Term.shiftvar M1) (Term.shiftvar S1) n) ->
	   Let sigma = (Subst.consshifti n (Subst.unit N)) ->
	   VarListSplit.rec
		(\split:VarListSplit ->
		 Thesis.aux T1 (Term.univ vt1) n split ->
		 Thesis.aux M1 S1 n split ->
		 Thesis.aux (Term.shiftvar M1) (Term.shiftvar S1) (Nat.s n)
		   (VarListSplit.extend vt1 (Term.substapp T1 sigma) split))
		(\x:T\y:T -> T.tt)
		(\T2:Term\Gamma1:VarList\Gamma2:VarList
		 \Hyp3:(CCTypeCheck Gamma1 N T2 ->
		        CCTypeCheck Gamma2 (Term.substapp T1 sigma)
				    	   (Term.univ vt1))
		 \Hyp4:(CCTypeCheck Gamma1 N T2 ->
		        CCTypeCheck Gamma2 (Term.substapp M1 sigma)
				    	   (Term.substapp S1 sigma))
		 \prf:CCTypeCheck Gamma1 N T2 ->
		 I.subst2 (I.symm (Term.shiftvar.consshift M1 sigma))
		 	  (I.symm (Term.shiftvar.consshift S1 sigma))
		    (\M:Term \N:Term -> CCTypeCheck
		    	 (VarList.cons vt1 (Term.substapp T1 sigma) Gamma2) M N)
		    (CCTypeCheck.weak (Hyp3 prf) (Hyp4 prf)))
		(VarList.split N Gamma n)
		(Hyp1 n) (Hyp2 n)))
     ; pi
     (\Gamma:VarList \vt1:VarType \T1:Term
      \prf1:CCTypeCheck Gamma T1 (Term.univ vt1)
      \Hyp1:(n:Nat -> Thesis Gamma T1 (Term.univ vt1) n)
      \vt2:VarType \S:Term
      \prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
      \Hyp2:(n:Nat -> Thesis (VarList.cons vt1 T1 Gamma) S (Term.univ vt2) n)
      \n:Nat
      Let sigma = (Subst.consshifti n (Subst.unit N)) ->
      VarListSplit.rec
	 (\split:VarListSplit ->
	  Thesis.aux T1 (Term.univ vt1) n split ->
	  Thesis.aux S (Term.univ vt2) (Nat.s n)
	    (VarListSplit.extend vt1 (Term.substapp T1 sigma) split) ->
	  Thesis.aux (Term.pi vt1 T1 S) (Term.univ vt2) n split)
	 (\x:T\y:T -> T.tt)
	 (\T2:Term\Gamma1:VarList\Gamma2:VarList
	  \Hyp1':(CCTypeCheck Gamma1 N T2 ->
		  CCTypeCheck Gamma2 (Term.substapp T1 sigma)
				     (Term.univ vt1))
	  \Hyp2':(CCTypeCheck Gamma1 N T2 ->
		  CCTypeCheck (VarList.cons vt1 (Term.substapp T1 sigma) Gamma2)
		  	      (Term.substapp S (Subst.consshift sigma))
			      (Term.univ vt2))
	  \prf:CCTypeCheck Gamma1 N T2 ->
          CCTypeCheck.pi (Hyp1' prf) (Hyp2' prf))
	 (VarList.split N Gamma n)
	 (Hyp1 n) (Hyp2 (Nat.s n)))
     ; lam
     (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
      \prf1:CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
      \Hyp1:(n:Nat -> Thesis (VarList.cons vt1 T1 Gamma) M S n)
      \vt2:VarType
      \prf2:CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
      \Hyp2:(n:Nat -> Thesis Gamma (Term.pi vt1 T1 S) (Term.univ vt2) n)
      \n:Nat
      Let sigma = (Subst.consshifti n (Subst.unit N)) ->
      VarListSplit.rec
	 (\split:VarListSplit ->
	  Thesis.aux M S (Nat.s n)
	    (VarListSplit.extend vt1 (Term.substapp T1 sigma) split) ->
	  Thesis.aux (Term.pi vt1 T1 S) (Term.univ vt2) n split ->
	  Thesis.aux (Term.lam vt1 T1 M) (Term.pi vt1 T1 S) n split)
	 (\x:T\y:T -> T.tt)
	 (\T2:Term\Gamma1:VarList\Gamma2:VarList
	  \Hyp1':(CCTypeCheck Gamma1 N T2 ->
		  CCTypeCheck (VarList.cons vt1 (Term.substapp T1 sigma) Gamma2)
		  	      (Term.substapp M (Subst.consshift sigma))
		  	      (Term.substapp S (Subst.consshift sigma)))
	  \Hyp2':(CCTypeCheck Gamma1 N T2 ->
		  CCTypeCheck Gamma2 (Term.substapp (Term.pi vt1 T1 S) sigma)
				     (Term.univ vt2))
	  \prf:CCTypeCheck Gamma1 N T2 ->
          CCTypeCheck.lam (Hyp1' prf) (Hyp2' prf))
	 (VarList.split N Gamma n)
	 (Hyp1 (Nat.s n)) (Hyp2 n))
     ; app
     (\Gamma:VarList \M1:Term \vt1:VarType \T1:Term \S:Term
      \prf1:CCTypeCheck Gamma M1 (Term.pi vt1 T1 S)
      \Hyp1:(n:Nat -> Thesis Gamma M1 (Term.pi vt1 T1 S) n)
      \M2:Term
      \prf2:CCTypeCheck Gamma M2 T1
      \Hyp2:(n:Nat -> Thesis Gamma M2 T1 n)
      \n:Nat
      Let sigma = (Subst.consshifti n (Subst.unit N)) ->
      VarListSplit.rec
	 (\split:VarListSplit ->
	  Thesis.aux M1 (Term.pi vt1 T1 S) n split ->
	  Thesis.aux M2 T1 n split ->
	  Thesis.aux (Term.app M1 M2) (Term.subst S M2) n split)
	 (\x:T\y:T -> T.tt)
	 (\T2:Term\Gamma1:VarList\Gamma2:VarList
	  \Hyp1':(CCTypeCheck Gamma1 N T2 ->
		  CCTypeCheck Gamma2 (Term.substapp M1 sigma)
		  	      (Term.substapp (Term.pi vt1 T1 S) sigma))
	  \Hyp2':(CCTypeCheck Gamma1 N T2 ->
		  CCTypeCheck Gamma2 (Term.substapp M2 sigma)
				     (Term.substapp T1 sigma))
	  \prf:CCTypeCheck Gamma1 N T2 ->
	  I.subst (Term.substapp.consshift S M2 sigma)
	     (\x:Term ->
	      CCTypeCheck Gamma2 (Term.substapp (Term.app M1 M2) sigma) x)
             (CCTypeCheck.app (Hyp1' prf) (Hyp2' prf)))
	 (VarList.split N Gamma n)
	 (Hyp1 n) (Hyp2 n))
     ; conv
     (\Gamma:VarList \M:Term \S1:Term
      \prf1:CCTypeCheck Gamma M S1
      \Hyp1:(n:Nat -> Thesis Gamma M S1 n)
      \S2:Term
      \prf2:ConvSymmStep S1 S2
      \n:Nat
      Let sigma = (Subst.consshifti n (Subst.unit N)) ->
      VarListSplit.rec
	 (\split:VarListSplit ->
	  Thesis.aux M S1 n split ->
	  Thesis.aux M S2 n split)
	 (\x:T -> T.tt)
	 (\T2:Term\Gamma1:VarList\Gamma2:VarList
	  \Hyp1':(CCTypeCheck Gamma1 N T2 ->
		  CCTypeCheck Gamma2 (Term.substapp M sigma)
		  	      (Term.substapp S1 sigma))
	  \prf:CCTypeCheck Gamma1 N T2 ->
          CCTypeCheck.conv (Hyp1' prf)
	  		   (ConvSymmStep.substapp prf2 sigma))
	 (VarList.split N Gamma n)
	 (Hyp1 n))
		
TypeCheck ({\vt0:VarType} {\T0:Term} {\Gamma:VarList} {\M:Term} {\S:Term}
  \prf:CCTypeCheck (VarList.cons vt0 T0 Gamma) M S {\N:Term} ->
  CCTypeCheck.subst vt0 T0 N (VarList.cons vt0 T0 Gamma) M S prf Nat.0) :
  (vt0:VarType -> T0:Term -> Gamma:VarList -> M:Term -> S:Term ->
  CCTypeCheck (VarList.cons vt0 T0 Gamma) M S -> N:Term -> 
  CCTypeCheck Gamma N T0 ->
  CCTypeCheck Gamma (Term.subst M N) (Term.subst S N))

Inductive Class : U =
  []     : Class,
  kind   : Class,
  prop   : Class,
  constr : Class,
  obj    : Class

Definition Class.constr2prop =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.prop Class.prop Class.obj
Definition Class.prop2constr =
  Class.rec (\_:Class -> Class)
    Class.[] Class.kind Class.constr Class.constr Class.obj
Definition Class.constrobj =
  VarType.rec (\_:VarType -> Class) Class.constr Class.obj
Definition Class.kindprop =
  VarType.rec (\_:VarType -> Class) Class.kind Class.prop
Definition Class.boxkind =
  VarType.rec (\_:VarType -> Class) Class.[] Class.kind


Definition Term.classify =
  Term.rec (\t:Term -> Class)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; lam
        Class.prop2constr Nc)
    (\vt:VarType \M:Term \_:Class \N:Term \Nc:Class ->  ; pi
        Class.constr2prop Nc)
    (\M:Term \Mc:Class \N:Term \_:Class -> Mc)          ; app
    (\vt:VarType \n:Nat -> Class.constrobj vt)          ; var
    Class.boxkind                                       ; univ

Definition Term.shiftn.classify =
  Term.rec (\M:Term -> n:Nat ->
            I (Term.classify (Term.shiftn M n)) (Term.classify M))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class.prop2constr (Hyp (Nat.s n)))
    (\vt:VarType
     \M:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> I.cong Class.constr2prop (Hyp (Nat.s n)))
    (\M:Term
     \Hyp:(n:Nat -> I (Term.classify (Term.shiftn M n)) (Term.classify M))
     \N:Term
     \_:(n:Nat -> I (Term.classify (Term.shiftn N n)) (Term.classify N))
     \n:Nat -> Hyp n)
    (\vt:VarType \i:Nat \n:Nat -> I.r (Class.constrobj vt))
    (\vt:VarType \n:Nat -> I.r (Class.boxkind vt))

Inductive TypedClass : Gamma:VarList -> S:Term -> Class -> U =
  kind  : CCTypeCheck Gamma S Term.[] -> TypedClass Gamma S Class.kind,
  prop  : CCTypeCheck Gamma S Term.*  -> TypedClass Gamma S Class.prop,
  constr: A:Term -> CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.[] -> TypedClass Gamma S Class.constr,
  obj   : A:Term -> CCTypeCheck Gamma S A ->
          CCTypeCheck Gamma A Term.* -> TypedClass Gamma S Class.obj

Assume XXX : Gamma:VarList -> S:Term -> vt:VarType ->
     CCTypeCheck Gamma S (Term.univ vt) ->
     TypedClass Gamma S (Term.classify S) ->
     I (Class.constr2prop (Term.classify S)) (Class.kindprop vt)

Definition Term.classify.type.correct =
   CCTypeCheck.rec (\Gamma:VarList \M:Term \S:Term \t:CCTypeCheck Gamma M S ->
                    TypedClass Gamma M (Term.classify M))
    ;ax
    (TypedClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf:CCTypeCheck Gamma T0 (Term.univ vt)
     \_:TypedClass Gamma T0 (Term.classify T0) ->
     VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term -> A:Term ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt (VarList.cons vt T0 Gamma) (Term.var vt Nat.0) (Term.shiftvar T0)
	(CCTypeCheck.var prf)
	(CCTypeCheck.weak prf prf))
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: TypedClass Gamma T0 (Term.classify T0) ->
     \M: Term -> \S:Term -> \prf2:CCTypeCheck Gamma M S ->
     I.rsubst (Term.shiftn.classify M Nat.0)
     	 (\x:Class -> TypedClass Gamma M (Term.classify M) ->
	 	   TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) x)
     (TypedClass.rec Gamma M
         (\class: Class \_:TypedClass Gamma M class ->
          TypedClass (VarList.cons vt T0 Gamma) (Term.shiftvar M) class)
	 ; kind
	 (\prf3: CCTypeCheck Gamma M Term.[] ->
	  TypedClass.kind (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak prf prf3))
	 ; prop
	 (\prf3: CCTypeCheck Gamma M Term.* ->
	  TypedClass.prop (VarList.cons vt T0 Gamma) (Term.shiftvar M)
	                  (CCTypeCheck.weak prf prf3))
	 ; constr
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.[] ->
	  TypedClass.constr (VarList.cons vt T0 Gamma)
	  		    (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 ; obj
	 (\A:Term \prf3: CCTypeCheck Gamma M A
	  \prf4: CCTypeCheck Gamma A Term.* ->
	  TypedClass.obj (VarList.cons vt T0 Gamma)
	  		 (Term.shiftvar M) (Term.shiftvar A)
	     (CCTypeCheck.weak prf prf3)
	     (CCTypeCheck.weak prf prf4))
	 (Term.classify M)))
    ;pi
    (\Gamma:VarList \vt1:VarType \T1:Term
     \prf1: CCTypeCheck Gamma T1 (Term.univ vt1)
     \_: TypedClass Gamma T1 (Term.classify T1) ->
     \vt2: VarType -> \S:Term ->
     \prf2: CCTypeCheck (VarList.cons vt1 T1 Gamma) S (Term.univ vt2)
     \Hyp: TypedClass (VarList.cons vt1 T1 Gamma) S (Term.classify S) ->
     I.rsubst (Assume I (Class.constr2prop (Term.classify S)) (Class.kindprop vt2))
	       (\x:Class -> TypedClass Gamma (Term.pi vt1 T1 S) x)
     (VarType.rec (\vt:VarType ->
     		  Gamma:VarList -> M:Term ->
		  CCTypeCheck Gamma M (Term.univ vt) ->
                  TypedClass Gamma M (Class.kindprop vt))
        TypedClass.kind
	TypedClass.prop
	vt2 Gamma (Term.pi vt1 T1 S)
	    (CCTypeCheck.pi prf1 prf2)))
    ;lam
    (\Gamma:VarList \vt1:VarType \T1:Term \M:Term \S:Term
     \prf1: CCTypeCheck (VarList.cons vt1 T1 Gamma) M S
     \_: TypedClass (VarList.cons vt1 T1 Gamma) M (Term.classify M) ->
     \vt2: VarType ->
     \prf2: CCTypeCheck Gamma (Term.pi vt1 T1 S) (Term.univ vt2)
     \Hyp: TypedClass Gamma (Term.pi vt1 T1 S)
     	   	      (Class.constr2prop (Term.classify S)) ->
     I.rsubst  (Assume I (Class.prop2constr (Term.classify S)) (Class.constrobj vt2))
	       (\x:Class -> TypedClass Gamma (Term.lam vt1 T1 M) x)
     (VarType.rec (\vt:VarType ->
     		  {Gamma:VarList} -> {M:Term} -> {A:Term} ->
		  CCTypeCheck Gamma M A ->
		  CCTypeCheck Gamma A (Term.univ vt) ->
                  TypedClass Gamma M (Class.constrobj vt))
        TypedClass.constr
	TypedClass.obj
	vt2 (CCTypeCheck.lam prf1 prf2) prf2))

Definition Term.ispi = 
   Term.rec (\t:Term -> U)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> F)
      (\vt:VarType \M:Term \_:U \S:Term \_:U -> T)
      (\M:Term \_:U \N:Term \_:U -> F)
      (\vt:VarType \n:Nat -> F)
      (\vt:VarType -> F)
Definition Term.casepi = \C:(t:Term -> U1)
   \case:(vt:VarType -> T:Term -> S:Term -> C (Term.pi vt T S)) ->
   Term.rec (\t:Term -> Term.ispi t -> C t)
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.lam vt M N)))
      (\vt:VarType \M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         \_:T -> case vt M N)
      (\M:Term \_:(Term.ispi M -> C M) \N:Term \_:(Term.ispi N -> C N) ->
         F.rec (\_:F -> C (Term.app M N)))
      (\vt:VarType \n:Nat -> F.rec (\_:F -> C (Term.var vt n)))
      (\vt:VarType -> F.rec (\_:F -> C (Term.univ vt)))

Inductive KindOrProp : Gamma:VarList -> S:Term -> U =
  kind: CCTypeCheck Gamma S Term.[] -> KindOrProp Gamma S,
  prop: CCTypeCheck Gamma S Term.*  -> KindOrProp Gamma S



Definition PiRangeCorrectType = \Gamma:VarList ->
  Term.casepi (\_:Term -> U)
              (\vt0:VarType \T0:Term \S0:Term ->
	         KindOrProp (VarList.cons vt0 T0 Gamma) S0)

Definition PiRangeCorrect = 
  CCTypeCheck.rec
     (\Gamma:VarList \M:Term \S:Term \_:CCTypeCheck Gamma M S ->
      PiRangeCorrectType Gamma M)
    ;ax
    T.tt
    ;var
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     T.tt)
    ;weak
    (\Gamma:VarList \vt:VarType \T0:Term
     \prf: CCTypeCheck Gamma T0 (Term.univ vt)
     \_: PiRangeCorrectType Gamma T0 ->
     Term.casepi (\M: Term -> S:Term -> CCTypeCheck Gamma M S ->
        PiRangeCorrectType Gamma M ->
        PiRangeCorrectType (VarList.cons vt T0 Gamma) (Term.shiftvar M))
        (\vt1:VarType \T1:Term \S1:Term
	 \S:Term \_:CCTypeCheck Gamma (Term.pi vt1 T1 S1) S ->
	 KindOrProp.rec (VarList.cons vt1 T1 Gamma) S1
	    (\_:KindOrProp (VarList.cons vt1 T1 Gamma) S1 ->
	     KindOrProp (VarList.cons vt1 (Term.shiftvar T1) (VarList.cons vt T0 Gamma)) (Term.shiftn S1 Nat.1))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.[] ->
	     KindOrProp.kind (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf))
	    (\prf2:CCTypeCheck (VarList.cons vt1 T1 Gamma) S1 Term.* ->
	     KindOrProp.prop (VarList.cons vt1 (Term.shiftvar T1)
	     		     		   (VarList.cons vt T0 Gamma))
	     		     (Term.shiftn S1 Nat.1)
	         	     (CCTypeCheck.weakn vt T0 prf2
		                 Nat.1 prf)))
	(\M:Term \S:Term \_:CCTypeCheck Gamma M S
	 \_:PiRangeCorrectType Gamma M ->
	 T.tt))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \_:CCTypeCheck Gamma T (Term.univ vt) \rec:VarListTypeCheck Gamma
     \vt2:VarType \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2)
     \_:VarListTypeCheck (VarList.cons vt T Gamma) ->
     rec)
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \_:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:VarListTypeCheck (VarList.cons vt T Gamma)
     \vt2:VarType \_:CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2)
     \rec:VarListTypeCheck Gamma ->
     rec)
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \_:CCTypeCheck Gamma M (Term.pi vt T S) \rec:VarListTypeCheck Gamma
     \N:Term \_:CCTypeCheck Gamma N T \_:VarListTypeCheck Gamma ->
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:VarListTypeCheck Gamma
     \S:Term \_:ConvSymmStep T S ->
     rec)

Inductive TermClass : Gamma:VarList -> M:Term -> U =
  kind   : CCTypeCheck Gamma M Term.[] -> TermClass Gamma M,
  constr : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.[]
           -> TermClass Gamma M,
  obj    : T:Term -> CCTypeCheck Gamma M T -> CCTypeCheck Gamma T Term.*
           -> TermClass Gamma M
  
Definition Term.classify =
  CCTypeCheck.rec (\Gamma:VarList \M:Term \T:Term \_:CCTypeCheck Gamma M T ->
  		   TermClass Gamma M)
    (TermClass.kind VarList.nil Term.* CCTypeCheck.ax)
    ;var
    (\Gamma:VarList -> VarType.rec
        (\vt:VarType -> T:Term -> CCTypeCheck Gamma T (Term.univ vt) ->
	 TermClass Gamma T ->
	 TermClass (VarList.cons vt T Gamma) (Term.var vt Nat.0))
        (\T:Term \prf:CCTypeCheck Gamma T Term.[] \rec:TermClass Gamma T ->
	 TermClass.constr (VarList.cons VarType.[] T Gamma)
	 		  (Term.var VarType.[] Nat.0)
			  (Term.shiftvar T)
	                  (CCTypeCheck.var Gamma VarType.[] T prf)
	             (CCTypeCheck.weak Gamma VarType.[] T prf T Term.[] prf))
        (\T:Term \prf:CCTypeCheck Gamma T Term.* \rec:TermClass Gamma T ->
	 TermClass.obj (VarList.cons VarType.* T Gamma)
	 	       (Term.var VarType.* Nat.0)
		       (Term.shiftvar T)
	               (CCTypeCheck.var Gamma VarType.* T prf)
		       (CCTypeCheck.weak Gamma VarType.* T prf T Term.* prf)))
    ;weak
    (\Gamma:VarList \vt:VarType \T:Term
     \prfvar: CCTypeCheck Gamma T (Term.univ vt) \_: TermClass Gamma T
     \M : Term \S:Term
     \_: CCTypeCheck Gamma M S ->
     TermClass.rec Gamma M (\_:TermClass Gamma M ->
                   TermClass (VarList.cons vt T Gamma) (Term.shiftvar M))
     	;kind
        (\prf1:CCTypeCheck Gamma M Term.[] ->
	 TermClass.kind (VarList.cons vt T Gamma) (Term.shiftvar M)
	                (CCTypeCheck.weak Gamma vt T prfvar
					  M Term.[] prf1))
     	;constr
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.[] ->
	 TermClass.constr (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.[] prf2))
     	;obj
        (\T1:Term \prf1:CCTypeCheck Gamma M T1
	 \prf2:CCTypeCheck Gamma T1 Term.* ->
	 TermClass.obj (VarList.cons vt T Gamma) (Term.shiftvar M)
	 		  (Term.shiftvar T1)
	                  (CCTypeCheck.weak Gamma vt T prfvar M T1 prf1)
                          (CCTypeCheck.weak Gamma vt T prfvar T1 Term.* prf2)))
    ;pi
    (\Gamma:VarList \vt:VarType \T:Term 
     \prf1:CCTypeCheck Gamma T (Term.univ vt) \rec:TermClass Gamma T ->
     VarType.rec (\vt2:VarType -> S:Term ->
     		  CCTypeCheck (VarList.cons vt T Gamma) S (Term.univ vt2) ->
		  TermClass (VarList.cons vt T Gamma) S ->
		  TermClass Gamma (Term.pi vt T S))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.[]
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.kind Gamma (Term.pi vt T S)
	 		(CCTypeCheck.pi Gamma vt T prf1 VarType.[] S prf2))
	(\S:Term
	 \prf2:CCTypeCheck (VarList.cons vt T Gamma) S Term.*
	 \_:TermClass (VarList.cons vt T Gamma) S ->
	 TermClass.constr Gamma (Term.pi vt T S) Term.*
	 		  (CCTypeCheck.pi Gamma vt T prf1 VarType.* S prf2)
			  (CCTypeCheck.ax2 (CCTypeCheck.gammatc Gamma T
			  		                 (Term.univ vt) prf1))))
    ;lam
    (\Gamma:VarList \vt:VarType \T:Term \M:Term \S:Term
     \prf1:CCTypeCheck (VarList.cons vt T Gamma) M S
     \_:TermClass (VarList.cons vt T Gamma) M ->
     VarType.rec (\vt2:VarType -> 
     		  CCTypeCheck Gamma (Term.pi vt T S) (Term.univ vt2) ->
		  TermClass Gamma (Term.pi vt T S) ->
		  TermClass Gamma (Term.lam vt T M))
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.[]
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.constr Gamma (Term.lam vt T M) (Term.pi vt T S)
	 		  (CCTypeCheck.lam Gamma vt T M S prf1 VarType.[] prf2)
			  prf2)
	(\prf2 : CCTypeCheck Gamma (Term.pi vt T S) Term.*
	 \_:TermClass Gamma (Term.pi vt T S) ->
	 TermClass.obj Gamma (Term.lam vt T M) (Term.pi vt T S)
	 	       (CCTypeCheck.lam Gamma vt T M S prf1 VarType.* prf2)
		       prf2))
    ;app
    (\Gamma:VarList \M:Term \vt:VarType \T:Term \S:Term 
     \prf1:CCTypeCheck Gamma M (Term.pi vt T S) \_:TermClass Gamma M
     \N:Term \prf2:CCTypeCheck Gamma N T \_:TermClass Gamma N ->
     Ter
     TermClass
     TermClass Gamma (Term.app M N)
     rec)
    ;conv
    (\Gamma:VarList \M:Term \T:Term
     \_:CCTypeCheck Gamma M T \rec:TermClass Gamma M
     \S:Term \_:ConvSymmStep T S -> rec)
    

