Intuitionistic Type Theory
==========================

This directory contains an implementation of Martin-LÃ¶f style 
Intuitionistic Type Theory (ITT).

Compilation
-----------

Run ant in the main folder with

    ant create_itt_jar


Usage
-----

To run ITT from command line you need the standalone jar.  Run it as

    java -jar itt.jar DependentTypeCheck/examples/numbers.itt


Syntax
------

ITT only supports a very minimal syntax.  The expressions are
generated by this syntax

    expr := expr expr         ;; function application
            \id:expr -> expr  ;; lambda abstraction
            id:expr -> expr   ;; dependent function type
            id                ;; previously defined expression/variable
            Assume expr       ;; assumed existence of a type

The symbol `\` denotes the lambda.  Function application binds to the
left and stronger than lambda and dependent function type, which bind
to the right.  The `id:` part in dependent function type is optional
(for non-dependent function types).  If lambda abstractions are
nested, the `->` is optional before another lambda.  Note that the
`Assume` command can introduce unsoundness.

The overall syntax of a file is:

     file ::= decl*
     decl ::= Inductive id : expr = id : expr, ..., id : expr
            | Definition id = expr
            | TypeCheck expr : expr
            | Check expr = expr
            | Assume id : expr
            | Evaluate expr
            | EvaluateType expr

Every expression has a type, which is also an expression.  There are
predefined expression `U0`, `U1`, etc, the universe hierarchy.  The
expression `Ui` has the type `U(i+1)` for every natural number `i` The
universe `U0` is also denoted by `U`.  We assume `Ui` is a subtype of
`U(i+1)`, i.e., every expression of type `Ui` is also of type
`U(i+1)`.  New types can be created with the keyword `Inductive`.
See section about inductive types below.

Typechecking Rules
------------------

ITT is based on lambda calculus.  It uses the standard beta-reduction rule

    (\x -> F)y  ~~> F[x <- y]

An application of a lambda term is `(\x -> F)` rewritten by
substituting all occurrences of `x` in `F` by the argument `y` of the
application.  Furthermore we have a reduction rule for the induction
operator `T.rec` for a recursive datatype `T`

    T.rec C rule1 ... rulen (consi arg1 .. argk) ~~>
        rulei arg1 (T.rec C rule1 ... rulen arg1) ...
              argk (T.rec C rule1 ... rulen arg1)

where `(T.rec C rule1 ... rulen argi)` is omitted if `argi` is not of
type `T`.

The rewriting rules are confluent and terminating (how to prove?).  We
say terms are equal `T1 <~> T2` if they can both be rewritten to the
same term `T`, i.e. `T1 ~~>* T` and `T2 ~~>* T`.

The typechecking rules are:

     Gamma |- T : Ui/Prop
    -------------------
    Gamma, a:T |- a : T

    Gamma |- T : Ui/Prop   Gamma |- b : T2
    ---------------------------------
    Gamma, a:T |- b : T2

    Gamma |- T1 : Ui   Gamma, x:T1 |- T2 : Prop
    -----------------------------------------
      Gamma |- (x:T1 -> T2) : Prop

    Gamma |- T1 : Ui/Prop  Gamma, x:T1 |- T2 : Uj
    ---------------------------------------------
      Gamma |- (x:T1 -> T2) : U{max(i,j)}

    Gamma |- T1 : Ui   Gamma, x:T1 |- y : T2
    ----------------------------------------
      Gamma |- (\x:T1 -> y) : (x:T1 -> T2)

    Gamma |- a : (x:T1 -> T2)   Gamma |- b : T1
    -------------------------------------------
          Gamma |- a b : (\x:T1 -> T2) b

    Gamma |- Prop : U0
    Gamma |- Ui : U{i+1}

    Gamma |- T : Prop
    -------------------
    Gamma |- T : U0

    Gamma |- T : Ui
    -------------------
    Gamma |- T : U{i+1}

    Gamma |- T1 : T2   T2 <~> T3
    ----------------------------
         Gamma |- T1 : T3


Inductive Types
---------------

An inductive declaration looks like this:

    Inductive Nat : U =
        0 : Nat,
        s : Nat -> Nat

This declaration defines `Nat : U`, `Nat.0 : Nat`, `Nat.s : Nat -> Nat`, and
additionally a recursion operator `Nat.rec`.  The latter has the type

    TypeCheck Nat.rec : C:(Nat -> U{i}) -> (C Nat.0) -> 
                        (n:Nat -> rec:C n -> C (Nat.s n)) ->
                        n:Nat -> C n

This type can be used to define recursive operations or prove theorems (if `C`
is a proposition).

There are some restriction on the types used in inductive definitions.
First the type of the inductive type must be `U{i}` or `Prop` or a
function type returning `U{i}`/`Prop`.  The declared constructors must
return an element from the type.  If they use a parameter of the type,
all constructors must use it in every occurence of the type.  The type
may only occur as a return value, as a parameter, or as the return
value of a functional parameter.  You cannot create mutual recursive
types.  The type of the constructor type must be `U{i}`/`Prop` (or
lower).  If the type of the inductive type is `Prop`, the type of `C`
must be of type `I -> Prop`; for non-propositional inductive types
the type is `I -> U{i}` for an arbitrarily large `i`.

There is a builtin evaluation that is used when type-checking.  It
does beta-rewriting of lambda expressions and applies recursion
operators as far as possible.  Definitions are immediately expanded.

### Inductive Definition

An inductive definition has the form:

    Inductive Type : shared:typeargs... priv:typeargs... -> U =
        cons1 : cons1args... -> Type shared typeparams...
        ...
        consm : consmargs... -> Type shared consparams...

where `shared:typeargs... priv:typeargs...` are the parameters of the
type constructor `Type`.  The `shared` parameters are those that occur
in thee constructors, the `priv` parameters are not allowed to occur
in the constructors.  The type of an inductive type must be of type
`U1`, i.e., the type does not contain U1 or higher.  The type of each
constructor must be of type `U`.  If a parameter type of a constructor
contains the declared type contructor `Type`, it is called a recursive
parameter.  The parameter type must be of the form

    args... -> Type shared typeparams...

where args do not contain the type constructor `Type`.  This means
that all shared parameters must always occur in the right order as the
first parameters of the type constructor `Type`. Also `typeparams...`
must not contain the constructor `Type`.  The number of
`typeparams...` must always match (but this is already ensured by the
type-checker).  The variables declared in `typeargs...` are still
visible in the constructor declarations but if the variable is used,
it and all previous variables must occur in every application of
`Type` at the corresponding position.  We call these variables that
are reused *shared* between the constructors.  We call the other
variables *private*.

The inductive definition defines the new functions

    Type : shared:typeargs... -> priv:typeargs... -> U
    Type.cons1 : shared:typeargs... -> cons1args... -> Type shared typeparams...
    ...
    Type.consm : shared:typeargs... -> consmargs... -> Type shared typeparams...

and a special function

    Type.rec : shared:typeargs... ->
        C : (priv:typeargs... -> t: Type shared priv -> U1) ->
        case1 : (case1args... -> C typeparams1... (Type.cons1 shared cons1params)) ->
        ...
        casem : (casemargs... -> C typeparamsm... (Type.consm shared consmparams)) ->
        priv:typeargs... -> t : (Type shared priv)) ->
        C priv t

where case1args... is build from cons1args... by adding a new parameter after
each recursive parameter.  After a recursive parameter of the form

    v:(recparam:recargs... -> Type shared rectypeparams...)

we add a parameter 

    vHyp:(recparam:recargs... -> C rectypeparams... (v recparam))



### Examples for Inductive Type

The type declaration:

    Inductive Nat : U =
       0 : Nat,
       succ : Nat -> Nat

implicitly declares the functions

    Nat : U
    Nat.0 : Nat
    Nat.succ : Nat -> Nat
    Nat.rec : C:(Nat -> U1) ->
              case0 : C Nat.0 ->
              caseSucc : (n:Nat -> C n -> C (Nat.succ n)) ->
              n : Nat -> C n

and the rewrite rules

    Nat.rec C c0 cS Nat.0 ~~> c0
    Nat.rec C c0 cS (Nat.succ n) ~~> cS n (Nat.rec C c0 cS n)

An example for a polymorphic type is `List`:

    Inductive List : X:U -> U =
       nil  : List X,
       cons : X -> List X -> List X
    TypeCheck List : X:U -> U
    TypeCheck List.nil : X:U -> List X
    TypeCheck List.cons : X:U -> X -> List X -> List X
    TypeCheck List.rec : X:U -> C:(List X -> U1) -> caseNil : C (List.nil X) ->
          caseCons : (hd:X -> tl:List X -> C tl -> C (List.cons hd tl) ->
          t : List X -> C t

In the above example `X` was shared.  An example for a mixture of shared
and private is (here `A`, `a` are shared):

    Inductive Id : A:U -> a:A -> b:A -> U =
       refl : Id A a a
    TypeCheck Id : A:U -> a:A -> b:A -> U
    TypeCheck Id.refl : A:U -> a:A -> Id A a a
    TypeCheck Id.rec : A:U -> a:A -> C:(b:A -> Id A a b -> U1) ->
          caseRefl : C a (C.refl A a) ->
          b : A -> t : Id A a b -> C b t

An example where the recursive argument is a function:

    Inductive W : A:U -> B:(A->U) -> U =
       sup : a:A -> b:(B a -> W A B) -> W A B
    TypeCheck W : A:U -> B:(A->U) -> U
    TypeCheck W.sup : A:U -> B:(A->U) -> a:A -> b:(B a -> W A B) -> W A B
    TypeCheck W.rec : A:U -> B:(A->U) -> C:(W A B -> U1) ->
       caseSub : (a:A -> b:(B a -> W A B) -> (v:B a -> C (b v)) -> C (W.sup A B a b)) ->
       t : W A B -> C t

Hidden Parameters
-----------------

Some parameters are implicitly determined by the type of the previous
parameters.  E.g. in the example above `Id A a b`, the parameter `A`
must always be the type of the parameter `a`.  These parameters can be
omitted.

For every dependent function type we compute whether the first parameter
may be omitted.  This is the case if it is of the form

     A:U -> a:A -> ....

or

     A1:T1 -> ... -> Ak:Tk -> B:TC (... Ai ...) -> ....

where A1,...,Ak all occur as parameters of TC and TC is an inductive
type.  In the second case, if A1 is omitted, also A2....Ak must be
omitted.  Note that "B:TC (... Ai ....)" could again be a parameter
that is allowed to be omitted.

There is one possible ambiguity introduced by this.  For a function `f
: A:U1 -> a:A -> B A a` and a parameter `M:U`, the expression `f M`
can be the abbreviation for `f U M : B U M`, but `f M : a:M -> B M a`
would also type-check.  Currently, we always expand it to `f U M`; to
get an expression `f M` you have to write it as
`(\f:(A:U->a:A ->B A a) f) f M`

TODO
----

The only really useful part of the type hierarchy is to prove
`I Bool.tt Bool.ff -> F`, e.g.,

    Inductive F : U =
    Inductive I : A:U->a:A->b:A->U = r: I a a
    Inductive Bool : U = tt:Bool, ff:Bool
    Definition Bool.inj = I.rec Bool.tt
        (\x:Bool \_:I Bool.tt x -> Bool.rec (\_:Bool -> U) Bool F x)
        Bool.tt Bool.ff
    TypeCheck Bool.inj : I Bool.tt Bool.ff -> F
